// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: proto/admin/v1/admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import { UpstreamServiceConfig } from "../../config/v1/upstream_service";
import { User } from "../../config/v1/user";
import { Tool } from "../../mcp_router/v1/mcp_router";

export const protobufPackage = "mcpany.admin.v1";

export interface ClearCacheRequest {
}

export interface ClearCacheResponse {
}

export interface ListServicesRequest {
}

export interface ListServicesResponse {
  /** @deprecated */
  services: UpstreamServiceConfig[];
  serviceStates: ServiceState[];
}

export interface ServiceState {
  config?:
    | UpstreamServiceConfig
    | undefined;
  /** "OK", "ERROR", "CONNECTING" */
  status: string;
  error: string;
}

export interface GetServiceRequest {
  serviceId: string;
}

export interface GetServiceResponse {
  /** @deprecated */
  service?: UpstreamServiceConfig | undefined;
  serviceState?: ServiceState | undefined;
}

export interface ListToolsRequest {
}

export interface ListToolsResponse {
  tools: Tool[];
}

export interface GetToolRequest {
  toolName: string;
}

export interface GetToolResponse {
  tool?: Tool | undefined;
}

export interface PreviewServiceConfigRequest {
  service?: UpstreamServiceConfig | undefined;
}

export interface PreviewServiceConfigResponse {
  service?: UpstreamServiceConfig | undefined;
}

export interface CreateUserRequest {
  user?: User | undefined;
}

export interface CreateUserResponse {
  user?: User | undefined;
}

export interface GetUserRequest {
  userId: string;
}

export interface GetUserResponse {
  user?: User | undefined;
}

export interface ListUsersRequest {
}

export interface ListUsersResponse {
  users: User[];
}

export interface UpdateUserRequest {
  /** Field mask to specify which fields to update (optional for now, full replace). */
  user?: User | undefined;
}

export interface UpdateUserResponse {
  user?: User | undefined;
}

export interface DeleteUserRequest {
  userId: string;
}

export interface DeleteUserResponse {
}

export interface GetDiscoveryStatusRequest {
}

export interface GetDiscoveryStatusResponse {
  providers: DiscoveryProviderStatus[];
}

export interface DiscoveryProviderStatus {
  name: string;
  /** "OK", "ERROR" */
  status: string;
  lastError: string;
  /** ISO 8601 */
  lastRunAt: string;
  discoveredCount: number;
}

export interface ListAuditLogsRequest {
  /** ISO 8601 */
  startTime: string;
  /** ISO 8601 */
  endTime: string;
  toolName: string;
  userId: string;
  profileId: string;
  limit: number;
  offset: number;
}

export interface ListAuditLogsResponse {
  entries: AuditLogEntry[];
}

export interface AuditLogEntry {
  /** ISO 8601 */
  timestamp: string;
  toolName: string;
  userId: string;
  profileId: string;
  /** JSON string */
  arguments: string;
  /** JSON string */
  result: string;
  error: string;
  duration: string;
  durationMs: Long;
}

function createBaseClearCacheRequest(): ClearCacheRequest {
  return {};
}

export const ClearCacheRequest: MessageFns<ClearCacheRequest> = {
  encode(_: ClearCacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearCacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearCacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearCacheRequest {
    return {};
  },

  toJSON(_: ClearCacheRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearCacheRequest>, I>>(base?: I): ClearCacheRequest {
    return ClearCacheRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearCacheRequest>, I>>(_: I): ClearCacheRequest {
    const message = createBaseClearCacheRequest();
    return message;
  },
};

function createBaseClearCacheResponse(): ClearCacheResponse {
  return {};
}

export const ClearCacheResponse: MessageFns<ClearCacheResponse> = {
  encode(_: ClearCacheResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearCacheResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearCacheResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearCacheResponse {
    return {};
  },

  toJSON(_: ClearCacheResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearCacheResponse>, I>>(base?: I): ClearCacheResponse {
    return ClearCacheResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearCacheResponse>, I>>(_: I): ClearCacheResponse {
    const message = createBaseClearCacheResponse();
    return message;
  },
};

function createBaseListServicesRequest(): ListServicesRequest {
  return {};
}

export const ListServicesRequest: MessageFns<ListServicesRequest> = {
  encode(_: ListServicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListServicesRequest {
    return {};
  },

  toJSON(_: ListServicesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServicesRequest>, I>>(base?: I): ListServicesRequest {
    return ListServicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServicesRequest>, I>>(_: I): ListServicesRequest {
    const message = createBaseListServicesRequest();
    return message;
  },
};

function createBaseListServicesResponse(): ListServicesResponse {
  return { services: [], serviceStates: [] };
}

export const ListServicesResponse: MessageFns<ListServicesResponse> = {
  encode(message: ListServicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.services) {
      UpstreamServiceConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.serviceStates) {
      ServiceState.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.services.push(UpstreamServiceConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceStates.push(ServiceState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesResponse {
    return {
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => UpstreamServiceConfig.fromJSON(e))
        : [],
      serviceStates: globalThis.Array.isArray(object?.serviceStates)
        ? object.serviceStates.map((e: any) => ServiceState.fromJSON(e))
        : globalThis.Array.isArray(object?.service_states)
        ? object.service_states.map((e: any) => ServiceState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListServicesResponse): unknown {
    const obj: any = {};
    if (message.services?.length) {
      obj.services = message.services.map((e) => UpstreamServiceConfig.toJSON(e));
    }
    if (message.serviceStates?.length) {
      obj.serviceStates = message.serviceStates.map((e) => ServiceState.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServicesResponse>, I>>(base?: I): ListServicesResponse {
    return ListServicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServicesResponse>, I>>(object: I): ListServicesResponse {
    const message = createBaseListServicesResponse();
    message.services = object.services?.map((e) => UpstreamServiceConfig.fromPartial(e)) || [];
    message.serviceStates = object.serviceStates?.map((e) => ServiceState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServiceState(): ServiceState {
  return { config: undefined, status: "", error: "" };
}

export const ServiceState: MessageFns<ServiceState> = {
  encode(message: ServiceState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      UpstreamServiceConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = UpstreamServiceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceState {
    return {
      config: isSet(object.config) ? UpstreamServiceConfig.fromJSON(object.config) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ServiceState): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = UpstreamServiceConfig.toJSON(message.config);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceState>, I>>(base?: I): ServiceState {
    return ServiceState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceState>, I>>(object: I): ServiceState {
    const message = createBaseServiceState();
    message.config = (object.config !== undefined && object.config !== null)
      ? UpstreamServiceConfig.fromPartial(object.config)
      : undefined;
    message.status = object.status ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetServiceRequest(): GetServiceRequest {
  return { serviceId: "" };
}

export const GetServiceRequest: MessageFns<GetServiceRequest> = {
  encode(message: GetServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceRequest {
    return {
      serviceId: isSet(object.serviceId)
        ? globalThis.String(object.serviceId)
        : isSet(object.service_id)
        ? globalThis.String(object.service_id)
        : "",
    };
  },

  toJSON(message: GetServiceRequest): unknown {
    const obj: any = {};
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceRequest>, I>>(base?: I): GetServiceRequest {
    return GetServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceRequest>, I>>(object: I): GetServiceRequest {
    const message = createBaseGetServiceRequest();
    message.serviceId = object.serviceId ?? "";
    return message;
  },
};

function createBaseGetServiceResponse(): GetServiceResponse {
  return { service: undefined, serviceState: undefined };
}

export const GetServiceResponse: MessageFns<GetServiceResponse> = {
  encode(message: GetServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== undefined) {
      UpstreamServiceConfig.encode(message.service, writer.uint32(10).fork()).join();
    }
    if (message.serviceState !== undefined) {
      ServiceState.encode(message.serviceState, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = UpstreamServiceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceState = ServiceState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceResponse {
    return {
      service: isSet(object.service) ? UpstreamServiceConfig.fromJSON(object.service) : undefined,
      serviceState: isSet(object.serviceState)
        ? ServiceState.fromJSON(object.serviceState)
        : isSet(object.service_state)
        ? ServiceState.fromJSON(object.service_state)
        : undefined,
    };
  },

  toJSON(message: GetServiceResponse): unknown {
    const obj: any = {};
    if (message.service !== undefined) {
      obj.service = UpstreamServiceConfig.toJSON(message.service);
    }
    if (message.serviceState !== undefined) {
      obj.serviceState = ServiceState.toJSON(message.serviceState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceResponse>, I>>(base?: I): GetServiceResponse {
    return GetServiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceResponse>, I>>(object: I): GetServiceResponse {
    const message = createBaseGetServiceResponse();
    message.service = (object.service !== undefined && object.service !== null)
      ? UpstreamServiceConfig.fromPartial(object.service)
      : undefined;
    message.serviceState = (object.serviceState !== undefined && object.serviceState !== null)
      ? ServiceState.fromPartial(object.serviceState)
      : undefined;
    return message;
  },
};

function createBaseListToolsRequest(): ListToolsRequest {
  return {};
}

export const ListToolsRequest: MessageFns<ListToolsRequest> = {
  encode(_: ListToolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListToolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListToolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListToolsRequest {
    return {};
  },

  toJSON(_: ListToolsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListToolsRequest>, I>>(base?: I): ListToolsRequest {
    return ListToolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListToolsRequest>, I>>(_: I): ListToolsRequest {
    const message = createBaseListToolsRequest();
    return message;
  },
};

function createBaseListToolsResponse(): ListToolsResponse {
  return { tools: [] };
}

export const ListToolsResponse: MessageFns<ListToolsResponse> = {
  encode(message: ListToolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tools) {
      Tool.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListToolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListToolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tools.push(Tool.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListToolsResponse {
    return { tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => Tool.fromJSON(e)) : [] };
  },

  toJSON(message: ListToolsResponse): unknown {
    const obj: any = {};
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => Tool.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListToolsResponse>, I>>(base?: I): ListToolsResponse {
    return ListToolsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListToolsResponse>, I>>(object: I): ListToolsResponse {
    const message = createBaseListToolsResponse();
    message.tools = object.tools?.map((e) => Tool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetToolRequest(): GetToolRequest {
  return { toolName: "" };
}

export const GetToolRequest: MessageFns<GetToolRequest> = {
  encode(message: GetToolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolName !== "") {
      writer.uint32(10).string(message.toolName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetToolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetToolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetToolRequest {
    return {
      toolName: isSet(object.toolName)
        ? globalThis.String(object.toolName)
        : isSet(object.tool_name)
        ? globalThis.String(object.tool_name)
        : "",
    };
  },

  toJSON(message: GetToolRequest): unknown {
    const obj: any = {};
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetToolRequest>, I>>(base?: I): GetToolRequest {
    return GetToolRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetToolRequest>, I>>(object: I): GetToolRequest {
    const message = createBaseGetToolRequest();
    message.toolName = object.toolName ?? "";
    return message;
  },
};

function createBaseGetToolResponse(): GetToolResponse {
  return { tool: undefined };
}

export const GetToolResponse: MessageFns<GetToolResponse> = {
  encode(message: GetToolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tool !== undefined) {
      Tool.encode(message.tool, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetToolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetToolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tool = Tool.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetToolResponse {
    return { tool: isSet(object.tool) ? Tool.fromJSON(object.tool) : undefined };
  },

  toJSON(message: GetToolResponse): unknown {
    const obj: any = {};
    if (message.tool !== undefined) {
      obj.tool = Tool.toJSON(message.tool);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetToolResponse>, I>>(base?: I): GetToolResponse {
    return GetToolResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetToolResponse>, I>>(object: I): GetToolResponse {
    const message = createBaseGetToolResponse();
    message.tool = (object.tool !== undefined && object.tool !== null) ? Tool.fromPartial(object.tool) : undefined;
    return message;
  },
};

function createBasePreviewServiceConfigRequest(): PreviewServiceConfigRequest {
  return { service: undefined };
}

export const PreviewServiceConfigRequest: MessageFns<PreviewServiceConfigRequest> = {
  encode(message: PreviewServiceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== undefined) {
      UpstreamServiceConfig.encode(message.service, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviewServiceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewServiceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = UpstreamServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewServiceConfigRequest {
    return { service: isSet(object.service) ? UpstreamServiceConfig.fromJSON(object.service) : undefined };
  },

  toJSON(message: PreviewServiceConfigRequest): unknown {
    const obj: any = {};
    if (message.service !== undefined) {
      obj.service = UpstreamServiceConfig.toJSON(message.service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviewServiceConfigRequest>, I>>(base?: I): PreviewServiceConfigRequest {
    return PreviewServiceConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviewServiceConfigRequest>, I>>(object: I): PreviewServiceConfigRequest {
    const message = createBasePreviewServiceConfigRequest();
    message.service = (object.service !== undefined && object.service !== null)
      ? UpstreamServiceConfig.fromPartial(object.service)
      : undefined;
    return message;
  },
};

function createBasePreviewServiceConfigResponse(): PreviewServiceConfigResponse {
  return { service: undefined };
}

export const PreviewServiceConfigResponse: MessageFns<PreviewServiceConfigResponse> = {
  encode(message: PreviewServiceConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== undefined) {
      UpstreamServiceConfig.encode(message.service, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviewServiceConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewServiceConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = UpstreamServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewServiceConfigResponse {
    return { service: isSet(object.service) ? UpstreamServiceConfig.fromJSON(object.service) : undefined };
  },

  toJSON(message: PreviewServiceConfigResponse): unknown {
    const obj: any = {};
    if (message.service !== undefined) {
      obj.service = UpstreamServiceConfig.toJSON(message.service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviewServiceConfigResponse>, I>>(base?: I): PreviewServiceConfigResponse {
    return PreviewServiceConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviewServiceConfigResponse>, I>>(object: I): PreviewServiceConfigResponse {
    const message = createBasePreviewServiceConfigResponse();
    message.service = (object.service !== undefined && object.service !== null)
      ? UpstreamServiceConfig.fromPartial(object.service)
      : undefined;
    return message;
  },
};

function createBaseCreateUserRequest(): CreateUserRequest {
  return { user: undefined };
}

export const CreateUserRequest: MessageFns<CreateUserRequest> = {
  encode(message: CreateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserRequest {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: CreateUserRequest): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserRequest>, I>>(base?: I): CreateUserRequest {
    return CreateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserRequest>, I>>(object: I): CreateUserRequest {
    const message = createBaseCreateUserRequest();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseCreateUserResponse(): CreateUserResponse {
  return { user: undefined };
}

export const CreateUserResponse: MessageFns<CreateUserResponse> = {
  encode(message: CreateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: CreateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserResponse>, I>>(base?: I): CreateUserResponse {
    return CreateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserResponse>, I>>(object: I): CreateUserResponse {
    const message = createBaseCreateUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { userId: "" };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
    };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { user: undefined };
}

export const GetUserResponse: MessageFns<GetUserResponse> = {
  encode(message: GetUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseListUsersRequest(): ListUsersRequest {
  return {};
}

export const ListUsersRequest: MessageFns<ListUsersRequest> = {
  encode(_: ListUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListUsersRequest {
    return {};
  },

  toJSON(_: ListUsersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersRequest>, I>>(base?: I): ListUsersRequest {
    return ListUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersRequest>, I>>(_: I): ListUsersRequest {
    const message = createBaseListUsersRequest();
    return message;
  },
};

function createBaseListUsersResponse(): ListUsersResponse {
  return { users: [] };
}

export const ListUsersResponse: MessageFns<ListUsersResponse> = {
  encode(message: ListUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersResponse {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: ListUsersResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersResponse>, I>>(base?: I): ListUsersResponse {
    return ListUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersResponse>, I>>(object: I): ListUsersResponse {
    const message = createBaseListUsersResponse();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { user: undefined };
}

export const UpdateUserRequest: MessageFns<UpdateUserRequest> = {
  encode(message: UpdateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserRequest {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: UpdateUserRequest): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(base?: I): UpdateUserRequest {
    return UpdateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(object: I): UpdateUserRequest {
    const message = createBaseUpdateUserRequest();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUpdateUserResponse(): UpdateUserResponse {
  return { user: undefined };
}

export const UpdateUserResponse: MessageFns<UpdateUserResponse> = {
  encode(message: UpdateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: UpdateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(base?: I): UpdateUserResponse {
    return UpdateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(object: I): UpdateUserResponse {
    const message = createBaseUpdateUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { userId: "" };
}

export const DeleteUserRequest: MessageFns<DeleteUserRequest> = {
  encode(message: DeleteUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
    };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return {};
}

export const DeleteUserResponse: MessageFns<DeleteUserResponse> = {
  encode(_: DeleteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteUserResponse {
    return {};
  },

  toJSON(_: DeleteUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(_: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    return message;
  },
};

function createBaseGetDiscoveryStatusRequest(): GetDiscoveryStatusRequest {
  return {};
}

export const GetDiscoveryStatusRequest: MessageFns<GetDiscoveryStatusRequest> = {
  encode(_: GetDiscoveryStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDiscoveryStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDiscoveryStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetDiscoveryStatusRequest {
    return {};
  },

  toJSON(_: GetDiscoveryStatusRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDiscoveryStatusRequest>, I>>(base?: I): GetDiscoveryStatusRequest {
    return GetDiscoveryStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDiscoveryStatusRequest>, I>>(_: I): GetDiscoveryStatusRequest {
    const message = createBaseGetDiscoveryStatusRequest();
    return message;
  },
};

function createBaseGetDiscoveryStatusResponse(): GetDiscoveryStatusResponse {
  return { providers: [] };
}

export const GetDiscoveryStatusResponse: MessageFns<GetDiscoveryStatusResponse> = {
  encode(message: GetDiscoveryStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.providers) {
      DiscoveryProviderStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDiscoveryStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDiscoveryStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providers.push(DiscoveryProviderStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDiscoveryStatusResponse {
    return {
      providers: globalThis.Array.isArray(object?.providers)
        ? object.providers.map((e: any) => DiscoveryProviderStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetDiscoveryStatusResponse): unknown {
    const obj: any = {};
    if (message.providers?.length) {
      obj.providers = message.providers.map((e) => DiscoveryProviderStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDiscoveryStatusResponse>, I>>(base?: I): GetDiscoveryStatusResponse {
    return GetDiscoveryStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDiscoveryStatusResponse>, I>>(object: I): GetDiscoveryStatusResponse {
    const message = createBaseGetDiscoveryStatusResponse();
    message.providers = object.providers?.map((e) => DiscoveryProviderStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiscoveryProviderStatus(): DiscoveryProviderStatus {
  return { name: "", status: "", lastError: "", lastRunAt: "", discoveredCount: 0 };
}

export const DiscoveryProviderStatus: MessageFns<DiscoveryProviderStatus> = {
  encode(message: DiscoveryProviderStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.lastError !== "") {
      writer.uint32(26).string(message.lastError);
    }
    if (message.lastRunAt !== "") {
      writer.uint32(34).string(message.lastRunAt);
    }
    if (message.discoveredCount !== 0) {
      writer.uint32(40).int32(message.discoveredCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscoveryProviderStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscoveryProviderStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastError = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastRunAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.discoveredCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscoveryProviderStatus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      lastError: isSet(object.lastError)
        ? globalThis.String(object.lastError)
        : isSet(object.last_error)
        ? globalThis.String(object.last_error)
        : "",
      lastRunAt: isSet(object.lastRunAt)
        ? globalThis.String(object.lastRunAt)
        : isSet(object.last_run_at)
        ? globalThis.String(object.last_run_at)
        : "",
      discoveredCount: isSet(object.discoveredCount)
        ? globalThis.Number(object.discoveredCount)
        : isSet(object.discovered_count)
        ? globalThis.Number(object.discovered_count)
        : 0,
    };
  },

  toJSON(message: DiscoveryProviderStatus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.lastError !== "") {
      obj.lastError = message.lastError;
    }
    if (message.lastRunAt !== "") {
      obj.lastRunAt = message.lastRunAt;
    }
    if (message.discoveredCount !== 0) {
      obj.discoveredCount = Math.round(message.discoveredCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscoveryProviderStatus>, I>>(base?: I): DiscoveryProviderStatus {
    return DiscoveryProviderStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscoveryProviderStatus>, I>>(object: I): DiscoveryProviderStatus {
    const message = createBaseDiscoveryProviderStatus();
    message.name = object.name ?? "";
    message.status = object.status ?? "";
    message.lastError = object.lastError ?? "";
    message.lastRunAt = object.lastRunAt ?? "";
    message.discoveredCount = object.discoveredCount ?? 0;
    return message;
  },
};

function createBaseListAuditLogsRequest(): ListAuditLogsRequest {
  return { startTime: "", endTime: "", toolName: "", userId: "", profileId: "", limit: 0, offset: 0 };
}

export const ListAuditLogsRequest: MessageFns<ListAuditLogsRequest> = {
  encode(message: ListAuditLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== "") {
      writer.uint32(10).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(18).string(message.endTime);
    }
    if (message.toolName !== "") {
      writer.uint32(26).string(message.toolName);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.profileId !== "") {
      writer.uint32(42).string(message.profileId);
    }
    if (message.limit !== 0) {
      writer.uint32(48).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(56).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuditLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditLogsRequest {
    return {
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : isSet(object.start_time)
        ? globalThis.String(object.start_time)
        : "",
      endTime: isSet(object.endTime)
        ? globalThis.String(object.endTime)
        : isSet(object.end_time)
        ? globalThis.String(object.end_time)
        : "",
      toolName: isSet(object.toolName)
        ? globalThis.String(object.toolName)
        : isSet(object.tool_name)
        ? globalThis.String(object.tool_name)
        : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: ListAuditLogsRequest): unknown {
    const obj: any = {};
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditLogsRequest>, I>>(base?: I): ListAuditLogsRequest {
    return ListAuditLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditLogsRequest>, I>>(object: I): ListAuditLogsRequest {
    const message = createBaseListAuditLogsRequest();
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.toolName = object.toolName ?? "";
    message.userId = object.userId ?? "";
    message.profileId = object.profileId ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseListAuditLogsResponse(): ListAuditLogsResponse {
  return { entries: [] };
}

export const ListAuditLogsResponse: MessageFns<ListAuditLogsResponse> = {
  encode(message: ListAuditLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      AuditLogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuditLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditLogsResponse {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => AuditLogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListAuditLogsResponse): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => AuditLogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditLogsResponse>, I>>(base?: I): ListAuditLogsResponse {
    return ListAuditLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditLogsResponse>, I>>(object: I): ListAuditLogsResponse {
    const message = createBaseListAuditLogsResponse();
    message.entries = object.entries?.map((e) => AuditLogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAuditLogEntry(): AuditLogEntry {
  return {
    timestamp: "",
    toolName: "",
    userId: "",
    profileId: "",
    arguments: "",
    result: "",
    error: "",
    duration: "",
    durationMs: Long.ZERO,
  };
}

export const AuditLogEntry: MessageFns<AuditLogEntry> = {
  encode(message: AuditLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "") {
      writer.uint32(10).string(message.timestamp);
    }
    if (message.toolName !== "") {
      writer.uint32(18).string(message.toolName);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.profileId !== "") {
      writer.uint32(34).string(message.profileId);
    }
    if (message.arguments !== "") {
      writer.uint32(42).string(message.arguments);
    }
    if (message.result !== "") {
      writer.uint32(50).string(message.result);
    }
    if (message.error !== "") {
      writer.uint32(58).string(message.error);
    }
    if (message.duration !== "") {
      writer.uint32(66).string(message.duration);
    }
    if (!message.durationMs.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.durationMs.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.result = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.duration = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.durationMs = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLogEntry {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      toolName: isSet(object.toolName)
        ? globalThis.String(object.toolName)
        : isSet(object.tool_name)
        ? globalThis.String(object.tool_name)
        : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      duration: isSet(object.duration) ? globalThis.String(object.duration) : "",
      durationMs: isSet(object.durationMs)
        ? Long.fromValue(object.durationMs)
        : isSet(object.duration_ms)
        ? Long.fromValue(object.duration_ms)
        : Long.ZERO,
    };
  },

  toJSON(message: AuditLogEntry): unknown {
    const obj: any = {};
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.arguments !== "") {
      obj.arguments = message.arguments;
    }
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.duration !== "") {
      obj.duration = message.duration;
    }
    if (!message.durationMs.equals(Long.ZERO)) {
      obj.durationMs = (message.durationMs || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLogEntry>, I>>(base?: I): AuditLogEntry {
    return AuditLogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLogEntry>, I>>(object: I): AuditLogEntry {
    const message = createBaseAuditLogEntry();
    message.timestamp = object.timestamp ?? "";
    message.toolName = object.toolName ?? "";
    message.userId = object.userId ?? "";
    message.profileId = object.profileId ?? "";
    message.arguments = object.arguments ?? "";
    message.result = object.result ?? "";
    message.error = object.error ?? "";
    message.duration = object.duration ?? "";
    message.durationMs = (object.durationMs !== undefined && object.durationMs !== null)
      ? Long.fromValue(object.durationMs)
      : Long.ZERO;
    return message;
  },
};

/** AdminService provides administrative operations for the MCP Any server. */
export interface AdminService {
  /** ClearCache clears all cached data in the server. */
  ClearCache(request: DeepPartial<ClearCacheRequest>, metadata?: grpc.Metadata): Promise<ClearCacheResponse>;
  /** ListServices returns all registered services. */
  ListServices(request: DeepPartial<ListServicesRequest>, metadata?: grpc.Metadata): Promise<ListServicesResponse>;
  /** GetService returns a specific service by ID. */
  GetService(request: DeepPartial<GetServiceRequest>, metadata?: grpc.Metadata): Promise<GetServiceResponse>;
  /** ListTools returns all registered tools. */
  ListTools(request: DeepPartial<ListToolsRequest>, metadata?: grpc.Metadata): Promise<ListToolsResponse>;
  /** GetTool returns a specific tool by name. */
  GetTool(request: DeepPartial<GetToolRequest>, metadata?: grpc.Metadata): Promise<GetToolResponse>;
  /**
   * PreviewServiceConfig generates a preview of the service configuration (e.g. discovered tools)
   * without saving it.
   */
  PreviewServiceConfig(
    request: DeepPartial<PreviewServiceConfigRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PreviewServiceConfigResponse>;
  /** CreateUser creates a new user. */
  CreateUser(request: DeepPartial<CreateUserRequest>, metadata?: grpc.Metadata): Promise<CreateUserResponse>;
  /** GetUser returns a specific user by ID. */
  GetUser(request: DeepPartial<GetUserRequest>, metadata?: grpc.Metadata): Promise<GetUserResponse>;
  /** ListUsers returns all registered users. */
  ListUsers(request: DeepPartial<ListUsersRequest>, metadata?: grpc.Metadata): Promise<ListUsersResponse>;
  /** UpdateUser updates an existing user. */
  UpdateUser(request: DeepPartial<UpdateUserRequest>, metadata?: grpc.Metadata): Promise<UpdateUserResponse>;
  /** DeleteUser deletes a user by ID. */
  DeleteUser(request: DeepPartial<DeleteUserRequest>, metadata?: grpc.Metadata): Promise<DeleteUserResponse>;
  /** GetDiscoveryStatus returns the status of auto-discovery providers. */
  GetDiscoveryStatus(
    request: DeepPartial<GetDiscoveryStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetDiscoveryStatusResponse>;
  /** ListAuditLogs returns audit logs matching the filter. */
  ListAuditLogs(request: DeepPartial<ListAuditLogsRequest>, metadata?: grpc.Metadata): Promise<ListAuditLogsResponse>;
}

export class AdminServiceClientImpl implements AdminService {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.ClearCache = this.ClearCache.bind(this);
    this.ListServices = this.ListServices.bind(this);
    this.GetService = this.GetService.bind(this);
    this.ListTools = this.ListTools.bind(this);
    this.GetTool = this.GetTool.bind(this);
    this.PreviewServiceConfig = this.PreviewServiceConfig.bind(this);
    this.CreateUser = this.CreateUser.bind(this);
    this.GetUser = this.GetUser.bind(this);
    this.ListUsers = this.ListUsers.bind(this);
    this.UpdateUser = this.UpdateUser.bind(this);
    this.DeleteUser = this.DeleteUser.bind(this);
    this.GetDiscoveryStatus = this.GetDiscoveryStatus.bind(this);
    this.ListAuditLogs = this.ListAuditLogs.bind(this);
  }

  ClearCache(request: DeepPartial<ClearCacheRequest>, metadata?: grpc.Metadata): Promise<ClearCacheResponse> {
    return this.rpc.unary(AdminServiceClearCacheDesc, ClearCacheRequest.fromPartial(request), metadata);
  }

  ListServices(request: DeepPartial<ListServicesRequest>, metadata?: grpc.Metadata): Promise<ListServicesResponse> {
    return this.rpc.unary(AdminServiceListServicesDesc, ListServicesRequest.fromPartial(request), metadata);
  }

  GetService(request: DeepPartial<GetServiceRequest>, metadata?: grpc.Metadata): Promise<GetServiceResponse> {
    return this.rpc.unary(AdminServiceGetServiceDesc, GetServiceRequest.fromPartial(request), metadata);
  }

  ListTools(request: DeepPartial<ListToolsRequest>, metadata?: grpc.Metadata): Promise<ListToolsResponse> {
    return this.rpc.unary(AdminServiceListToolsDesc, ListToolsRequest.fromPartial(request), metadata);
  }

  GetTool(request: DeepPartial<GetToolRequest>, metadata?: grpc.Metadata): Promise<GetToolResponse> {
    return this.rpc.unary(AdminServiceGetToolDesc, GetToolRequest.fromPartial(request), metadata);
  }

  PreviewServiceConfig(
    request: DeepPartial<PreviewServiceConfigRequest>,
    metadata?: grpc.Metadata,
  ): Promise<PreviewServiceConfigResponse> {
    return this.rpc.unary(
      AdminServicePreviewServiceConfigDesc,
      PreviewServiceConfigRequest.fromPartial(request),
      metadata,
    );
  }

  CreateUser(request: DeepPartial<CreateUserRequest>, metadata?: grpc.Metadata): Promise<CreateUserResponse> {
    return this.rpc.unary(AdminServiceCreateUserDesc, CreateUserRequest.fromPartial(request), metadata);
  }

  GetUser(request: DeepPartial<GetUserRequest>, metadata?: grpc.Metadata): Promise<GetUserResponse> {
    return this.rpc.unary(AdminServiceGetUserDesc, GetUserRequest.fromPartial(request), metadata);
  }

  ListUsers(request: DeepPartial<ListUsersRequest>, metadata?: grpc.Metadata): Promise<ListUsersResponse> {
    return this.rpc.unary(AdminServiceListUsersDesc, ListUsersRequest.fromPartial(request), metadata);
  }

  UpdateUser(request: DeepPartial<UpdateUserRequest>, metadata?: grpc.Metadata): Promise<UpdateUserResponse> {
    return this.rpc.unary(AdminServiceUpdateUserDesc, UpdateUserRequest.fromPartial(request), metadata);
  }

  DeleteUser(request: DeepPartial<DeleteUserRequest>, metadata?: grpc.Metadata): Promise<DeleteUserResponse> {
    return this.rpc.unary(AdminServiceDeleteUserDesc, DeleteUserRequest.fromPartial(request), metadata);
  }

  GetDiscoveryStatus(
    request: DeepPartial<GetDiscoveryStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetDiscoveryStatusResponse> {
    return this.rpc.unary(AdminServiceGetDiscoveryStatusDesc, GetDiscoveryStatusRequest.fromPartial(request), metadata);
  }

  ListAuditLogs(request: DeepPartial<ListAuditLogsRequest>, metadata?: grpc.Metadata): Promise<ListAuditLogsResponse> {
    return this.rpc.unary(AdminServiceListAuditLogsDesc, ListAuditLogsRequest.fromPartial(request), metadata);
  }
}

export const AdminServiceDesc = { serviceName: "mcpany.admin.v1.AdminService" };

export const AdminServiceClearCacheDesc: UnaryMethodDefinitionish = {
  methodName: "ClearCache",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ClearCacheRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ClearCacheResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceListServicesDesc: UnaryMethodDefinitionish = {
  methodName: "ListServices",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListServicesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListServicesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetServiceDesc: UnaryMethodDefinitionish = {
  methodName: "GetService",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetServiceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceListToolsDesc: UnaryMethodDefinitionish = {
  methodName: "ListTools",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListToolsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListToolsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetToolDesc: UnaryMethodDefinitionish = {
  methodName: "GetTool",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetToolRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetToolResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServicePreviewServiceConfigDesc: UnaryMethodDefinitionish = {
  methodName: "PreviewServiceConfig",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PreviewServiceConfigRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PreviewServiceConfigResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceCreateUserDesc: UnaryMethodDefinitionish = {
  methodName: "CreateUser",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateUserRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CreateUserResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetUserDesc: UnaryMethodDefinitionish = {
  methodName: "GetUser",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetUserRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetUserResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceListUsersDesc: UnaryMethodDefinitionish = {
  methodName: "ListUsers",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListUsersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListUsersResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceUpdateUserDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateUser",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpdateUserRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpdateUserResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceDeleteUserDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteUser",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteUserRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteUserResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceGetDiscoveryStatusDesc: UnaryMethodDefinitionish = {
  methodName: "GetDiscoveryStatus",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetDiscoveryStatusRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetDiscoveryStatusResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AdminServiceListAuditLogsDesc: UnaryMethodDefinitionish = {
  methodName: "ListAuditLogs",
  service: AdminServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListAuditLogsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListAuditLogsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
