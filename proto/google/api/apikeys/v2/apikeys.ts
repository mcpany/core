// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: google/api/apikeys/v2/apikeys.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import { Operation } from "../../../longrunning/operations";
import { FieldMask } from "../../../protobuf/field_mask";
import { Key } from "./resources";

export const protobufPackage = "google.api.apikeys.v2";

/** Request message for `CreateKey` method. */
export interface CreateKeyRequest {
  /** Required. The project in which the API key is created. */
  parent: string;
  /**
   * Required. The API key fields to set at creation time.
   * You can configure only the `display_name`, `restrictions`, and
   * `annotations` fields.
   */
  key?:
    | Key
    | undefined;
  /**
   * User specified key id (optional). If specified, it will become the final
   * component of the key resource name.
   *
   * The id must be unique within the project, must conform with RFC-1034,
   * is restricted to lower-cased letters, and has a maximum length of 63
   * characters. In another word, the id must match the regular
   * expression: `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   *
   * The id must NOT be a UUID-like string.
   */
  keyId: string;
}

/** Request message for `ListKeys` method. */
export interface ListKeysRequest {
  /** Required. Lists all API keys associated with this project. */
  parent: string;
  /** Optional. Specifies the maximum number of results to be returned at a time. */
  pageSize: number;
  /** Optional. Requests a specific page of results. */
  pageToken: string;
  /**
   * Optional. Indicate that keys deleted in the past 30 days should also be
   * returned.
   */
  showDeleted: boolean;
}

/** Response message for `ListKeys` method. */
export interface ListKeysResponse {
  /** A list of API keys. */
  keys: Key[];
  /** The pagination token for the next page of results. */
  nextPageToken: string;
}

/** Request message for `GetKey` method. */
export interface GetKeyRequest {
  /** Required. The resource name of the API key to get. */
  name: string;
}

/** Request message for `GetKeyString` method. */
export interface GetKeyStringRequest {
  /** Required. The resource name of the API key to be retrieved. */
  name: string;
}

/** Response message for `GetKeyString` method. */
export interface GetKeyStringResponse {
  /** An encrypted and signed value of the key. */
  keyString: string;
}

/** Request message for `UpdateKey` method. */
export interface UpdateKeyRequest {
  /**
   * Required. Set the `name` field to the resource name of the API key to be
   * updated. You can update only the `display_name`, `restrictions`, and
   * `annotations` fields.
   */
  key?:
    | Key
    | undefined;
  /**
   * The field mask specifies which fields to be updated as part of this
   * request. All other fields are ignored.
   * Mutable fields are: `display_name`, `restrictions`, and `annotations`.
   * If an update mask is not provided, the service treats it as an implied mask
   * equivalent to all allowed fields that are set on the wire. If the field
   * mask has a special value "*", the service treats it equivalent to replace
   * all allowed mutable fields.
   */
  updateMask?: string[] | undefined;
}

/** Request message for `DeleteKey` method. */
export interface DeleteKeyRequest {
  /** Required. The resource name of the API key to be deleted. */
  name: string;
  /**
   * Optional. The etag known to the client for the expected state of the key.
   * This is to be used for optimistic concurrency.
   */
  etag: string;
}

/** Request message for `UndeleteKey` method. */
export interface UndeleteKeyRequest {
  /** Required. The resource name of the API key to be undeleted. */
  name: string;
}

/** Request message for `LookupKey` method. */
export interface LookupKeyRequest {
  /** Required. Finds the project that owns the key string value. */
  keyString: string;
}

/** Response message for `LookupKey` method. */
export interface LookupKeyResponse {
  /** The project that owns the key with the value specified in the request. */
  parent: string;
  /**
   * The resource name of the API key. If the API key has been purged,
   * resource name is empty.
   */
  name: string;
}

function createBaseCreateKeyRequest(): CreateKeyRequest {
  return { parent: "", key: undefined, keyId: "" };
}

export const CreateKeyRequest: MessageFns<CreateKeyRequest> = {
  encode(message: CreateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(18).fork()).join();
    }
    if (message.keyId !== "") {
      writer.uint32(26).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateKeyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
      keyId: isSet(object.keyId)
        ? globalThis.String(object.keyId)
        : isSet(object.key_id)
        ? globalThis.String(object.key_id)
        : "",
    };
  },

  toJSON(message: CreateKeyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateKeyRequest>, I>>(base?: I): CreateKeyRequest {
    return CreateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateKeyRequest>, I>>(object: I): CreateKeyRequest {
    const message = createBaseCreateKeyRequest();
    message.parent = object.parent ?? "";
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBaseListKeysRequest(): ListKeysRequest {
  return { parent: "", pageSize: 0, pageToken: "", showDeleted: false };
}

export const ListKeysRequest: MessageFns<ListKeysRequest> = {
  encode(message: ListKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.showDeleted !== false) {
      writer.uint32(48).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
      pageToken: isSet(object.pageToken)
        ? globalThis.String(object.pageToken)
        : isSet(object.page_token)
        ? globalThis.String(object.page_token)
        : "",
      showDeleted: isSet(object.showDeleted)
        ? globalThis.Boolean(object.showDeleted)
        : isSet(object.show_deleted)
        ? globalThis.Boolean(object.show_deleted)
        : false,
    };
  },

  toJSON(message: ListKeysRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKeysRequest>, I>>(base?: I): ListKeysRequest {
    return ListKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKeysRequest>, I>>(object: I): ListKeysRequest {
    const message = createBaseListKeysRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListKeysResponse(): ListKeysResponse {
  return { keys: [], nextPageToken: "" };
}

export const ListKeysResponse: MessageFns<ListKeysResponse> = {
  encode(message: ListKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysResponse {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken)
        ? globalThis.String(object.nextPageToken)
        : isSet(object.next_page_token)
        ? globalThis.String(object.next_page_token)
        : "",
    };
  },

  toJSON(message: ListKeysResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKeysResponse>, I>>(base?: I): ListKeysResponse {
    return ListKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKeysResponse>, I>>(object: I): ListKeysResponse {
    const message = createBaseListKeysResponse();
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetKeyRequest(): GetKeyRequest {
  return { name: "" };
}

export const GetKeyRequest: MessageFns<GetKeyRequest> = {
  encode(message: GetKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyRequest>, I>>(base?: I): GetKeyRequest {
    return GetKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyRequest>, I>>(object: I): GetKeyRequest {
    const message = createBaseGetKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetKeyStringRequest(): GetKeyStringRequest {
  return { name: "" };
}

export const GetKeyStringRequest: MessageFns<GetKeyStringRequest> = {
  encode(message: GetKeyStringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyStringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyStringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyStringRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetKeyStringRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyStringRequest>, I>>(base?: I): GetKeyStringRequest {
    return GetKeyStringRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyStringRequest>, I>>(object: I): GetKeyStringRequest {
    const message = createBaseGetKeyStringRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetKeyStringResponse(): GetKeyStringResponse {
  return { keyString: "" };
}

export const GetKeyStringResponse: MessageFns<GetKeyStringResponse> = {
  encode(message: GetKeyStringResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyString !== "") {
      writer.uint32(10).string(message.keyString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyStringResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyStringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyStringResponse {
    return {
      keyString: isSet(object.keyString)
        ? globalThis.String(object.keyString)
        : isSet(object.key_string)
        ? globalThis.String(object.key_string)
        : "",
    };
  },

  toJSON(message: GetKeyStringResponse): unknown {
    const obj: any = {};
    if (message.keyString !== "") {
      obj.keyString = message.keyString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyStringResponse>, I>>(base?: I): GetKeyStringResponse {
    return GetKeyStringResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyStringResponse>, I>>(object: I): GetKeyStringResponse {
    const message = createBaseGetKeyStringResponse();
    message.keyString = object.keyString ?? "";
    return message;
  },
};

function createBaseUpdateKeyRequest(): UpdateKeyRequest {
  return { key: undefined, updateMask: undefined };
}

export const UpdateKeyRequest: MessageFns<UpdateKeyRequest> = {
  encode(message: UpdateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateKeyRequest {
    return {
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
      updateMask: isSet(object.updateMask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask))
        : isSet(object.update_mask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.update_mask))
        : undefined,
    };
  },

  toJSON(message: UpdateKeyRequest): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateKeyRequest>, I>>(base?: I): UpdateKeyRequest {
    return UpdateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateKeyRequest>, I>>(object: I): UpdateKeyRequest {
    const message = createBaseUpdateKeyRequest();
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteKeyRequest(): DeleteKeyRequest {
  return { name: "", etag: "" };
}

export const DeleteKeyRequest: MessageFns<DeleteKeyRequest> = {
  encode(message: DeleteKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteKeyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteKeyRequest>, I>>(base?: I): DeleteKeyRequest {
    return DeleteKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteKeyRequest>, I>>(object: I): DeleteKeyRequest {
    const message = createBaseDeleteKeyRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseUndeleteKeyRequest(): UndeleteKeyRequest {
  return { name: "" };
}

export const UndeleteKeyRequest: MessageFns<UndeleteKeyRequest> = {
  encode(message: UndeleteKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UndeleteKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UndeleteKeyRequest>, I>>(base?: I): UndeleteKeyRequest {
    return UndeleteKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UndeleteKeyRequest>, I>>(object: I): UndeleteKeyRequest {
    const message = createBaseUndeleteKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLookupKeyRequest(): LookupKeyRequest {
  return { keyString: "" };
}

export const LookupKeyRequest: MessageFns<LookupKeyRequest> = {
  encode(message: LookupKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyString !== "") {
      writer.uint32(10).string(message.keyString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupKeyRequest {
    return {
      keyString: isSet(object.keyString)
        ? globalThis.String(object.keyString)
        : isSet(object.key_string)
        ? globalThis.String(object.key_string)
        : "",
    };
  },

  toJSON(message: LookupKeyRequest): unknown {
    const obj: any = {};
    if (message.keyString !== "") {
      obj.keyString = message.keyString;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LookupKeyRequest>, I>>(base?: I): LookupKeyRequest {
    return LookupKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LookupKeyRequest>, I>>(object: I): LookupKeyRequest {
    const message = createBaseLookupKeyRequest();
    message.keyString = object.keyString ?? "";
    return message;
  },
};

function createBaseLookupKeyResponse(): LookupKeyResponse {
  return { parent: "", name: "" };
}

export const LookupKeyResponse: MessageFns<LookupKeyResponse> = {
  encode(message: LookupKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupKeyResponse {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: LookupKeyResponse): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LookupKeyResponse>, I>>(base?: I): LookupKeyResponse {
    return LookupKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LookupKeyResponse>, I>>(object: I): LookupKeyResponse {
    const message = createBaseLookupKeyResponse();
    message.parent = object.parent ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

/** Manages the API keys associated with projects. */
export interface ApiKeys {
  /**
   * Creates a new API key.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  CreateKey(request: DeepPartial<CreateKeyRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Lists the API keys owned by a project. The key string of the API key
   * isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  ListKeys(request: DeepPartial<ListKeysRequest>, metadata?: grpc.Metadata): Promise<ListKeysResponse>;
  /**
   * Gets the metadata for an API key. The key string of the API key
   * isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  GetKey(request: DeepPartial<GetKeyRequest>, metadata?: grpc.Metadata): Promise<Key>;
  /**
   * Get the key string for an API key.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  GetKeyString(request: DeepPartial<GetKeyStringRequest>, metadata?: grpc.Metadata): Promise<GetKeyStringResponse>;
  /**
   * Patches the modifiable fields of an API key.
   * The key string of the API key isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  UpdateKey(request: DeepPartial<UpdateKeyRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Deletes an API key. Deleted key can be retrieved within 30 days of
   * deletion. Afterward, key will be purged from the project.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  DeleteKey(request: DeepPartial<DeleteKeyRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Undeletes an API key which was deleted within 30 days.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  UndeleteKey(request: DeepPartial<UndeleteKeyRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Find the parent project and resource name of the API
   * key that matches the key string in the request. If the API key has been
   * purged, resource name will not be set.
   * The service account must have the `apikeys.keys.lookup` permission
   * on the parent project.
   */
  LookupKey(request: DeepPartial<LookupKeyRequest>, metadata?: grpc.Metadata): Promise<LookupKeyResponse>;
}

export class ApiKeysClientImpl implements ApiKeys {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.CreateKey = this.CreateKey.bind(this);
    this.ListKeys = this.ListKeys.bind(this);
    this.GetKey = this.GetKey.bind(this);
    this.GetKeyString = this.GetKeyString.bind(this);
    this.UpdateKey = this.UpdateKey.bind(this);
    this.DeleteKey = this.DeleteKey.bind(this);
    this.UndeleteKey = this.UndeleteKey.bind(this);
    this.LookupKey = this.LookupKey.bind(this);
  }

  CreateKey(request: DeepPartial<CreateKeyRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(ApiKeysCreateKeyDesc, CreateKeyRequest.fromPartial(request), metadata);
  }

  ListKeys(request: DeepPartial<ListKeysRequest>, metadata?: grpc.Metadata): Promise<ListKeysResponse> {
    return this.rpc.unary(ApiKeysListKeysDesc, ListKeysRequest.fromPartial(request), metadata);
  }

  GetKey(request: DeepPartial<GetKeyRequest>, metadata?: grpc.Metadata): Promise<Key> {
    return this.rpc.unary(ApiKeysGetKeyDesc, GetKeyRequest.fromPartial(request), metadata);
  }

  GetKeyString(request: DeepPartial<GetKeyStringRequest>, metadata?: grpc.Metadata): Promise<GetKeyStringResponse> {
    return this.rpc.unary(ApiKeysGetKeyStringDesc, GetKeyStringRequest.fromPartial(request), metadata);
  }

  UpdateKey(request: DeepPartial<UpdateKeyRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(ApiKeysUpdateKeyDesc, UpdateKeyRequest.fromPartial(request), metadata);
  }

  DeleteKey(request: DeepPartial<DeleteKeyRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(ApiKeysDeleteKeyDesc, DeleteKeyRequest.fromPartial(request), metadata);
  }

  UndeleteKey(request: DeepPartial<UndeleteKeyRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(ApiKeysUndeleteKeyDesc, UndeleteKeyRequest.fromPartial(request), metadata);
  }

  LookupKey(request: DeepPartial<LookupKeyRequest>, metadata?: grpc.Metadata): Promise<LookupKeyResponse> {
    return this.rpc.unary(ApiKeysLookupKeyDesc, LookupKeyRequest.fromPartial(request), metadata);
  }
}

export const ApiKeysDesc = { serviceName: "google.api.apikeys.v2.ApiKeys" };

export const ApiKeysCreateKeyDesc: UnaryMethodDefinitionish = {
  methodName: "CreateKey",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateKeyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ApiKeysListKeysDesc: UnaryMethodDefinitionish = {
  methodName: "ListKeys",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListKeysRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListKeysResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ApiKeysGetKeyDesc: UnaryMethodDefinitionish = {
  methodName: "GetKey",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetKeyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Key.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ApiKeysGetKeyStringDesc: UnaryMethodDefinitionish = {
  methodName: "GetKeyString",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetKeyStringRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetKeyStringResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ApiKeysUpdateKeyDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateKey",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpdateKeyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ApiKeysDeleteKeyDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteKey",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteKeyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ApiKeysUndeleteKeyDesc: UnaryMethodDefinitionish = {
  methodName: "UndeleteKey",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UndeleteKeyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ApiKeysLookupKeyDesc: UnaryMethodDefinitionish = {
  methodName: "LookupKey",
  service: ApiKeysDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LookupKeyRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LookupKeyResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
