// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: google/api/expr/conformance/v1alpha1/conformance_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import { Status } from "../../../../rpc/status";
import { CheckedExpr, Decl } from "../../v1alpha1/checked";
import { ExprValue } from "../../v1alpha1/eval";
import { ParsedExpr } from "../../v1alpha1/syntax";

export const protobufPackage = "google.api.expr.conformance.v1alpha1";

/** Request message for the Parse method. */
export interface ParseRequest {
  /** Required. Source text in CEL syntax. */
  celSource: string;
  /** Tag for version of CEL syntax, for future use. */
  syntaxVersion: string;
  /** File or resource for source text, used in [SourceInfo][google.api.SourceInfo]. */
  sourceLocation: string;
  /** Prevent macro expansion.  See "Macros" in Language Defiinition. */
  disableMacros: boolean;
}

/** Response message for the Parse method. */
export interface ParseResponse {
  /** The parsed representation, or unset if parsing failed. */
  parsedExpr?:
    | ParsedExpr
    | undefined;
  /** Any number of issues with [StatusDetails][] as the details. */
  issues: Status[];
}

/** Request message for the Check method. */
export interface CheckRequest {
  /** Required. The parsed representation of the CEL program. */
  parsedExpr?:
    | ParsedExpr
    | undefined;
  /**
   * Declarations of types for external variables and functions.
   * Required if program uses external variables or functions
   * not in the default environment.
   */
  typeEnv: Decl[];
  /**
   * The protocol buffer context.  See "Name Resolution" in the
   * Language Definition.
   */
  container: string;
  /**
   * If true, use only the declarations in [type_env][google.api.expr.conformance.v1alpha1.CheckRequest.type_env].  If false (default),
   * add declarations for the standard definitions to the type environment.  See
   * "Standard Definitions" in the Language Definition.
   */
  noStdEnv: boolean;
}

/** Response message for the Check method. */
export interface CheckResponse {
  /** The annotated representation, or unset if checking failed. */
  checkedExpr?:
    | CheckedExpr
    | undefined;
  /** Any number of issues with [StatusDetails][] as the details. */
  issues: Status[];
}

/** Request message for the Eval method. */
export interface EvalRequest {
  /** Evaluate based on the parsed representation. */
  parsedExpr?:
    | ParsedExpr
    | undefined;
  /** Evaluate based on the checked representation. */
  checkedExpr?:
    | CheckedExpr
    | undefined;
  /**
   * Bindings for the external variables.  The types SHOULD be compatible
   * with the type environment in [CheckRequest][google.api.expr.conformance.v1alpha1.CheckRequest], if checked.
   */
  bindings: { [key: string]: ExprValue };
  /** SHOULD be the same container as used in [CheckRequest][google.api.expr.conformance.v1alpha1.CheckRequest], if checked. */
  container: string;
}

export interface EvalRequest_BindingsEntry {
  key: string;
  value?: ExprValue | undefined;
}

/** Response message for the Eval method. */
export interface EvalResponse {
  /** The execution result, or unset if execution couldn't start. */
  result?:
    | ExprValue
    | undefined;
  /**
   * Any number of issues with [StatusDetails][] as the details.
   * Note that CEL execution errors are reified into [ExprValue][].
   * Nevertheless, we'll allow out-of-band issues to be raised,
   * which also makes the replies more regular.
   */
  issues: Status[];
}

/** A specific position in source. */
export interface SourcePosition {
  /** The source location name (e.g. file name). */
  location: string;
  /** The UTF-8 code unit offset. */
  offset: number;
  /**
   * The 1-based index of the starting line in the source text
   * where the issue occurs, or 0 if unknown.
   */
  line: number;
  /**
   * The 0-based index of the starting position within the line of source text
   * where the issue occurs.  Only meaningful if line is nonzero.
   */
  column: number;
}

/**
 * Warnings or errors in service execution are represented by
 * [google.rpc.Status][google.rpc.Status] messages, with the following message
 * in the details field.
 */
export interface IssueDetails {
  /** The severity of the issue. */
  severity: IssueDetails_Severity;
  /** Position in the source, if known. */
  position?:
    | SourcePosition
    | undefined;
  /** Expression ID from [Expr][], 0 if unknown. */
  id: Long;
}

/** Severities of issues. */
export enum IssueDetails_Severity {
  /** SEVERITY_UNSPECIFIED - An unspecified severity. */
  SEVERITY_UNSPECIFIED = 0,
  /**
   * DEPRECATION - Deprecation issue for statements and method that may no longer be
   * supported or maintained.
   */
  DEPRECATION = 1,
  /** WARNING - Warnings such as: unused variables. */
  WARNING = 2,
  /** ERROR - Errors such as: unmatched curly braces or variable redefinition. */
  ERROR = 3,
  UNRECOGNIZED = -1,
}

export function issueDetails_SeverityFromJSON(object: any): IssueDetails_Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return IssueDetails_Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "DEPRECATION":
      return IssueDetails_Severity.DEPRECATION;
    case 2:
    case "WARNING":
      return IssueDetails_Severity.WARNING;
    case 3:
    case "ERROR":
      return IssueDetails_Severity.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IssueDetails_Severity.UNRECOGNIZED;
  }
}

export function issueDetails_SeverityToJSON(object: IssueDetails_Severity): string {
  switch (object) {
    case IssueDetails_Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case IssueDetails_Severity.DEPRECATION:
      return "DEPRECATION";
    case IssueDetails_Severity.WARNING:
      return "WARNING";
    case IssueDetails_Severity.ERROR:
      return "ERROR";
    case IssueDetails_Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseParseRequest(): ParseRequest {
  return { celSource: "", syntaxVersion: "", sourceLocation: "", disableMacros: false };
}

export const ParseRequest: MessageFns<ParseRequest> = {
  encode(message: ParseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.celSource !== "") {
      writer.uint32(10).string(message.celSource);
    }
    if (message.syntaxVersion !== "") {
      writer.uint32(18).string(message.syntaxVersion);
    }
    if (message.sourceLocation !== "") {
      writer.uint32(26).string(message.sourceLocation);
    }
    if (message.disableMacros !== false) {
      writer.uint32(32).bool(message.disableMacros);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.celSource = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.syntaxVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceLocation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.disableMacros = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseRequest {
    return {
      celSource: isSet(object.celSource)
        ? globalThis.String(object.celSource)
        : isSet(object.cel_source)
        ? globalThis.String(object.cel_source)
        : "",
      syntaxVersion: isSet(object.syntaxVersion)
        ? globalThis.String(object.syntaxVersion)
        : isSet(object.syntax_version)
        ? globalThis.String(object.syntax_version)
        : "",
      sourceLocation: isSet(object.sourceLocation)
        ? globalThis.String(object.sourceLocation)
        : isSet(object.source_location)
        ? globalThis.String(object.source_location)
        : "",
      disableMacros: isSet(object.disableMacros)
        ? globalThis.Boolean(object.disableMacros)
        : isSet(object.disable_macros)
        ? globalThis.Boolean(object.disable_macros)
        : false,
    };
  },

  toJSON(message: ParseRequest): unknown {
    const obj: any = {};
    if (message.celSource !== "") {
      obj.celSource = message.celSource;
    }
    if (message.syntaxVersion !== "") {
      obj.syntaxVersion = message.syntaxVersion;
    }
    if (message.sourceLocation !== "") {
      obj.sourceLocation = message.sourceLocation;
    }
    if (message.disableMacros !== false) {
      obj.disableMacros = message.disableMacros;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParseRequest>, I>>(base?: I): ParseRequest {
    return ParseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParseRequest>, I>>(object: I): ParseRequest {
    const message = createBaseParseRequest();
    message.celSource = object.celSource ?? "";
    message.syntaxVersion = object.syntaxVersion ?? "";
    message.sourceLocation = object.sourceLocation ?? "";
    message.disableMacros = object.disableMacros ?? false;
    return message;
  },
};

function createBaseParseResponse(): ParseResponse {
  return { parsedExpr: undefined, issues: [] };
}

export const ParseResponse: MessageFns<ParseResponse> = {
  encode(message: ParseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parsedExpr !== undefined) {
      ParsedExpr.encode(message.parsedExpr, writer.uint32(10).fork()).join();
    }
    for (const v of message.issues) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parsedExpr = ParsedExpr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issues.push(Status.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseResponse {
    return {
      parsedExpr: isSet(object.parsedExpr)
        ? ParsedExpr.fromJSON(object.parsedExpr)
        : isSet(object.parsed_expr)
        ? ParsedExpr.fromJSON(object.parsed_expr)
        : undefined,
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: ParseResponse): unknown {
    const obj: any = {};
    if (message.parsedExpr !== undefined) {
      obj.parsedExpr = ParsedExpr.toJSON(message.parsedExpr);
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParseResponse>, I>>(base?: I): ParseResponse {
    return ParseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParseResponse>, I>>(object: I): ParseResponse {
    const message = createBaseParseResponse();
    message.parsedExpr = (object.parsedExpr !== undefined && object.parsedExpr !== null)
      ? ParsedExpr.fromPartial(object.parsedExpr)
      : undefined;
    message.issues = object.issues?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCheckRequest(): CheckRequest {
  return { parsedExpr: undefined, typeEnv: [], container: "", noStdEnv: false };
}

export const CheckRequest: MessageFns<CheckRequest> = {
  encode(message: CheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parsedExpr !== undefined) {
      ParsedExpr.encode(message.parsedExpr, writer.uint32(10).fork()).join();
    }
    for (const v of message.typeEnv) {
      Decl.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.container !== "") {
      writer.uint32(26).string(message.container);
    }
    if (message.noStdEnv !== false) {
      writer.uint32(32).bool(message.noStdEnv);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parsedExpr = ParsedExpr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeEnv.push(Decl.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.container = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noStdEnv = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckRequest {
    return {
      parsedExpr: isSet(object.parsedExpr)
        ? ParsedExpr.fromJSON(object.parsedExpr)
        : isSet(object.parsed_expr)
        ? ParsedExpr.fromJSON(object.parsed_expr)
        : undefined,
      typeEnv: globalThis.Array.isArray(object?.typeEnv)
        ? object.typeEnv.map((e: any) => Decl.fromJSON(e))
        : globalThis.Array.isArray(object?.type_env)
        ? object.type_env.map((e: any) => Decl.fromJSON(e))
        : [],
      container: isSet(object.container) ? globalThis.String(object.container) : "",
      noStdEnv: isSet(object.noStdEnv)
        ? globalThis.Boolean(object.noStdEnv)
        : isSet(object.no_std_env)
        ? globalThis.Boolean(object.no_std_env)
        : false,
    };
  },

  toJSON(message: CheckRequest): unknown {
    const obj: any = {};
    if (message.parsedExpr !== undefined) {
      obj.parsedExpr = ParsedExpr.toJSON(message.parsedExpr);
    }
    if (message.typeEnv?.length) {
      obj.typeEnv = message.typeEnv.map((e) => Decl.toJSON(e));
    }
    if (message.container !== "") {
      obj.container = message.container;
    }
    if (message.noStdEnv !== false) {
      obj.noStdEnv = message.noStdEnv;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckRequest>, I>>(base?: I): CheckRequest {
    return CheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckRequest>, I>>(object: I): CheckRequest {
    const message = createBaseCheckRequest();
    message.parsedExpr = (object.parsedExpr !== undefined && object.parsedExpr !== null)
      ? ParsedExpr.fromPartial(object.parsedExpr)
      : undefined;
    message.typeEnv = object.typeEnv?.map((e) => Decl.fromPartial(e)) || [];
    message.container = object.container ?? "";
    message.noStdEnv = object.noStdEnv ?? false;
    return message;
  },
};

function createBaseCheckResponse(): CheckResponse {
  return { checkedExpr: undefined, issues: [] };
}

export const CheckResponse: MessageFns<CheckResponse> = {
  encode(message: CheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkedExpr !== undefined) {
      CheckedExpr.encode(message.checkedExpr, writer.uint32(10).fork()).join();
    }
    for (const v of message.issues) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.checkedExpr = CheckedExpr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issues.push(Status.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckResponse {
    return {
      checkedExpr: isSet(object.checkedExpr)
        ? CheckedExpr.fromJSON(object.checkedExpr)
        : isSet(object.checked_expr)
        ? CheckedExpr.fromJSON(object.checked_expr)
        : undefined,
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: CheckResponse): unknown {
    const obj: any = {};
    if (message.checkedExpr !== undefined) {
      obj.checkedExpr = CheckedExpr.toJSON(message.checkedExpr);
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckResponse>, I>>(base?: I): CheckResponse {
    return CheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckResponse>, I>>(object: I): CheckResponse {
    const message = createBaseCheckResponse();
    message.checkedExpr = (object.checkedExpr !== undefined && object.checkedExpr !== null)
      ? CheckedExpr.fromPartial(object.checkedExpr)
      : undefined;
    message.issues = object.issues?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvalRequest(): EvalRequest {
  return { parsedExpr: undefined, checkedExpr: undefined, bindings: {}, container: "" };
}

export const EvalRequest: MessageFns<EvalRequest> = {
  encode(message: EvalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parsedExpr !== undefined) {
      ParsedExpr.encode(message.parsedExpr, writer.uint32(10).fork()).join();
    }
    if (message.checkedExpr !== undefined) {
      CheckedExpr.encode(message.checkedExpr, writer.uint32(18).fork()).join();
    }
    globalThis.Object.entries(message.bindings).forEach(([key, value]: [string, ExprValue]) => {
      EvalRequest_BindingsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.container !== "") {
      writer.uint32(34).string(message.container);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parsedExpr = ParsedExpr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkedExpr = CheckedExpr.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = EvalRequest_BindingsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.bindings[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.container = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalRequest {
    return {
      parsedExpr: isSet(object.parsedExpr)
        ? ParsedExpr.fromJSON(object.parsedExpr)
        : isSet(object.parsed_expr)
        ? ParsedExpr.fromJSON(object.parsed_expr)
        : undefined,
      checkedExpr: isSet(object.checkedExpr)
        ? CheckedExpr.fromJSON(object.checkedExpr)
        : isSet(object.checked_expr)
        ? CheckedExpr.fromJSON(object.checked_expr)
        : undefined,
      bindings: isObject(object.bindings)
        ? (globalThis.Object.entries(object.bindings) as [string, any][]).reduce(
          (acc: { [key: string]: ExprValue }, [key, value]: [string, any]) => {
            acc[key] = ExprValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      container: isSet(object.container) ? globalThis.String(object.container) : "",
    };
  },

  toJSON(message: EvalRequest): unknown {
    const obj: any = {};
    if (message.parsedExpr !== undefined) {
      obj.parsedExpr = ParsedExpr.toJSON(message.parsedExpr);
    }
    if (message.checkedExpr !== undefined) {
      obj.checkedExpr = CheckedExpr.toJSON(message.checkedExpr);
    }
    if (message.bindings) {
      const entries = globalThis.Object.entries(message.bindings) as [string, ExprValue][];
      if (entries.length > 0) {
        obj.bindings = {};
        entries.forEach(([k, v]) => {
          obj.bindings[k] = ExprValue.toJSON(v);
        });
      }
    }
    if (message.container !== "") {
      obj.container = message.container;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalRequest>, I>>(base?: I): EvalRequest {
    return EvalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalRequest>, I>>(object: I): EvalRequest {
    const message = createBaseEvalRequest();
    message.parsedExpr = (object.parsedExpr !== undefined && object.parsedExpr !== null)
      ? ParsedExpr.fromPartial(object.parsedExpr)
      : undefined;
    message.checkedExpr = (object.checkedExpr !== undefined && object.checkedExpr !== null)
      ? CheckedExpr.fromPartial(object.checkedExpr)
      : undefined;
    message.bindings = (globalThis.Object.entries(object.bindings ?? {}) as [string, ExprValue][]).reduce(
      (acc: { [key: string]: ExprValue }, [key, value]: [string, ExprValue]) => {
        if (value !== undefined) {
          acc[key] = ExprValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.container = object.container ?? "";
    return message;
  },
};

function createBaseEvalRequest_BindingsEntry(): EvalRequest_BindingsEntry {
  return { key: "", value: undefined };
}

export const EvalRequest_BindingsEntry: MessageFns<EvalRequest_BindingsEntry> = {
  encode(message: EvalRequest_BindingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ExprValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalRequest_BindingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalRequest_BindingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ExprValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalRequest_BindingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ExprValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EvalRequest_BindingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ExprValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalRequest_BindingsEntry>, I>>(base?: I): EvalRequest_BindingsEntry {
    return EvalRequest_BindingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalRequest_BindingsEntry>, I>>(object: I): EvalRequest_BindingsEntry {
    const message = createBaseEvalRequest_BindingsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ExprValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEvalResponse(): EvalResponse {
  return { result: undefined, issues: [] };
}

export const EvalResponse: MessageFns<EvalResponse> = {
  encode(message: EvalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      ExprValue.encode(message.result, writer.uint32(10).fork()).join();
    }
    for (const v of message.issues) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = ExprValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issues.push(Status.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvalResponse {
    return {
      result: isSet(object.result) ? ExprValue.fromJSON(object.result) : undefined,
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: EvalResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = ExprValue.toJSON(message.result);
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvalResponse>, I>>(base?: I): EvalResponse {
    return EvalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvalResponse>, I>>(object: I): EvalResponse {
    const message = createBaseEvalResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? ExprValue.fromPartial(object.result)
      : undefined;
    message.issues = object.issues?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSourcePosition(): SourcePosition {
  return { location: "", offset: 0, line: 0, column: 0 };
}

export const SourcePosition: MessageFns<SourcePosition> = {
  encode(message: SourcePosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.line !== 0) {
      writer.uint32(24).int32(message.line);
    }
    if (message.column !== 0) {
      writer.uint32(32).int32(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourcePosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourcePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.line = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.column = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourcePosition {
    return {
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
    };
  },

  toJSON(message: SourcePosition): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourcePosition>, I>>(base?: I): SourcePosition {
    return SourcePosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourcePosition>, I>>(object: I): SourcePosition {
    const message = createBaseSourcePosition();
    message.location = object.location ?? "";
    message.offset = object.offset ?? 0;
    message.line = object.line ?? 0;
    message.column = object.column ?? 0;
    return message;
  },
};

function createBaseIssueDetails(): IssueDetails {
  return { severity: 0, position: undefined, id: Long.ZERO };
}

export const IssueDetails: MessageFns<IssueDetails> = {
  encode(message: IssueDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.severity !== 0) {
      writer.uint32(8).int32(message.severity);
    }
    if (message.position !== undefined) {
      SourcePosition.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.id.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = SourcePosition.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueDetails {
    return {
      severity: isSet(object.severity) ? issueDetails_SeverityFromJSON(object.severity) : 0,
      position: isSet(object.position) ? SourcePosition.fromJSON(object.position) : undefined,
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
    };
  },

  toJSON(message: IssueDetails): unknown {
    const obj: any = {};
    if (message.severity !== 0) {
      obj.severity = issueDetails_SeverityToJSON(message.severity);
    }
    if (message.position !== undefined) {
      obj.position = SourcePosition.toJSON(message.position);
    }
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IssueDetails>, I>>(base?: I): IssueDetails {
    return IssueDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IssueDetails>, I>>(object: I): IssueDetails {
    const message = createBaseIssueDetails();
    message.severity = object.severity ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? SourcePosition.fromPartial(object.position)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    return message;
  },
};

/**
 * Access a CEL implementation from another process or machine.
 * A CEL implementation is decomposed as a parser, a static checker,
 * and an evaluator.  Every CEL implementation is expected to provide
 * a server for this API.  The API will be used for conformance testing
 * and other utilities.
 */
export interface ConformanceService {
  /** Transforms CEL source text into a parsed representation. */
  Parse(request: DeepPartial<ParseRequest>, metadata?: grpc.Metadata): Promise<ParseResponse>;
  /**
   * Runs static checks on a parsed CEL representation and return
   * an annotated representation, or a set of issues.
   */
  Check(request: DeepPartial<CheckRequest>, metadata?: grpc.Metadata): Promise<CheckResponse>;
  /**
   * Evaluates a parsed or annotation CEL representation given
   * values of external bindings.
   */
  Eval(request: DeepPartial<EvalRequest>, metadata?: grpc.Metadata): Promise<EvalResponse>;
}

export class ConformanceServiceClientImpl implements ConformanceService {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.Parse = this.Parse.bind(this);
    this.Check = this.Check.bind(this);
    this.Eval = this.Eval.bind(this);
  }

  Parse(request: DeepPartial<ParseRequest>, metadata?: grpc.Metadata): Promise<ParseResponse> {
    return this.rpc.unary(ConformanceServiceParseDesc, ParseRequest.fromPartial(request), metadata);
  }

  Check(request: DeepPartial<CheckRequest>, metadata?: grpc.Metadata): Promise<CheckResponse> {
    return this.rpc.unary(ConformanceServiceCheckDesc, CheckRequest.fromPartial(request), metadata);
  }

  Eval(request: DeepPartial<EvalRequest>, metadata?: grpc.Metadata): Promise<EvalResponse> {
    return this.rpc.unary(ConformanceServiceEvalDesc, EvalRequest.fromPartial(request), metadata);
  }
}

export const ConformanceServiceDesc = { serviceName: "google.api.expr.conformance.v1alpha1.ConformanceService" };

export const ConformanceServiceParseDesc: UnaryMethodDefinitionish = {
  methodName: "Parse",
  service: ConformanceServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParseRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ParseResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConformanceServiceCheckDesc: UnaryMethodDefinitionish = {
  methodName: "Check",
  service: ConformanceServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CheckRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CheckResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ConformanceServiceEvalDesc: UnaryMethodDefinitionish = {
  methodName: "Eval",
  service: ConformanceServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return EvalRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = EvalResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
