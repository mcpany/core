// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: google/api/cloudquotas/v1beta/cloudquotas.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask";
import {
  QuotaInfo,
  QuotaPreference,
  QuotaSafetyCheck,
  quotaSafetyCheckFromJSON,
  quotaSafetyCheckToJSON,
} from "./resources";

export const protobufPackage = "google.api.cloudquotas.v1beta";

/** Message for requesting list of QuotaInfos */
export interface ListQuotaInfosRequest {
  /**
   * Required. Parent value of QuotaInfo resources.
   * Listing across different resource containers (such as 'projects/-') is not
   * allowed.
   *
   * Example names:
   * `projects/123/locations/global/services/compute.googleapis.com`
   * `folders/234/locations/global/services/compute.googleapis.com`
   * `organizations/345/locations/global/services/compute.googleapis.com`
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
}

/** Message for response to listing QuotaInfos */
export interface ListQuotaInfosResponse {
  /** The list of QuotaInfo */
  quotaInfos: QuotaInfo[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Message for getting a QuotaInfo */
export interface GetQuotaInfoRequest {
  /**
   * Required. The resource name of the quota info.
   *
   * An example name:
   * `projects/123/locations/global/services/compute.googleapis.com/quotaInfos/CpusPerProjectPerRegion`
   */
  name: string;
}

/** Message for requesting list of QuotaPreferences */
export interface ListQuotaPreferencesRequest {
  /**
   * Required. Parent value of QuotaPreference resources.
   * Listing across different resource containers (such as 'projects/-') is not
   * allowed.
   *
   * When the value starts with 'folders' or 'organizations', it lists the
   * QuotaPreferences for org quotas in the container. It does not list the
   * QuotaPreferences in the descendant projects of the container.
   *
   * Example parents:
   * `projects/123/locations/global`
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
  /**
   * Optional. Filter result QuotaPreferences by their state, type,
   * create/update time range.
   *
   * Example filters:
   * `reconciling=true AND request_type=CLOUD_CONSOLE`,
   * `reconciling=true OR creation_time>2022-12-03T10:30:00`
   */
  filter: string;
  /**
   * Optional. How to order of the results. By default, the results are ordered
   * by create time.
   *
   * Example orders:
   * `quota_id`,
   * `service, create_time`
   */
  orderBy: string;
}

/** Message for response to listing QuotaPreferences */
export interface ListQuotaPreferencesResponse {
  /** The list of QuotaPreference */
  quotaPreferences: QuotaPreference[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a QuotaPreference */
export interface GetQuotaPreferenceRequest {
  /**
   * Required. Name of the resource
   *
   * Example name:
   * `projects/123/locations/global/quota_preferences/my-config-for-us-east1`
   */
  name: string;
}

/** Message for creating a QuotaPreference */
export interface CreateQuotaPreferenceRequest {
  /**
   * Required. Value for parent.
   *
   * Example:
   * `projects/123/locations/global`
   */
  parent: string;
  /**
   * Optional. Id of the requesting object, must be unique under its parent.
   * If client does not set this field, the service will generate one.
   */
  quotaPreferenceId: string;
  /** Required. The resource being created */
  quotaPreference?:
    | QuotaPreference
    | undefined;
  /** The list of quota safety checks to be ignored. */
  ignoreSafetyChecks: QuotaSafetyCheck[];
}

/** Message for updating a QuotaPreference */
export interface UpdateQuotaPreferenceRequest {
  /**
   * Optional. Field mask is used to specify the fields to be overwritten in the
   * QuotaPreference resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask?:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  quotaPreference?:
    | QuotaPreference
    | undefined;
  /**
   * Optional. If set to true, and the quota preference is not found, a new one
   * will be created. In this situation, `update_mask` is ignored.
   */
  allowMissing: boolean;
  /**
   * Optional. If set to true, validate the request, but do not actually update.
   * Note that a request being valid does not mean that the request is
   * guaranteed to be fulfilled.
   */
  validateOnly: boolean;
  /** The list of quota safety checks to be ignored. */
  ignoreSafetyChecks: QuotaSafetyCheck[];
}

function createBaseListQuotaInfosRequest(): ListQuotaInfosRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListQuotaInfosRequest: MessageFns<ListQuotaInfosRequest> = {
  encode(message: ListQuotaInfosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQuotaInfosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQuotaInfosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQuotaInfosRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
      pageToken: isSet(object.pageToken)
        ? globalThis.String(object.pageToken)
        : isSet(object.page_token)
        ? globalThis.String(object.page_token)
        : "",
    };
  },

  toJSON(message: ListQuotaInfosRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListQuotaInfosRequest>, I>>(base?: I): ListQuotaInfosRequest {
    return ListQuotaInfosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListQuotaInfosRequest>, I>>(object: I): ListQuotaInfosRequest {
    const message = createBaseListQuotaInfosRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListQuotaInfosResponse(): ListQuotaInfosResponse {
  return { quotaInfos: [], nextPageToken: "" };
}

export const ListQuotaInfosResponse: MessageFns<ListQuotaInfosResponse> = {
  encode(message: ListQuotaInfosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.quotaInfos) {
      QuotaInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQuotaInfosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQuotaInfosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quotaInfos.push(QuotaInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQuotaInfosResponse {
    return {
      quotaInfos: globalThis.Array.isArray(object?.quotaInfos)
        ? object.quotaInfos.map((e: any) => QuotaInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.quota_infos)
        ? object.quota_infos.map((e: any) => QuotaInfo.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? globalThis.String(object.nextPageToken)
        : isSet(object.next_page_token)
        ? globalThis.String(object.next_page_token)
        : "",
    };
  },

  toJSON(message: ListQuotaInfosResponse): unknown {
    const obj: any = {};
    if (message.quotaInfos?.length) {
      obj.quotaInfos = message.quotaInfos.map((e) => QuotaInfo.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListQuotaInfosResponse>, I>>(base?: I): ListQuotaInfosResponse {
    return ListQuotaInfosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListQuotaInfosResponse>, I>>(object: I): ListQuotaInfosResponse {
    const message = createBaseListQuotaInfosResponse();
    message.quotaInfos = object.quotaInfos?.map((e) => QuotaInfo.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetQuotaInfoRequest(): GetQuotaInfoRequest {
  return { name: "" };
}

export const GetQuotaInfoRequest: MessageFns<GetQuotaInfoRequest> = {
  encode(message: GetQuotaInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuotaInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuotaInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuotaInfoRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetQuotaInfoRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuotaInfoRequest>, I>>(base?: I): GetQuotaInfoRequest {
    return GetQuotaInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuotaInfoRequest>, I>>(object: I): GetQuotaInfoRequest {
    const message = createBaseGetQuotaInfoRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListQuotaPreferencesRequest(): ListQuotaPreferencesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListQuotaPreferencesRequest: MessageFns<ListQuotaPreferencesRequest> = {
  encode(message: ListQuotaPreferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQuotaPreferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQuotaPreferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQuotaPreferencesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
      pageToken: isSet(object.pageToken)
        ? globalThis.String(object.pageToken)
        : isSet(object.page_token)
        ? globalThis.String(object.page_token)
        : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy)
        ? globalThis.String(object.orderBy)
        : isSet(object.order_by)
        ? globalThis.String(object.order_by)
        : "",
    };
  },

  toJSON(message: ListQuotaPreferencesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListQuotaPreferencesRequest>, I>>(base?: I): ListQuotaPreferencesRequest {
    return ListQuotaPreferencesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListQuotaPreferencesRequest>, I>>(object: I): ListQuotaPreferencesRequest {
    const message = createBaseListQuotaPreferencesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListQuotaPreferencesResponse(): ListQuotaPreferencesResponse {
  return { quotaPreferences: [], nextPageToken: "", unreachable: [] };
}

export const ListQuotaPreferencesResponse: MessageFns<ListQuotaPreferencesResponse> = {
  encode(message: ListQuotaPreferencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.quotaPreferences) {
      QuotaPreference.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQuotaPreferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQuotaPreferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quotaPreferences.push(QuotaPreference.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQuotaPreferencesResponse {
    return {
      quotaPreferences: globalThis.Array.isArray(object?.quotaPreferences)
        ? object.quotaPreferences.map((e: any) => QuotaPreference.fromJSON(e))
        : globalThis.Array.isArray(object?.quota_preferences)
        ? object.quota_preferences.map((e: any) => QuotaPreference.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? globalThis.String(object.nextPageToken)
        : isSet(object.next_page_token)
        ? globalThis.String(object.next_page_token)
        : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListQuotaPreferencesResponse): unknown {
    const obj: any = {};
    if (message.quotaPreferences?.length) {
      obj.quotaPreferences = message.quotaPreferences.map((e) => QuotaPreference.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListQuotaPreferencesResponse>, I>>(base?: I): ListQuotaPreferencesResponse {
    return ListQuotaPreferencesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListQuotaPreferencesResponse>, I>>(object: I): ListQuotaPreferencesResponse {
    const message = createBaseListQuotaPreferencesResponse();
    message.quotaPreferences = object.quotaPreferences?.map((e) => QuotaPreference.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetQuotaPreferenceRequest(): GetQuotaPreferenceRequest {
  return { name: "" };
}

export const GetQuotaPreferenceRequest: MessageFns<GetQuotaPreferenceRequest> = {
  encode(message: GetQuotaPreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuotaPreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuotaPreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuotaPreferenceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetQuotaPreferenceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuotaPreferenceRequest>, I>>(base?: I): GetQuotaPreferenceRequest {
    return GetQuotaPreferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuotaPreferenceRequest>, I>>(object: I): GetQuotaPreferenceRequest {
    const message = createBaseGetQuotaPreferenceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateQuotaPreferenceRequest(): CreateQuotaPreferenceRequest {
  return { parent: "", quotaPreferenceId: "", quotaPreference: undefined, ignoreSafetyChecks: [] };
}

export const CreateQuotaPreferenceRequest: MessageFns<CreateQuotaPreferenceRequest> = {
  encode(message: CreateQuotaPreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.quotaPreferenceId !== "") {
      writer.uint32(18).string(message.quotaPreferenceId);
    }
    if (message.quotaPreference !== undefined) {
      QuotaPreference.encode(message.quotaPreference, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.ignoreSafetyChecks) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQuotaPreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQuotaPreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quotaPreferenceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quotaPreference = QuotaPreference.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.ignoreSafetyChecks.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ignoreSafetyChecks.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQuotaPreferenceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      quotaPreferenceId: isSet(object.quotaPreferenceId)
        ? globalThis.String(object.quotaPreferenceId)
        : isSet(object.quota_preference_id)
        ? globalThis.String(object.quota_preference_id)
        : "",
      quotaPreference: isSet(object.quotaPreference)
        ? QuotaPreference.fromJSON(object.quotaPreference)
        : isSet(object.quota_preference)
        ? QuotaPreference.fromJSON(object.quota_preference)
        : undefined,
      ignoreSafetyChecks: globalThis.Array.isArray(object?.ignoreSafetyChecks)
        ? object.ignoreSafetyChecks.map((e: any) => quotaSafetyCheckFromJSON(e))
        : globalThis.Array.isArray(object?.ignore_safety_checks)
        ? object.ignore_safety_checks.map((e: any) => quotaSafetyCheckFromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateQuotaPreferenceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.quotaPreferenceId !== "") {
      obj.quotaPreferenceId = message.quotaPreferenceId;
    }
    if (message.quotaPreference !== undefined) {
      obj.quotaPreference = QuotaPreference.toJSON(message.quotaPreference);
    }
    if (message.ignoreSafetyChecks?.length) {
      obj.ignoreSafetyChecks = message.ignoreSafetyChecks.map((e) => quotaSafetyCheckToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateQuotaPreferenceRequest>, I>>(base?: I): CreateQuotaPreferenceRequest {
    return CreateQuotaPreferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateQuotaPreferenceRequest>, I>>(object: I): CreateQuotaPreferenceRequest {
    const message = createBaseCreateQuotaPreferenceRequest();
    message.parent = object.parent ?? "";
    message.quotaPreferenceId = object.quotaPreferenceId ?? "";
    message.quotaPreference = (object.quotaPreference !== undefined && object.quotaPreference !== null)
      ? QuotaPreference.fromPartial(object.quotaPreference)
      : undefined;
    message.ignoreSafetyChecks = object.ignoreSafetyChecks?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateQuotaPreferenceRequest(): UpdateQuotaPreferenceRequest {
  return {
    updateMask: undefined,
    quotaPreference: undefined,
    allowMissing: false,
    validateOnly: false,
    ignoreSafetyChecks: [],
  };
}

export const UpdateQuotaPreferenceRequest: MessageFns<UpdateQuotaPreferenceRequest> = {
  encode(message: UpdateQuotaPreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.quotaPreference !== undefined) {
      QuotaPreference.encode(message.quotaPreference, writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    writer.uint32(42).fork();
    for (const v of message.ignoreSafetyChecks) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateQuotaPreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateQuotaPreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quotaPreference = QuotaPreference.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.ignoreSafetyChecks.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ignoreSafetyChecks.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateQuotaPreferenceRequest {
    return {
      updateMask: isSet(object.updateMask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask))
        : isSet(object.update_mask)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.update_mask))
        : undefined,
      quotaPreference: isSet(object.quotaPreference)
        ? QuotaPreference.fromJSON(object.quotaPreference)
        : isSet(object.quota_preference)
        ? QuotaPreference.fromJSON(object.quota_preference)
        : undefined,
      allowMissing: isSet(object.allowMissing)
        ? globalThis.Boolean(object.allowMissing)
        : isSet(object.allow_missing)
        ? globalThis.Boolean(object.allow_missing)
        : false,
      validateOnly: isSet(object.validateOnly)
        ? globalThis.Boolean(object.validateOnly)
        : isSet(object.validate_only)
        ? globalThis.Boolean(object.validate_only)
        : false,
      ignoreSafetyChecks: globalThis.Array.isArray(object?.ignoreSafetyChecks)
        ? object.ignoreSafetyChecks.map((e: any) => quotaSafetyCheckFromJSON(e))
        : globalThis.Array.isArray(object?.ignore_safety_checks)
        ? object.ignore_safety_checks.map((e: any) => quotaSafetyCheckFromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateQuotaPreferenceRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.quotaPreference !== undefined) {
      obj.quotaPreference = QuotaPreference.toJSON(message.quotaPreference);
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.ignoreSafetyChecks?.length) {
      obj.ignoreSafetyChecks = message.ignoreSafetyChecks.map((e) => quotaSafetyCheckToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateQuotaPreferenceRequest>, I>>(base?: I): UpdateQuotaPreferenceRequest {
    return UpdateQuotaPreferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateQuotaPreferenceRequest>, I>>(object: I): UpdateQuotaPreferenceRequest {
    const message = createBaseUpdateQuotaPreferenceRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.quotaPreference = (object.quotaPreference !== undefined && object.quotaPreference !== null)
      ? QuotaPreference.fromPartial(object.quotaPreference)
      : undefined;
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.ignoreSafetyChecks = object.ignoreSafetyChecks?.map((e) => e) || [];
    return message;
  },
};

/**
 * The Cloud Quotas API is an infrastructure service for Google Cloud that lets
 * service consumers list and manage their resource usage limits.
 *
 * - List/Get the metadata and current status of the quotas for a service.
 * - Create/Update quota preferencess that declare the preferred quota values.
 * - Check the status of a quota preference request.
 * - List/Get pending and historical quota preference.
 */
export interface CloudQuotas {
  /** Lists QuotaInfos of all quotas for a given project, folder or organization. */
  ListQuotaInfos(
    request: DeepPartial<ListQuotaInfosRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListQuotaInfosResponse>;
  /** Retrieve the QuotaInfo of a quota for a project, folder or organization. */
  GetQuotaInfo(request: DeepPartial<GetQuotaInfoRequest>, metadata?: grpc.Metadata): Promise<QuotaInfo>;
  /** Lists QuotaPreferences in a given project, folder or organization. */
  ListQuotaPreferences(
    request: DeepPartial<ListQuotaPreferencesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListQuotaPreferencesResponse>;
  /** Gets details of a single QuotaPreference. */
  GetQuotaPreference(
    request: DeepPartial<GetQuotaPreferenceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuotaPreference>;
  /** Creates a new QuotaPreference that declares the desired value for a quota. */
  CreateQuotaPreference(
    request: DeepPartial<CreateQuotaPreferenceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuotaPreference>;
  /**
   * Updates the parameters of a single QuotaPreference. It can updates the
   * config in any states, not just the ones pending approval.
   */
  UpdateQuotaPreference(
    request: DeepPartial<UpdateQuotaPreferenceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuotaPreference>;
}

export class CloudQuotasClientImpl implements CloudQuotas {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.ListQuotaInfos = this.ListQuotaInfos.bind(this);
    this.GetQuotaInfo = this.GetQuotaInfo.bind(this);
    this.ListQuotaPreferences = this.ListQuotaPreferences.bind(this);
    this.GetQuotaPreference = this.GetQuotaPreference.bind(this);
    this.CreateQuotaPreference = this.CreateQuotaPreference.bind(this);
    this.UpdateQuotaPreference = this.UpdateQuotaPreference.bind(this);
  }

  ListQuotaInfos(
    request: DeepPartial<ListQuotaInfosRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListQuotaInfosResponse> {
    return this.rpc.unary(CloudQuotasListQuotaInfosDesc, ListQuotaInfosRequest.fromPartial(request), metadata);
  }

  GetQuotaInfo(request: DeepPartial<GetQuotaInfoRequest>, metadata?: grpc.Metadata): Promise<QuotaInfo> {
    return this.rpc.unary(CloudQuotasGetQuotaInfoDesc, GetQuotaInfoRequest.fromPartial(request), metadata);
  }

  ListQuotaPreferences(
    request: DeepPartial<ListQuotaPreferencesRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListQuotaPreferencesResponse> {
    return this.rpc.unary(
      CloudQuotasListQuotaPreferencesDesc,
      ListQuotaPreferencesRequest.fromPartial(request),
      metadata,
    );
  }

  GetQuotaPreference(
    request: DeepPartial<GetQuotaPreferenceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuotaPreference> {
    return this.rpc.unary(CloudQuotasGetQuotaPreferenceDesc, GetQuotaPreferenceRequest.fromPartial(request), metadata);
  }

  CreateQuotaPreference(
    request: DeepPartial<CreateQuotaPreferenceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuotaPreference> {
    return this.rpc.unary(
      CloudQuotasCreateQuotaPreferenceDesc,
      CreateQuotaPreferenceRequest.fromPartial(request),
      metadata,
    );
  }

  UpdateQuotaPreference(
    request: DeepPartial<UpdateQuotaPreferenceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<QuotaPreference> {
    return this.rpc.unary(
      CloudQuotasUpdateQuotaPreferenceDesc,
      UpdateQuotaPreferenceRequest.fromPartial(request),
      metadata,
    );
  }
}

export const CloudQuotasDesc = { serviceName: "google.api.cloudquotas.v1beta.CloudQuotas" };

export const CloudQuotasListQuotaInfosDesc: UnaryMethodDefinitionish = {
  methodName: "ListQuotaInfos",
  service: CloudQuotasDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListQuotaInfosRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListQuotaInfosResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CloudQuotasGetQuotaInfoDesc: UnaryMethodDefinitionish = {
  methodName: "GetQuotaInfo",
  service: CloudQuotasDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetQuotaInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuotaInfo.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CloudQuotasListQuotaPreferencesDesc: UnaryMethodDefinitionish = {
  methodName: "ListQuotaPreferences",
  service: CloudQuotasDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListQuotaPreferencesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListQuotaPreferencesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CloudQuotasGetQuotaPreferenceDesc: UnaryMethodDefinitionish = {
  methodName: "GetQuotaPreference",
  service: CloudQuotasDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetQuotaPreferenceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuotaPreference.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CloudQuotasCreateQuotaPreferenceDesc: UnaryMethodDefinitionish = {
  methodName: "CreateQuotaPreference",
  service: CloudQuotasDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateQuotaPreferenceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuotaPreference.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CloudQuotasUpdateQuotaPreferenceDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateQuotaPreference",
  service: CloudQuotasDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpdateQuotaPreferenceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = QuotaPreference.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
