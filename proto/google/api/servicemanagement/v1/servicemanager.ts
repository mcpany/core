// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: google/api/servicemanagement/v1/servicemanager.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import { Operation } from "../../../longrunning/operations";
import { Any } from "../../../protobuf/any";
import { Service } from "../../service";
import { ChangeReport, ConfigSource, Diagnostic, ManagedService, Rollout } from "./resources";

export const protobufPackage = "google.api.servicemanagement.v1";

/** Request message for `ListServices` method. */
export interface ListServicesRequest {
  /** Include services produced by the specified project. */
  producerProjectId: string;
  /**
   * The max number of items to include in the response list. Page size is 50
   * if not specified. Maximum value is 500.
   */
  pageSize: number;
  /**
   * Token identifying which result to start with; returned by a previous list
   * call.
   */
  pageToken: string;
  /**
   * Include services consumed by the specified consumer.
   *
   * The Google Service Management implementation accepts the following
   * forms:
   * - project:<project_id>
   *
   * @deprecated
   */
  consumerId: string;
}

/** Response message for `ListServices` method. */
export interface ListServicesResponse {
  /** The returned services will only have the name field set. */
  services: ManagedService[];
  /** Token that can be passed to `ListServices` to resume a paginated query. */
  nextPageToken: string;
}

/** Request message for `GetService` method. */
export interface GetServiceRequest {
  /**
   * Required. The name of the service.  See the `ServiceManager` overview for
   * naming requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
}

/** Request message for CreateService method. */
export interface CreateServiceRequest {
  /** Required. Initial values for the service resource. */
  service?: ManagedService | undefined;
}

/** Request message for DeleteService method. */
export interface DeleteServiceRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
}

/** Request message for UndeleteService method. */
export interface UndeleteServiceRequest {
  /**
   * Required. The name of the service. See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements. For example: `example.googleapis.com`.
   */
  serviceName: string;
}

/** Response message for UndeleteService method. */
export interface UndeleteServiceResponse {
  /** Revived service resource. */
  service?: ManagedService | undefined;
}

/** Request message for GetServiceConfig method. */
export interface GetServiceConfigRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
  /**
   * Required. The id of the service configuration resource.
   *
   * This field must be specified for the server to return all fields, including
   * `SourceInfo`.
   */
  configId: string;
  /**
   * Specifies which parts of the Service Config should be returned in the
   * response.
   */
  view: GetServiceConfigRequest_ConfigView;
}

export enum GetServiceConfigRequest_ConfigView {
  /** BASIC - Server response includes all fields except SourceInfo. */
  BASIC = 0,
  /**
   * FULL - Server response includes all fields including SourceInfo.
   * SourceFiles are of type 'google.api.servicemanagement.v1.ConfigFile'
   * and are only available for configs created using the
   * SubmitConfigSource method.
   */
  FULL = 1,
  UNRECOGNIZED = -1,
}

export function getServiceConfigRequest_ConfigViewFromJSON(object: any): GetServiceConfigRequest_ConfigView {
  switch (object) {
    case 0:
    case "BASIC":
      return GetServiceConfigRequest_ConfigView.BASIC;
    case 1:
    case "FULL":
      return GetServiceConfigRequest_ConfigView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetServiceConfigRequest_ConfigView.UNRECOGNIZED;
  }
}

export function getServiceConfigRequest_ConfigViewToJSON(object: GetServiceConfigRequest_ConfigView): string {
  switch (object) {
    case GetServiceConfigRequest_ConfigView.BASIC:
      return "BASIC";
    case GetServiceConfigRequest_ConfigView.FULL:
      return "FULL";
    case GetServiceConfigRequest_ConfigView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for ListServiceConfigs method. */
export interface ListServiceConfigsRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
  /** The token of the page to retrieve. */
  pageToken: string;
  /**
   * The max number of items to include in the response list. Page size is 50
   * if not specified. Maximum value is 100.
   */
  pageSize: number;
}

/** Response message for ListServiceConfigs method. */
export interface ListServiceConfigsResponse {
  /** The list of service configuration resources. */
  serviceConfigs: Service[];
  /** The token of the next page of results. */
  nextPageToken: string;
}

/** Request message for CreateServiceConfig method. */
export interface CreateServiceConfigRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
  /** Required. The service configuration resource. */
  serviceConfig?: Service | undefined;
}

/** Request message for SubmitConfigSource method. */
export interface SubmitConfigSourceRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
  /** Required. The source configuration for the service. */
  configSource?:
    | ConfigSource
    | undefined;
  /**
   * Optional. If set, this will result in the generation of a
   * `google.api.Service` configuration based on the `ConfigSource` provided,
   * but the generated config and the sources will NOT be persisted.
   */
  validateOnly: boolean;
}

/** Response message for SubmitConfigSource method. */
export interface SubmitConfigSourceResponse {
  /** The generated service configuration. */
  serviceConfig?: Service | undefined;
}

/** Request message for 'CreateServiceRollout' */
export interface CreateServiceRolloutRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
  /** Required. The rollout resource. The `service_name` field is output only. */
  rollout?: Rollout | undefined;
}

/** Request message for 'ListServiceRollouts' */
export interface ListServiceRolloutsRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
  /** The token of the page to retrieve. */
  pageToken: string;
  /**
   * The max number of items to include in the response list. Page size is 50
   * if not specified. Maximum value is 100.
   */
  pageSize: number;
  /**
   * Required. Use `filter` to return subset of rollouts.
   * The following filters are supported:
   *
   *  -- By [status]
   *  [google.api.servicemanagement.v1.Rollout.RolloutStatus]. For example,
   *  `filter='status=SUCCESS'`
   *
   *  -- By [strategy]
   *  [google.api.servicemanagement.v1.Rollout.strategy]. For example,
   *  `filter='strategy=TrafficPercentStrategy'`
   */
  filter: string;
}

/** Response message for ListServiceRollouts method. */
export interface ListServiceRolloutsResponse {
  /** The list of rollout resources. */
  rollouts: Rollout[];
  /** The token of the next page of results. */
  nextPageToken: string;
}

/** Request message for GetServiceRollout method. */
export interface GetServiceRolloutRequest {
  /**
   * Required. The name of the service.  See the
   * [overview](https://cloud.google.com/service-management/overview) for naming
   * requirements.  For example: `example.googleapis.com`.
   */
  serviceName: string;
  /** Required. The id of the rollout resource. */
  rolloutId: string;
}

/** Operation payload for EnableService method. */
export interface EnableServiceResponse {
}

/** Request message for GenerateConfigReport method. */
export interface GenerateConfigReportRequest {
  /**
   * Required. Service configuration for which we want to generate the report.
   * For this version of API, the supported types are
   * [google.api.servicemanagement.v1.ConfigRef][google.api.servicemanagement.v1.ConfigRef],
   * [google.api.servicemanagement.v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],
   * and [google.api.Service][google.api.Service]
   */
  newConfig?:
    | Any
    | undefined;
  /**
   * Optional. Service configuration against which the comparison will be done.
   * For this version of API, the supported types are
   * [google.api.servicemanagement.v1.ConfigRef][google.api.servicemanagement.v1.ConfigRef],
   * [google.api.servicemanagement.v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],
   * and [google.api.Service][google.api.Service]
   */
  oldConfig?: Any | undefined;
}

/** Response message for GenerateConfigReport method. */
export interface GenerateConfigReportResponse {
  /** Name of the service this report belongs to. */
  serviceName: string;
  /** ID of the service configuration this report belongs to. */
  id: string;
  /**
   * list of ChangeReport, each corresponding to comparison between two
   * service configurations.
   */
  changeReports: ChangeReport[];
  /**
   * Errors / Linter warnings associated with the service definition this
   * report
   * belongs to.
   */
  diagnostics: Diagnostic[];
}

function createBaseListServicesRequest(): ListServicesRequest {
  return { producerProjectId: "", pageSize: 0, pageToken: "", consumerId: "" };
}

export const ListServicesRequest: MessageFns<ListServicesRequest> = {
  encode(message: ListServicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.producerProjectId !== "") {
      writer.uint32(10).string(message.producerProjectId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    if (message.consumerId !== "") {
      writer.uint32(58).string(message.consumerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.producerProjectId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.consumerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesRequest {
    return {
      producerProjectId: isSet(object.producerProjectId)
        ? globalThis.String(object.producerProjectId)
        : isSet(object.producer_project_id)
        ? globalThis.String(object.producer_project_id)
        : "",
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
      pageToken: isSet(object.pageToken)
        ? globalThis.String(object.pageToken)
        : isSet(object.page_token)
        ? globalThis.String(object.page_token)
        : "",
      consumerId: isSet(object.consumerId)
        ? globalThis.String(object.consumerId)
        : isSet(object.consumer_id)
        ? globalThis.String(object.consumer_id)
        : "",
    };
  },

  toJSON(message: ListServicesRequest): unknown {
    const obj: any = {};
    if (message.producerProjectId !== "") {
      obj.producerProjectId = message.producerProjectId;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.consumerId !== "") {
      obj.consumerId = message.consumerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServicesRequest>, I>>(base?: I): ListServicesRequest {
    return ListServicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServicesRequest>, I>>(object: I): ListServicesRequest {
    const message = createBaseListServicesRequest();
    message.producerProjectId = object.producerProjectId ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.consumerId = object.consumerId ?? "";
    return message;
  },
};

function createBaseListServicesResponse(): ListServicesResponse {
  return { services: [], nextPageToken: "" };
}

export const ListServicesResponse: MessageFns<ListServicesResponse> = {
  encode(message: ListServicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.services) {
      ManagedService.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.services.push(ManagedService.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesResponse {
    return {
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => ManagedService.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? globalThis.String(object.nextPageToken)
        : isSet(object.next_page_token)
        ? globalThis.String(object.next_page_token)
        : "",
    };
  },

  toJSON(message: ListServicesResponse): unknown {
    const obj: any = {};
    if (message.services?.length) {
      obj.services = message.services.map((e) => ManagedService.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServicesResponse>, I>>(base?: I): ListServicesResponse {
    return ListServicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServicesResponse>, I>>(object: I): ListServicesResponse {
    const message = createBaseListServicesResponse();
    message.services = object.services?.map((e) => ManagedService.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetServiceRequest(): GetServiceRequest {
  return { serviceName: "" };
}

export const GetServiceRequest: MessageFns<GetServiceRequest> = {
  encode(message: GetServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
    };
  },

  toJSON(message: GetServiceRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceRequest>, I>>(base?: I): GetServiceRequest {
    return GetServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceRequest>, I>>(object: I): GetServiceRequest {
    const message = createBaseGetServiceRequest();
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseCreateServiceRequest(): CreateServiceRequest {
  return { service: undefined };
}

export const CreateServiceRequest: MessageFns<CreateServiceRequest> = {
  encode(message: CreateServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== undefined) {
      ManagedService.encode(message.service, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = ManagedService.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceRequest {
    return { service: isSet(object.service) ? ManagedService.fromJSON(object.service) : undefined };
  },

  toJSON(message: CreateServiceRequest): unknown {
    const obj: any = {};
    if (message.service !== undefined) {
      obj.service = ManagedService.toJSON(message.service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateServiceRequest>, I>>(base?: I): CreateServiceRequest {
    return CreateServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateServiceRequest>, I>>(object: I): CreateServiceRequest {
    const message = createBaseCreateServiceRequest();
    message.service = (object.service !== undefined && object.service !== null)
      ? ManagedService.fromPartial(object.service)
      : undefined;
    return message;
  },
};

function createBaseDeleteServiceRequest(): DeleteServiceRequest {
  return { serviceName: "" };
}

export const DeleteServiceRequest: MessageFns<DeleteServiceRequest> = {
  encode(message: DeleteServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteServiceRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
    };
  },

  toJSON(message: DeleteServiceRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteServiceRequest>, I>>(base?: I): DeleteServiceRequest {
    return DeleteServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteServiceRequest>, I>>(object: I): DeleteServiceRequest {
    const message = createBaseDeleteServiceRequest();
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseUndeleteServiceRequest(): UndeleteServiceRequest {
  return { serviceName: "" };
}

export const UndeleteServiceRequest: MessageFns<UndeleteServiceRequest> = {
  encode(message: UndeleteServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteServiceRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
    };
  },

  toJSON(message: UndeleteServiceRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UndeleteServiceRequest>, I>>(base?: I): UndeleteServiceRequest {
    return UndeleteServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UndeleteServiceRequest>, I>>(object: I): UndeleteServiceRequest {
    const message = createBaseUndeleteServiceRequest();
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseUndeleteServiceResponse(): UndeleteServiceResponse {
  return { service: undefined };
}

export const UndeleteServiceResponse: MessageFns<UndeleteServiceResponse> = {
  encode(message: UndeleteServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== undefined) {
      ManagedService.encode(message.service, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = ManagedService.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteServiceResponse {
    return { service: isSet(object.service) ? ManagedService.fromJSON(object.service) : undefined };
  },

  toJSON(message: UndeleteServiceResponse): unknown {
    const obj: any = {};
    if (message.service !== undefined) {
      obj.service = ManagedService.toJSON(message.service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UndeleteServiceResponse>, I>>(base?: I): UndeleteServiceResponse {
    return UndeleteServiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UndeleteServiceResponse>, I>>(object: I): UndeleteServiceResponse {
    const message = createBaseUndeleteServiceResponse();
    message.service = (object.service !== undefined && object.service !== null)
      ? ManagedService.fromPartial(object.service)
      : undefined;
    return message;
  },
};

function createBaseGetServiceConfigRequest(): GetServiceConfigRequest {
  return { serviceName: "", configId: "", view: 0 };
}

export const GetServiceConfigRequest: MessageFns<GetServiceConfigRequest> = {
  encode(message: GetServiceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.configId !== "") {
      writer.uint32(18).string(message.configId);
    }
    if (message.view !== 0) {
      writer.uint32(24).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceConfigRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      configId: isSet(object.configId)
        ? globalThis.String(object.configId)
        : isSet(object.config_id)
        ? globalThis.String(object.config_id)
        : "",
      view: isSet(object.view) ? getServiceConfigRequest_ConfigViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetServiceConfigRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.configId !== "") {
      obj.configId = message.configId;
    }
    if (message.view !== 0) {
      obj.view = getServiceConfigRequest_ConfigViewToJSON(message.view);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceConfigRequest>, I>>(base?: I): GetServiceConfigRequest {
    return GetServiceConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceConfigRequest>, I>>(object: I): GetServiceConfigRequest {
    const message = createBaseGetServiceConfigRequest();
    message.serviceName = object.serviceName ?? "";
    message.configId = object.configId ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListServiceConfigsRequest(): ListServiceConfigsRequest {
  return { serviceName: "", pageToken: "", pageSize: 0 };
}

export const ListServiceConfigsRequest: MessageFns<ListServiceConfigsRequest> = {
  encode(message: ListServiceConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceConfigsRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      pageToken: isSet(object.pageToken)
        ? globalThis.String(object.pageToken)
        : isSet(object.page_token)
        ? globalThis.String(object.page_token)
        : "",
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListServiceConfigsRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServiceConfigsRequest>, I>>(base?: I): ListServiceConfigsRequest {
    return ListServiceConfigsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServiceConfigsRequest>, I>>(object: I): ListServiceConfigsRequest {
    const message = createBaseListServiceConfigsRequest();
    message.serviceName = object.serviceName ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListServiceConfigsResponse(): ListServiceConfigsResponse {
  return { serviceConfigs: [], nextPageToken: "" };
}

export const ListServiceConfigsResponse: MessageFns<ListServiceConfigsResponse> = {
  encode(message: ListServiceConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.serviceConfigs) {
      Service.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceConfigs.push(Service.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceConfigsResponse {
    return {
      serviceConfigs: globalThis.Array.isArray(object?.serviceConfigs)
        ? object.serviceConfigs.map((e: any) => Service.fromJSON(e))
        : globalThis.Array.isArray(object?.service_configs)
        ? object.service_configs.map((e: any) => Service.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken)
        ? globalThis.String(object.nextPageToken)
        : isSet(object.next_page_token)
        ? globalThis.String(object.next_page_token)
        : "",
    };
  },

  toJSON(message: ListServiceConfigsResponse): unknown {
    const obj: any = {};
    if (message.serviceConfigs?.length) {
      obj.serviceConfigs = message.serviceConfigs.map((e) => Service.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServiceConfigsResponse>, I>>(base?: I): ListServiceConfigsResponse {
    return ListServiceConfigsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServiceConfigsResponse>, I>>(object: I): ListServiceConfigsResponse {
    const message = createBaseListServiceConfigsResponse();
    message.serviceConfigs = object.serviceConfigs?.map((e) => Service.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateServiceConfigRequest(): CreateServiceConfigRequest {
  return { serviceName: "", serviceConfig: undefined };
}

export const CreateServiceConfigRequest: MessageFns<CreateServiceConfigRequest> = {
  encode(message: CreateServiceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.serviceConfig !== undefined) {
      Service.encode(message.serviceConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceConfig = Service.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceConfigRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      serviceConfig: isSet(object.serviceConfig)
        ? Service.fromJSON(object.serviceConfig)
        : isSet(object.service_config)
        ? Service.fromJSON(object.service_config)
        : undefined,
    };
  },

  toJSON(message: CreateServiceConfigRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.serviceConfig !== undefined) {
      obj.serviceConfig = Service.toJSON(message.serviceConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateServiceConfigRequest>, I>>(base?: I): CreateServiceConfigRequest {
    return CreateServiceConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateServiceConfigRequest>, I>>(object: I): CreateServiceConfigRequest {
    const message = createBaseCreateServiceConfigRequest();
    message.serviceName = object.serviceName ?? "";
    message.serviceConfig = (object.serviceConfig !== undefined && object.serviceConfig !== null)
      ? Service.fromPartial(object.serviceConfig)
      : undefined;
    return message;
  },
};

function createBaseSubmitConfigSourceRequest(): SubmitConfigSourceRequest {
  return { serviceName: "", configSource: undefined, validateOnly: false };
}

export const SubmitConfigSourceRequest: MessageFns<SubmitConfigSourceRequest> = {
  encode(message: SubmitConfigSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.configSource !== undefined) {
      ConfigSource.encode(message.configSource, writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitConfigSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitConfigSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configSource = ConfigSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitConfigSourceRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      configSource: isSet(object.configSource)
        ? ConfigSource.fromJSON(object.configSource)
        : isSet(object.config_source)
        ? ConfigSource.fromJSON(object.config_source)
        : undefined,
      validateOnly: isSet(object.validateOnly)
        ? globalThis.Boolean(object.validateOnly)
        : isSet(object.validate_only)
        ? globalThis.Boolean(object.validate_only)
        : false,
    };
  },

  toJSON(message: SubmitConfigSourceRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.configSource !== undefined) {
      obj.configSource = ConfigSource.toJSON(message.configSource);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitConfigSourceRequest>, I>>(base?: I): SubmitConfigSourceRequest {
    return SubmitConfigSourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitConfigSourceRequest>, I>>(object: I): SubmitConfigSourceRequest {
    const message = createBaseSubmitConfigSourceRequest();
    message.serviceName = object.serviceName ?? "";
    message.configSource = (object.configSource !== undefined && object.configSource !== null)
      ? ConfigSource.fromPartial(object.configSource)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseSubmitConfigSourceResponse(): SubmitConfigSourceResponse {
  return { serviceConfig: undefined };
}

export const SubmitConfigSourceResponse: MessageFns<SubmitConfigSourceResponse> = {
  encode(message: SubmitConfigSourceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceConfig !== undefined) {
      Service.encode(message.serviceConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitConfigSourceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitConfigSourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceConfig = Service.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitConfigSourceResponse {
    return {
      serviceConfig: isSet(object.serviceConfig)
        ? Service.fromJSON(object.serviceConfig)
        : isSet(object.service_config)
        ? Service.fromJSON(object.service_config)
        : undefined,
    };
  },

  toJSON(message: SubmitConfigSourceResponse): unknown {
    const obj: any = {};
    if (message.serviceConfig !== undefined) {
      obj.serviceConfig = Service.toJSON(message.serviceConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitConfigSourceResponse>, I>>(base?: I): SubmitConfigSourceResponse {
    return SubmitConfigSourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitConfigSourceResponse>, I>>(object: I): SubmitConfigSourceResponse {
    const message = createBaseSubmitConfigSourceResponse();
    message.serviceConfig = (object.serviceConfig !== undefined && object.serviceConfig !== null)
      ? Service.fromPartial(object.serviceConfig)
      : undefined;
    return message;
  },
};

function createBaseCreateServiceRolloutRequest(): CreateServiceRolloutRequest {
  return { serviceName: "", rollout: undefined };
}

export const CreateServiceRolloutRequest: MessageFns<CreateServiceRolloutRequest> = {
  encode(message: CreateServiceRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.rollout !== undefined) {
      Rollout.encode(message.rollout, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rollout = Rollout.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceRolloutRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      rollout: isSet(object.rollout) ? Rollout.fromJSON(object.rollout) : undefined,
    };
  },

  toJSON(message: CreateServiceRolloutRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.rollout !== undefined) {
      obj.rollout = Rollout.toJSON(message.rollout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateServiceRolloutRequest>, I>>(base?: I): CreateServiceRolloutRequest {
    return CreateServiceRolloutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateServiceRolloutRequest>, I>>(object: I): CreateServiceRolloutRequest {
    const message = createBaseCreateServiceRolloutRequest();
    message.serviceName = object.serviceName ?? "";
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? Rollout.fromPartial(object.rollout)
      : undefined;
    return message;
  },
};

function createBaseListServiceRolloutsRequest(): ListServiceRolloutsRequest {
  return { serviceName: "", pageToken: "", pageSize: 0, filter: "" };
}

export const ListServiceRolloutsRequest: MessageFns<ListServiceRolloutsRequest> = {
  encode(message: ListServiceRolloutsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceRolloutsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceRolloutsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceRolloutsRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      pageToken: isSet(object.pageToken)
        ? globalThis.String(object.pageToken)
        : isSet(object.page_token)
        ? globalThis.String(object.page_token)
        : "",
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListServiceRolloutsRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServiceRolloutsRequest>, I>>(base?: I): ListServiceRolloutsRequest {
    return ListServiceRolloutsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServiceRolloutsRequest>, I>>(object: I): ListServiceRolloutsRequest {
    const message = createBaseListServiceRolloutsRequest();
    message.serviceName = object.serviceName ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListServiceRolloutsResponse(): ListServiceRolloutsResponse {
  return { rollouts: [], nextPageToken: "" };
}

export const ListServiceRolloutsResponse: MessageFns<ListServiceRolloutsResponse> = {
  encode(message: ListServiceRolloutsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rollouts) {
      Rollout.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceRolloutsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServiceRolloutsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rollouts.push(Rollout.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServiceRolloutsResponse {
    return {
      rollouts: globalThis.Array.isArray(object?.rollouts) ? object.rollouts.map((e: any) => Rollout.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken)
        ? globalThis.String(object.nextPageToken)
        : isSet(object.next_page_token)
        ? globalThis.String(object.next_page_token)
        : "",
    };
  },

  toJSON(message: ListServiceRolloutsResponse): unknown {
    const obj: any = {};
    if (message.rollouts?.length) {
      obj.rollouts = message.rollouts.map((e) => Rollout.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServiceRolloutsResponse>, I>>(base?: I): ListServiceRolloutsResponse {
    return ListServiceRolloutsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServiceRolloutsResponse>, I>>(object: I): ListServiceRolloutsResponse {
    const message = createBaseListServiceRolloutsResponse();
    message.rollouts = object.rollouts?.map((e) => Rollout.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetServiceRolloutRequest(): GetServiceRolloutRequest {
  return { serviceName: "", rolloutId: "" };
}

export const GetServiceRolloutRequest: MessageFns<GetServiceRolloutRequest> = {
  encode(message: GetServiceRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.rolloutId !== "") {
      writer.uint32(18).string(message.rolloutId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rolloutId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceRolloutRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      rolloutId: isSet(object.rolloutId)
        ? globalThis.String(object.rolloutId)
        : isSet(object.rollout_id)
        ? globalThis.String(object.rollout_id)
        : "",
    };
  },

  toJSON(message: GetServiceRolloutRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.rolloutId !== "") {
      obj.rolloutId = message.rolloutId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceRolloutRequest>, I>>(base?: I): GetServiceRolloutRequest {
    return GetServiceRolloutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceRolloutRequest>, I>>(object: I): GetServiceRolloutRequest {
    const message = createBaseGetServiceRolloutRequest();
    message.serviceName = object.serviceName ?? "";
    message.rolloutId = object.rolloutId ?? "";
    return message;
  },
};

function createBaseEnableServiceResponse(): EnableServiceResponse {
  return {};
}

export const EnableServiceResponse: MessageFns<EnableServiceResponse> = {
  encode(_: EnableServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EnableServiceResponse {
    return {};
  },

  toJSON(_: EnableServiceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EnableServiceResponse>, I>>(base?: I): EnableServiceResponse {
    return EnableServiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnableServiceResponse>, I>>(_: I): EnableServiceResponse {
    const message = createBaseEnableServiceResponse();
    return message;
  },
};

function createBaseGenerateConfigReportRequest(): GenerateConfigReportRequest {
  return { newConfig: undefined, oldConfig: undefined };
}

export const GenerateConfigReportRequest: MessageFns<GenerateConfigReportRequest> = {
  encode(message: GenerateConfigReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newConfig !== undefined) {
      Any.encode(message.newConfig, writer.uint32(10).fork()).join();
    }
    if (message.oldConfig !== undefined) {
      Any.encode(message.oldConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateConfigReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateConfigReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newConfig = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldConfig = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateConfigReportRequest {
    return {
      newConfig: isSet(object.newConfig)
        ? Any.fromJSON(object.newConfig)
        : isSet(object.new_config)
        ? Any.fromJSON(object.new_config)
        : undefined,
      oldConfig: isSet(object.oldConfig)
        ? Any.fromJSON(object.oldConfig)
        : isSet(object.old_config)
        ? Any.fromJSON(object.old_config)
        : undefined,
    };
  },

  toJSON(message: GenerateConfigReportRequest): unknown {
    const obj: any = {};
    if (message.newConfig !== undefined) {
      obj.newConfig = Any.toJSON(message.newConfig);
    }
    if (message.oldConfig !== undefined) {
      obj.oldConfig = Any.toJSON(message.oldConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateConfigReportRequest>, I>>(base?: I): GenerateConfigReportRequest {
    return GenerateConfigReportRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateConfigReportRequest>, I>>(object: I): GenerateConfigReportRequest {
    const message = createBaseGenerateConfigReportRequest();
    message.newConfig = (object.newConfig !== undefined && object.newConfig !== null)
      ? Any.fromPartial(object.newConfig)
      : undefined;
    message.oldConfig = (object.oldConfig !== undefined && object.oldConfig !== null)
      ? Any.fromPartial(object.oldConfig)
      : undefined;
    return message;
  },
};

function createBaseGenerateConfigReportResponse(): GenerateConfigReportResponse {
  return { serviceName: "", id: "", changeReports: [], diagnostics: [] };
}

export const GenerateConfigReportResponse: MessageFns<GenerateConfigReportResponse> = {
  encode(message: GenerateConfigReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    for (const v of message.changeReports) {
      ChangeReport.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.diagnostics) {
      Diagnostic.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateConfigReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateConfigReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.changeReports.push(ChangeReport.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.diagnostics.push(Diagnostic.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateConfigReportResponse {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      changeReports: globalThis.Array.isArray(object?.changeReports)
        ? object.changeReports.map((e: any) => ChangeReport.fromJSON(e))
        : globalThis.Array.isArray(object?.change_reports)
        ? object.change_reports.map((e: any) => ChangeReport.fromJSON(e))
        : [],
      diagnostics: globalThis.Array.isArray(object?.diagnostics)
        ? object.diagnostics.map((e: any) => Diagnostic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateConfigReportResponse): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.changeReports?.length) {
      obj.changeReports = message.changeReports.map((e) => ChangeReport.toJSON(e));
    }
    if (message.diagnostics?.length) {
      obj.diagnostics = message.diagnostics.map((e) => Diagnostic.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateConfigReportResponse>, I>>(base?: I): GenerateConfigReportResponse {
    return GenerateConfigReportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateConfigReportResponse>, I>>(object: I): GenerateConfigReportResponse {
    const message = createBaseGenerateConfigReportResponse();
    message.serviceName = object.serviceName ?? "";
    message.id = object.id ?? "";
    message.changeReports = object.changeReports?.map((e) => ChangeReport.fromPartial(e)) || [];
    message.diagnostics = object.diagnostics?.map((e) => Diagnostic.fromPartial(e)) || [];
    return message;
  },
};

/**
 * [Google Service Management
 * API](https://cloud.google.com/service-infrastructure/docs/overview)
 */
export interface ServiceManager {
  /**
   * Lists managed services.
   *
   * Returns all public services. For authenticated users, also returns all
   * services the calling user has "servicemanagement.services.get" permission
   * for.
   */
  ListServices(request: DeepPartial<ListServicesRequest>, metadata?: grpc.Metadata): Promise<ListServicesResponse>;
  /**
   * Gets a managed service. Authentication is required unless the service is
   * public.
   */
  GetService(request: DeepPartial<GetServiceRequest>, metadata?: grpc.Metadata): Promise<ManagedService>;
  /**
   * Creates a new managed service.
   *
   * A managed service is immutable, and is subject to mandatory 30-day
   * data retention. You cannot move a service or recreate it within 30 days
   * after deletion.
   *
   * One producer project can own no more than 500 services. For security and
   * reliability purposes, a production service should be hosted in a
   * dedicated producer project.
   *
   * Operation<response: ManagedService>
   */
  CreateService(request: DeepPartial<CreateServiceRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Deletes a managed service. This method will change the service to the
   * `Soft-Delete` state for 30 days. Within this period, service producers may
   * call
   * [UndeleteService][google.api.servicemanagement.v1.ServiceManager.UndeleteService]
   * to restore the service. After 30 days, the service will be permanently
   * deleted.
   *
   * Operation<response: google.protobuf.Empty>
   */
  DeleteService(request: DeepPartial<DeleteServiceRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Revives a previously deleted managed service. The method restores the
   * service using the configuration at the time the service was deleted.
   * The target service must exist and must have been deleted within the
   * last 30 days.
   *
   * Operation<response: UndeleteServiceResponse>
   */
  UndeleteService(request: DeepPartial<UndeleteServiceRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Lists the history of the service configuration for a managed service,
   * from the newest to the oldest.
   */
  ListServiceConfigs(
    request: DeepPartial<ListServiceConfigsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListServiceConfigsResponse>;
  /** Gets a service configuration (version) for a managed service. */
  GetServiceConfig(request: DeepPartial<GetServiceConfigRequest>, metadata?: grpc.Metadata): Promise<Service>;
  /**
   * Creates a new service configuration (version) for a managed service.
   * This method only stores the service configuration. To roll out the service
   * configuration to backend systems please call
   * [CreateServiceRollout][google.api.servicemanagement.v1.ServiceManager.CreateServiceRollout].
   *
   * Only the 100 most recent service configurations and ones referenced by
   * existing rollouts are kept for each service. The rest will be deleted
   * eventually.
   */
  CreateServiceConfig(request: DeepPartial<CreateServiceConfigRequest>, metadata?: grpc.Metadata): Promise<Service>;
  /**
   * Creates a new service configuration (version) for a managed service based
   * on
   * user-supplied configuration source files (for example: OpenAPI
   * Specification). This method stores the source configurations as well as the
   * generated service configuration. To rollout the service configuration to
   * other services,
   * please call
   * [CreateServiceRollout][google.api.servicemanagement.v1.ServiceManager.CreateServiceRollout].
   *
   * Only the 100 most recent configuration sources and ones referenced by
   * existing service configurtions are kept for each service. The rest will be
   * deleted eventually.
   *
   * Operation<response: SubmitConfigSourceResponse>
   */
  SubmitConfigSource(request: DeepPartial<SubmitConfigSourceRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Lists the history of the service configuration rollouts for a managed
   * service, from the newest to the oldest.
   */
  ListServiceRollouts(
    request: DeepPartial<ListServiceRolloutsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListServiceRolloutsResponse>;
  /**
   * Gets a service configuration
   * [rollout][google.api.servicemanagement.v1.Rollout].
   */
  GetServiceRollout(request: DeepPartial<GetServiceRolloutRequest>, metadata?: grpc.Metadata): Promise<Rollout>;
  /**
   * Creates a new service configuration rollout. Based on rollout, the
   * Google Service Management will roll out the service configurations to
   * different backend services. For example, the logging configuration will be
   * pushed to Google Cloud Logging.
   *
   * Please note that any previous pending and running Rollouts and associated
   * Operations will be automatically cancelled so that the latest Rollout will
   * not be blocked by previous Rollouts.
   *
   * Only the 100 most recent (in any state) and the last 10 successful (if not
   * already part of the set of 100 most recent) rollouts are kept for each
   * service. The rest will be deleted eventually.
   *
   * Operation<response: Rollout>
   */
  CreateServiceRollout(request: DeepPartial<CreateServiceRolloutRequest>, metadata?: grpc.Metadata): Promise<Operation>;
  /**
   * Generates and returns a report (errors, warnings and changes from
   * existing configurations) associated with
   * GenerateConfigReportRequest.new_value
   *
   * If GenerateConfigReportRequest.old_value is specified,
   * GenerateConfigReportRequest will contain a single ChangeReport based on the
   * comparison between GenerateConfigReportRequest.new_value and
   * GenerateConfigReportRequest.old_value.
   * If GenerateConfigReportRequest.old_value is not specified, this method
   * will compare GenerateConfigReportRequest.new_value with the last pushed
   * service configuration.
   */
  GenerateConfigReport(
    request: DeepPartial<GenerateConfigReportRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenerateConfigReportResponse>;
}

export class ServiceManagerClientImpl implements ServiceManager {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.ListServices = this.ListServices.bind(this);
    this.GetService = this.GetService.bind(this);
    this.CreateService = this.CreateService.bind(this);
    this.DeleteService = this.DeleteService.bind(this);
    this.UndeleteService = this.UndeleteService.bind(this);
    this.ListServiceConfigs = this.ListServiceConfigs.bind(this);
    this.GetServiceConfig = this.GetServiceConfig.bind(this);
    this.CreateServiceConfig = this.CreateServiceConfig.bind(this);
    this.SubmitConfigSource = this.SubmitConfigSource.bind(this);
    this.ListServiceRollouts = this.ListServiceRollouts.bind(this);
    this.GetServiceRollout = this.GetServiceRollout.bind(this);
    this.CreateServiceRollout = this.CreateServiceRollout.bind(this);
    this.GenerateConfigReport = this.GenerateConfigReport.bind(this);
  }

  ListServices(request: DeepPartial<ListServicesRequest>, metadata?: grpc.Metadata): Promise<ListServicesResponse> {
    return this.rpc.unary(ServiceManagerListServicesDesc, ListServicesRequest.fromPartial(request), metadata);
  }

  GetService(request: DeepPartial<GetServiceRequest>, metadata?: grpc.Metadata): Promise<ManagedService> {
    return this.rpc.unary(ServiceManagerGetServiceDesc, GetServiceRequest.fromPartial(request), metadata);
  }

  CreateService(request: DeepPartial<CreateServiceRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(ServiceManagerCreateServiceDesc, CreateServiceRequest.fromPartial(request), metadata);
  }

  DeleteService(request: DeepPartial<DeleteServiceRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(ServiceManagerDeleteServiceDesc, DeleteServiceRequest.fromPartial(request), metadata);
  }

  UndeleteService(request: DeepPartial<UndeleteServiceRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(ServiceManagerUndeleteServiceDesc, UndeleteServiceRequest.fromPartial(request), metadata);
  }

  ListServiceConfigs(
    request: DeepPartial<ListServiceConfigsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListServiceConfigsResponse> {
    return this.rpc.unary(
      ServiceManagerListServiceConfigsDesc,
      ListServiceConfigsRequest.fromPartial(request),
      metadata,
    );
  }

  GetServiceConfig(request: DeepPartial<GetServiceConfigRequest>, metadata?: grpc.Metadata): Promise<Service> {
    return this.rpc.unary(ServiceManagerGetServiceConfigDesc, GetServiceConfigRequest.fromPartial(request), metadata);
  }

  CreateServiceConfig(request: DeepPartial<CreateServiceConfigRequest>, metadata?: grpc.Metadata): Promise<Service> {
    return this.rpc.unary(
      ServiceManagerCreateServiceConfigDesc,
      CreateServiceConfigRequest.fromPartial(request),
      metadata,
    );
  }

  SubmitConfigSource(request: DeepPartial<SubmitConfigSourceRequest>, metadata?: grpc.Metadata): Promise<Operation> {
    return this.rpc.unary(
      ServiceManagerSubmitConfigSourceDesc,
      SubmitConfigSourceRequest.fromPartial(request),
      metadata,
    );
  }

  ListServiceRollouts(
    request: DeepPartial<ListServiceRolloutsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListServiceRolloutsResponse> {
    return this.rpc.unary(
      ServiceManagerListServiceRolloutsDesc,
      ListServiceRolloutsRequest.fromPartial(request),
      metadata,
    );
  }

  GetServiceRollout(request: DeepPartial<GetServiceRolloutRequest>, metadata?: grpc.Metadata): Promise<Rollout> {
    return this.rpc.unary(ServiceManagerGetServiceRolloutDesc, GetServiceRolloutRequest.fromPartial(request), metadata);
  }

  CreateServiceRollout(
    request: DeepPartial<CreateServiceRolloutRequest>,
    metadata?: grpc.Metadata,
  ): Promise<Operation> {
    return this.rpc.unary(
      ServiceManagerCreateServiceRolloutDesc,
      CreateServiceRolloutRequest.fromPartial(request),
      metadata,
    );
  }

  GenerateConfigReport(
    request: DeepPartial<GenerateConfigReportRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenerateConfigReportResponse> {
    return this.rpc.unary(
      ServiceManagerGenerateConfigReportDesc,
      GenerateConfigReportRequest.fromPartial(request),
      metadata,
    );
  }
}

export const ServiceManagerDesc = { serviceName: "google.api.servicemanagement.v1.ServiceManager" };

export const ServiceManagerListServicesDesc: UnaryMethodDefinitionish = {
  methodName: "ListServices",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListServicesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListServicesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerGetServiceDesc: UnaryMethodDefinitionish = {
  methodName: "GetService",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ManagedService.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerCreateServiceDesc: UnaryMethodDefinitionish = {
  methodName: "CreateService",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerDeleteServiceDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteService",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerUndeleteServiceDesc: UnaryMethodDefinitionish = {
  methodName: "UndeleteService",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UndeleteServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerListServiceConfigsDesc: UnaryMethodDefinitionish = {
  methodName: "ListServiceConfigs",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListServiceConfigsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListServiceConfigsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerGetServiceConfigDesc: UnaryMethodDefinitionish = {
  methodName: "GetServiceConfig",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetServiceConfigRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Service.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerCreateServiceConfigDesc: UnaryMethodDefinitionish = {
  methodName: "CreateServiceConfig",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateServiceConfigRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Service.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerSubmitConfigSourceDesc: UnaryMethodDefinitionish = {
  methodName: "SubmitConfigSource",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SubmitConfigSourceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerListServiceRolloutsDesc: UnaryMethodDefinitionish = {
  methodName: "ListServiceRollouts",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListServiceRolloutsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListServiceRolloutsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerGetServiceRolloutDesc: UnaryMethodDefinitionish = {
  methodName: "GetServiceRollout",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetServiceRolloutRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Rollout.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerCreateServiceRolloutDesc: UnaryMethodDefinitionish = {
  methodName: "CreateServiceRollout",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateServiceRolloutRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = Operation.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ServiceManagerGenerateConfigReportDesc: UnaryMethodDefinitionish = {
  methodName: "GenerateConfigReport",
  service: ServiceManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenerateConfigReportRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenerateConfigReportResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
