// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: proto/api/v1/registration.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import { ResourceDefinition } from "../../config/v1/resource";
import { ToolDefinition } from "../../config/v1/tool";
import { UpstreamServiceConfig } from "../../config/v1/upstream_service";

export const protobufPackage = "mcpany.api.v1";

export interface RegisterServiceRequest {
  config?: UpstreamServiceConfig | undefined;
}

export interface RegisterServiceResponse {
  /** e.g., "Service registered successfully" */
  message: string;
  discoveredTools: ToolDefinition[];
  /** The generated key for the service */
  serviceKey: string;
  discoveredResources: ResourceDefinition[];
}

export interface ValidateServiceRequest {
  config?: UpstreamServiceConfig | undefined;
}

export interface ValidateServiceResponse {
  valid: boolean;
  message: string;
  discoveredTools: ToolDefinition[];
  discoveredResources: ResourceDefinition[];
}

export interface ListServicesRequest {
}

export interface ListServicesResponse {
  services: UpstreamServiceConfig[];
}

export interface InitiateOAuth2FlowRequest {
  serviceId: string;
  namespace: string;
  credentialId: string;
  redirectUrl: string;
}

export interface InitiateOAuth2FlowResponse {
  authorizationUrl: string;
  state: string;
}

export interface UnregisterServiceRequest {
  /** User-defined unique ID for the service to deregister */
  serviceName: string;
  /** Optional namespace for the service */
  namespace: string;
}

export interface UnregisterServiceResponse {
  /** e.g., "Service unregistered successfully" */
  message: string;
}

export interface RegisterToolsRequest {
  serviceName: string;
  namespace: string;
  tools: ToolDefinition[];
}

export interface RegisterToolsResponse {
  message: string;
  toolsRegistered: number;
}

export interface GetServiceRequest {
  serviceName: string;
}

export interface GetServiceResponse {
  service?: UpstreamServiceConfig | undefined;
}

export interface GetServiceStatusRequest {
  serviceName: string;
  namespace: string;
}

export interface GetServiceStatusResponse {
  tools: ToolDefinition[];
  metrics: { [key: string]: Long };
}

export interface GetServiceStatusResponse_MetricsEntry {
  key: string;
  value: Long;
}

function createBaseRegisterServiceRequest(): RegisterServiceRequest {
  return { config: undefined };
}

export const RegisterServiceRequest: MessageFns<RegisterServiceRequest> = {
  encode(message: RegisterServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      UpstreamServiceConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = UpstreamServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterServiceRequest {
    return { config: isSet(object.config) ? UpstreamServiceConfig.fromJSON(object.config) : undefined };
  },

  toJSON(message: RegisterServiceRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = UpstreamServiceConfig.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterServiceRequest>, I>>(base?: I): RegisterServiceRequest {
    return RegisterServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterServiceRequest>, I>>(object: I): RegisterServiceRequest {
    const message = createBaseRegisterServiceRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? UpstreamServiceConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseRegisterServiceResponse(): RegisterServiceResponse {
  return { message: "", discoveredTools: [], serviceKey: "", discoveredResources: [] };
}

export const RegisterServiceResponse: MessageFns<RegisterServiceResponse> = {
  encode(message: RegisterServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    for (const v of message.discoveredTools) {
      ToolDefinition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.serviceKey !== "") {
      writer.uint32(26).string(message.serviceKey);
    }
    for (const v of message.discoveredResources) {
      ResourceDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.discoveredTools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.discoveredResources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterServiceResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      discoveredTools: globalThis.Array.isArray(object?.discoveredTools)
        ? object.discoveredTools.map((e: any) => ToolDefinition.fromJSON(e))
        : globalThis.Array.isArray(object?.discovered_tools)
        ? object.discovered_tools.map((e: any) => ToolDefinition.fromJSON(e))
        : [],
      serviceKey: isSet(object.serviceKey)
        ? globalThis.String(object.serviceKey)
        : isSet(object.service_key)
        ? globalThis.String(object.service_key)
        : "",
      discoveredResources: globalThis.Array.isArray(object?.discoveredResources)
        ? object.discoveredResources.map((e: any) => ResourceDefinition.fromJSON(e))
        : globalThis.Array.isArray(object?.discovered_resources)
        ? object.discovered_resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RegisterServiceResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.discoveredTools?.length) {
      obj.discoveredTools = message.discoveredTools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.serviceKey !== "") {
      obj.serviceKey = message.serviceKey;
    }
    if (message.discoveredResources?.length) {
      obj.discoveredResources = message.discoveredResources.map((e) => ResourceDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterServiceResponse>, I>>(base?: I): RegisterServiceResponse {
    return RegisterServiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterServiceResponse>, I>>(object: I): RegisterServiceResponse {
    const message = createBaseRegisterServiceResponse();
    message.message = object.message ?? "";
    message.discoveredTools = object.discoveredTools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.serviceKey = object.serviceKey ?? "";
    message.discoveredResources = object.discoveredResources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValidateServiceRequest(): ValidateServiceRequest {
  return { config: undefined };
}

export const ValidateServiceRequest: MessageFns<ValidateServiceRequest> = {
  encode(message: ValidateServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      UpstreamServiceConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.config = UpstreamServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateServiceRequest {
    return { config: isSet(object.config) ? UpstreamServiceConfig.fromJSON(object.config) : undefined };
  },

  toJSON(message: ValidateServiceRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = UpstreamServiceConfig.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateServiceRequest>, I>>(base?: I): ValidateServiceRequest {
    return ValidateServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateServiceRequest>, I>>(object: I): ValidateServiceRequest {
    const message = createBaseValidateServiceRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? UpstreamServiceConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseValidateServiceResponse(): ValidateServiceResponse {
  return { valid: false, message: "", discoveredTools: [], discoveredResources: [] };
}

export const ValidateServiceResponse: MessageFns<ValidateServiceResponse> = {
  encode(message: ValidateServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.discoveredTools) {
      ToolDefinition.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.discoveredResources) {
      ResourceDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.discoveredTools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.discoveredResources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateServiceResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      discoveredTools: globalThis.Array.isArray(object?.discoveredTools)
        ? object.discoveredTools.map((e: any) => ToolDefinition.fromJSON(e))
        : globalThis.Array.isArray(object?.discovered_tools)
        ? object.discovered_tools.map((e: any) => ToolDefinition.fromJSON(e))
        : [],
      discoveredResources: globalThis.Array.isArray(object?.discoveredResources)
        ? object.discoveredResources.map((e: any) => ResourceDefinition.fromJSON(e))
        : globalThis.Array.isArray(object?.discovered_resources)
        ? object.discovered_resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidateServiceResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.discoveredTools?.length) {
      obj.discoveredTools = message.discoveredTools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.discoveredResources?.length) {
      obj.discoveredResources = message.discoveredResources.map((e) => ResourceDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateServiceResponse>, I>>(base?: I): ValidateServiceResponse {
    return ValidateServiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateServiceResponse>, I>>(object: I): ValidateServiceResponse {
    const message = createBaseValidateServiceResponse();
    message.valid = object.valid ?? false;
    message.message = object.message ?? "";
    message.discoveredTools = object.discoveredTools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.discoveredResources = object.discoveredResources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListServicesRequest(): ListServicesRequest {
  return {};
}

export const ListServicesRequest: MessageFns<ListServicesRequest> = {
  encode(_: ListServicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListServicesRequest {
    return {};
  },

  toJSON(_: ListServicesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServicesRequest>, I>>(base?: I): ListServicesRequest {
    return ListServicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServicesRequest>, I>>(_: I): ListServicesRequest {
    const message = createBaseListServicesRequest();
    return message;
  },
};

function createBaseListServicesResponse(): ListServicesResponse {
  return { services: [] };
}

export const ListServicesResponse: MessageFns<ListServicesResponse> = {
  encode(message: ListServicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.services) {
      UpstreamServiceConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.services.push(UpstreamServiceConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesResponse {
    return {
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => UpstreamServiceConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListServicesResponse): unknown {
    const obj: any = {};
    if (message.services?.length) {
      obj.services = message.services.map((e) => UpstreamServiceConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListServicesResponse>, I>>(base?: I): ListServicesResponse {
    return ListServicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListServicesResponse>, I>>(object: I): ListServicesResponse {
    const message = createBaseListServicesResponse();
    message.services = object.services?.map((e) => UpstreamServiceConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInitiateOAuth2FlowRequest(): InitiateOAuth2FlowRequest {
  return { serviceId: "", namespace: "", credentialId: "", redirectUrl: "" };
}

export const InitiateOAuth2FlowRequest: MessageFns<InitiateOAuth2FlowRequest> = {
  encode(message: InitiateOAuth2FlowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.credentialId !== "") {
      writer.uint32(26).string(message.credentialId);
    }
    if (message.redirectUrl !== "") {
      writer.uint32(34).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateOAuth2FlowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateOAuth2FlowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.credentialId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateOAuth2FlowRequest {
    return {
      serviceId: isSet(object.serviceId)
        ? globalThis.String(object.serviceId)
        : isSet(object.service_id)
        ? globalThis.String(object.service_id)
        : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      credentialId: isSet(object.credentialId)
        ? globalThis.String(object.credentialId)
        : isSet(object.credential_id)
        ? globalThis.String(object.credential_id)
        : "",
      redirectUrl: isSet(object.redirectUrl)
        ? globalThis.String(object.redirectUrl)
        : isSet(object.redirect_url)
        ? globalThis.String(object.redirect_url)
        : "",
    };
  },

  toJSON(message: InitiateOAuth2FlowRequest): unknown {
    const obj: any = {};
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.credentialId !== "") {
      obj.credentialId = message.credentialId;
    }
    if (message.redirectUrl !== "") {
      obj.redirectUrl = message.redirectUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateOAuth2FlowRequest>, I>>(base?: I): InitiateOAuth2FlowRequest {
    return InitiateOAuth2FlowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateOAuth2FlowRequest>, I>>(object: I): InitiateOAuth2FlowRequest {
    const message = createBaseInitiateOAuth2FlowRequest();
    message.serviceId = object.serviceId ?? "";
    message.namespace = object.namespace ?? "";
    message.credentialId = object.credentialId ?? "";
    message.redirectUrl = object.redirectUrl ?? "";
    return message;
  },
};

function createBaseInitiateOAuth2FlowResponse(): InitiateOAuth2FlowResponse {
  return { authorizationUrl: "", state: "" };
}

export const InitiateOAuth2FlowResponse: MessageFns<InitiateOAuth2FlowResponse> = {
  encode(message: InitiateOAuth2FlowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorizationUrl !== "") {
      writer.uint32(10).string(message.authorizationUrl);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateOAuth2FlowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateOAuth2FlowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateOAuth2FlowResponse {
    return {
      authorizationUrl: isSet(object.authorizationUrl)
        ? globalThis.String(object.authorizationUrl)
        : isSet(object.authorization_url)
        ? globalThis.String(object.authorization_url)
        : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
    };
  },

  toJSON(message: InitiateOAuth2FlowResponse): unknown {
    const obj: any = {};
    if (message.authorizationUrl !== "") {
      obj.authorizationUrl = message.authorizationUrl;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateOAuth2FlowResponse>, I>>(base?: I): InitiateOAuth2FlowResponse {
    return InitiateOAuth2FlowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateOAuth2FlowResponse>, I>>(object: I): InitiateOAuth2FlowResponse {
    const message = createBaseInitiateOAuth2FlowResponse();
    message.authorizationUrl = object.authorizationUrl ?? "";
    message.state = object.state ?? "";
    return message;
  },
};

function createBaseUnregisterServiceRequest(): UnregisterServiceRequest {
  return { serviceName: "", namespace: "" };
}

export const UnregisterServiceRequest: MessageFns<UnregisterServiceRequest> = {
  encode(message: UnregisterServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnregisterServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterServiceRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
    };
  },

  toJSON(message: UnregisterServiceRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnregisterServiceRequest>, I>>(base?: I): UnregisterServiceRequest {
    return UnregisterServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnregisterServiceRequest>, I>>(object: I): UnregisterServiceRequest {
    const message = createBaseUnregisterServiceRequest();
    message.serviceName = object.serviceName ?? "";
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseUnregisterServiceResponse(): UnregisterServiceResponse {
  return { message: "" };
}

export const UnregisterServiceResponse: MessageFns<UnregisterServiceResponse> = {
  encode(message: UnregisterServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnregisterServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterServiceResponse {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UnregisterServiceResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnregisterServiceResponse>, I>>(base?: I): UnregisterServiceResponse {
    return UnregisterServiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnregisterServiceResponse>, I>>(object: I): UnregisterServiceResponse {
    const message = createBaseUnregisterServiceResponse();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRegisterToolsRequest(): RegisterToolsRequest {
  return { serviceName: "", namespace: "", tools: [] };
}

export const RegisterToolsRequest: MessageFns<RegisterToolsRequest> = {
  encode(message: RegisterToolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterToolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterToolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterToolsRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
    };
  },

  toJSON(message: RegisterToolsRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterToolsRequest>, I>>(base?: I): RegisterToolsRequest {
    return RegisterToolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterToolsRequest>, I>>(object: I): RegisterToolsRequest {
    const message = createBaseRegisterToolsRequest();
    message.serviceName = object.serviceName ?? "";
    message.namespace = object.namespace ?? "";
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRegisterToolsResponse(): RegisterToolsResponse {
  return { message: "", toolsRegistered: 0 };
}

export const RegisterToolsResponse: MessageFns<RegisterToolsResponse> = {
  encode(message: RegisterToolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.toolsRegistered !== 0) {
      writer.uint32(16).int32(message.toolsRegistered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterToolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterToolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toolsRegistered = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterToolsResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      toolsRegistered: isSet(object.toolsRegistered)
        ? globalThis.Number(object.toolsRegistered)
        : isSet(object.tools_registered)
        ? globalThis.Number(object.tools_registered)
        : 0,
    };
  },

  toJSON(message: RegisterToolsResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.toolsRegistered !== 0) {
      obj.toolsRegistered = Math.round(message.toolsRegistered);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterToolsResponse>, I>>(base?: I): RegisterToolsResponse {
    return RegisterToolsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterToolsResponse>, I>>(object: I): RegisterToolsResponse {
    const message = createBaseRegisterToolsResponse();
    message.message = object.message ?? "";
    message.toolsRegistered = object.toolsRegistered ?? 0;
    return message;
  },
};

function createBaseGetServiceRequest(): GetServiceRequest {
  return { serviceName: "" };
}

export const GetServiceRequest: MessageFns<GetServiceRequest> = {
  encode(message: GetServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
    };
  },

  toJSON(message: GetServiceRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceRequest>, I>>(base?: I): GetServiceRequest {
    return GetServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceRequest>, I>>(object: I): GetServiceRequest {
    const message = createBaseGetServiceRequest();
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseGetServiceResponse(): GetServiceResponse {
  return { service: undefined };
}

export const GetServiceResponse: MessageFns<GetServiceResponse> = {
  encode(message: GetServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== undefined) {
      UpstreamServiceConfig.encode(message.service, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = UpstreamServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceResponse {
    return { service: isSet(object.service) ? UpstreamServiceConfig.fromJSON(object.service) : undefined };
  },

  toJSON(message: GetServiceResponse): unknown {
    const obj: any = {};
    if (message.service !== undefined) {
      obj.service = UpstreamServiceConfig.toJSON(message.service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceResponse>, I>>(base?: I): GetServiceResponse {
    return GetServiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceResponse>, I>>(object: I): GetServiceResponse {
    const message = createBaseGetServiceResponse();
    message.service = (object.service !== undefined && object.service !== null)
      ? UpstreamServiceConfig.fromPartial(object.service)
      : undefined;
    return message;
  },
};

function createBaseGetServiceStatusRequest(): GetServiceStatusRequest {
  return { serviceName: "", namespace: "" };
}

export const GetServiceStatusRequest: MessageFns<GetServiceStatusRequest> = {
  encode(message: GetServiceStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceStatusRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
    };
  },

  toJSON(message: GetServiceStatusRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceStatusRequest>, I>>(base?: I): GetServiceStatusRequest {
    return GetServiceStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceStatusRequest>, I>>(object: I): GetServiceStatusRequest {
    const message = createBaseGetServiceStatusRequest();
    message.serviceName = object.serviceName ?? "";
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseGetServiceStatusResponse(): GetServiceStatusResponse {
  return { tools: [], metrics: {} };
}

export const GetServiceStatusResponse: MessageFns<GetServiceStatusResponse> = {
  encode(message: GetServiceStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(10).fork()).join();
    }
    globalThis.Object.entries(message.metrics).forEach(([key, value]: [string, Long]) => {
      GetServiceStatusResponse_MetricsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetServiceStatusResponse_MetricsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metrics[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceStatusResponse {
    return {
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      metrics: isObject(object.metrics)
        ? (globalThis.Object.entries(object.metrics) as [string, any][]).reduce(
          (acc: { [key: string]: Long }, [key, value]: [string, any]) => {
            acc[key] = Long.fromValue(value as Long | string);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetServiceStatusResponse): unknown {
    const obj: any = {};
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.metrics) {
      const entries = globalThis.Object.entries(message.metrics) as [string, Long][];
      if (entries.length > 0) {
        obj.metrics = {};
        entries.forEach(([k, v]) => {
          obj.metrics[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceStatusResponse>, I>>(base?: I): GetServiceStatusResponse {
    return GetServiceStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceStatusResponse>, I>>(object: I): GetServiceStatusResponse {
    const message = createBaseGetServiceStatusResponse();
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.metrics = (globalThis.Object.entries(object.metrics ?? {}) as [string, Long][]).reduce(
      (acc: { [key: string]: Long }, [key, value]: [string, Long]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetServiceStatusResponse_MetricsEntry(): GetServiceStatusResponse_MetricsEntry {
  return { key: "", value: Long.ZERO };
}

export const GetServiceStatusResponse_MetricsEntry: MessageFns<GetServiceStatusResponse_MetricsEntry> = {
  encode(message: GetServiceStatusResponse_MetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServiceStatusResponse_MetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceStatusResponse_MetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceStatusResponse_MetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: GetServiceStatusResponse_MetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceStatusResponse_MetricsEntry>, I>>(
    base?: I,
  ): GetServiceStatusResponse_MetricsEntry {
    return GetServiceStatusResponse_MetricsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceStatusResponse_MetricsEntry>, I>>(
    object: I,
  ): GetServiceStatusResponse_MetricsEntry {
    const message = createBaseGetServiceStatusResponse_MetricsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

export interface RegistrationService {
  RegisterService(
    request: DeepPartial<RegisterServiceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<RegisterServiceResponse>;
  ValidateService(
    request: DeepPartial<ValidateServiceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ValidateServiceResponse>;
  UnregisterService(
    request: DeepPartial<UnregisterServiceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UnregisterServiceResponse>;
  InitiateOAuth2Flow(
    request: DeepPartial<InitiateOAuth2FlowRequest>,
    metadata?: grpc.Metadata,
  ): Promise<InitiateOAuth2FlowResponse>;
  RegisterTools(request: DeepPartial<RegisterToolsRequest>, metadata?: grpc.Metadata): Promise<RegisterToolsResponse>;
  GetServiceStatus(
    request: DeepPartial<GetServiceStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetServiceStatusResponse>;
  ListServices(request: DeepPartial<ListServicesRequest>, metadata?: grpc.Metadata): Promise<ListServicesResponse>;
  GetService(request: DeepPartial<GetServiceRequest>, metadata?: grpc.Metadata): Promise<GetServiceResponse>;
}

export class RegistrationServiceClientImpl implements RegistrationService {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.RegisterService = this.RegisterService.bind(this);
    this.ValidateService = this.ValidateService.bind(this);
    this.UnregisterService = this.UnregisterService.bind(this);
    this.InitiateOAuth2Flow = this.InitiateOAuth2Flow.bind(this);
    this.RegisterTools = this.RegisterTools.bind(this);
    this.GetServiceStatus = this.GetServiceStatus.bind(this);
    this.ListServices = this.ListServices.bind(this);
    this.GetService = this.GetService.bind(this);
  }

  RegisterService(
    request: DeepPartial<RegisterServiceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<RegisterServiceResponse> {
    return this.rpc.unary(
      RegistrationServiceRegisterServiceDesc,
      RegisterServiceRequest.fromPartial(request),
      metadata,
    );
  }

  ValidateService(
    request: DeepPartial<ValidateServiceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ValidateServiceResponse> {
    return this.rpc.unary(
      RegistrationServiceValidateServiceDesc,
      ValidateServiceRequest.fromPartial(request),
      metadata,
    );
  }

  UnregisterService(
    request: DeepPartial<UnregisterServiceRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UnregisterServiceResponse> {
    return this.rpc.unary(
      RegistrationServiceUnregisterServiceDesc,
      UnregisterServiceRequest.fromPartial(request),
      metadata,
    );
  }

  InitiateOAuth2Flow(
    request: DeepPartial<InitiateOAuth2FlowRequest>,
    metadata?: grpc.Metadata,
  ): Promise<InitiateOAuth2FlowResponse> {
    return this.rpc.unary(
      RegistrationServiceInitiateOAuth2FlowDesc,
      InitiateOAuth2FlowRequest.fromPartial(request),
      metadata,
    );
  }

  RegisterTools(request: DeepPartial<RegisterToolsRequest>, metadata?: grpc.Metadata): Promise<RegisterToolsResponse> {
    return this.rpc.unary(RegistrationServiceRegisterToolsDesc, RegisterToolsRequest.fromPartial(request), metadata);
  }

  GetServiceStatus(
    request: DeepPartial<GetServiceStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GetServiceStatusResponse> {
    return this.rpc.unary(
      RegistrationServiceGetServiceStatusDesc,
      GetServiceStatusRequest.fromPartial(request),
      metadata,
    );
  }

  ListServices(request: DeepPartial<ListServicesRequest>, metadata?: grpc.Metadata): Promise<ListServicesResponse> {
    return this.rpc.unary(RegistrationServiceListServicesDesc, ListServicesRequest.fromPartial(request), metadata);
  }

  GetService(request: DeepPartial<GetServiceRequest>, metadata?: grpc.Metadata): Promise<GetServiceResponse> {
    return this.rpc.unary(RegistrationServiceGetServiceDesc, GetServiceRequest.fromPartial(request), metadata);
  }
}

export const RegistrationServiceDesc = { serviceName: "mcpany.api.v1.RegistrationService" };

export const RegistrationServiceRegisterServiceDesc: UnaryMethodDefinitionish = {
  methodName: "RegisterService",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return RegisterServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = RegisterServiceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RegistrationServiceValidateServiceDesc: UnaryMethodDefinitionish = {
  methodName: "ValidateService",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ValidateServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ValidateServiceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RegistrationServiceUnregisterServiceDesc: UnaryMethodDefinitionish = {
  methodName: "UnregisterService",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnregisterServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UnregisterServiceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RegistrationServiceInitiateOAuth2FlowDesc: UnaryMethodDefinitionish = {
  methodName: "InitiateOAuth2Flow",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return InitiateOAuth2FlowRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = InitiateOAuth2FlowResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RegistrationServiceRegisterToolsDesc: UnaryMethodDefinitionish = {
  methodName: "RegisterTools",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return RegisterToolsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = RegisterToolsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RegistrationServiceGetServiceStatusDesc: UnaryMethodDefinitionish = {
  methodName: "GetServiceStatus",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetServiceStatusRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetServiceStatusResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RegistrationServiceListServicesDesc: UnaryMethodDefinitionish = {
  methodName: "ListServices",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListServicesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ListServicesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const RegistrationServiceGetServiceDesc: UnaryMethodDefinitionish = {
  methodName: "GetService",
  service: RegistrationServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetServiceRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetServiceResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
