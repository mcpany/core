// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.1
// source: proto/config/v1/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "mcpany.config.v1";

/**
 * SecretValue represents a value that should be treated as a secret.
 * It can be a plain text value, an environment variable, a file path, or content fetched from a remote URL.
 */
export interface SecretValue {
  plainText?: string | undefined;
  environmentVariable?: string | undefined;
  filePath?: string | undefined;
  remoteContent?: RemoteContent | undefined;
  vault?: VaultSecret | undefined;
  awsSecretManager?: AwsSecretManagerSecret | undefined;
}

/** AwsSecretManagerSecret defines the parameters for fetching a secret from AWS Secrets Manager. */
export interface AwsSecretManagerSecret {
  /** The name or ARN of the secret. */
  secretId: string;
  /** Optional: The key to extract from the secret JSON. */
  jsonKey: string;
  /** Optional: The version stage (defaults to AWSCURRENT). */
  versionStage: string;
  /** Optional: The version ID. */
  versionId: string;
  /** Optional: The region. If not set, uses environment or profile. */
  region: string;
  /** Optional: Profile to use. */
  profile: string;
}

/** VaultSecret defines the parameters for fetching a secret from HashiCorp Vault. */
export interface VaultSecret {
  /** The address of the Vault server (e.g., "https://vault.example.com"). */
  address: string;
  /** The token to authenticate with Vault. */
  token?:
    | SecretValue
    | undefined;
  /** The path to the secret in Vault (e.g., "secret/data/my-app/db"). */
  path: string;
  /** The key of the secret to retrieve from the path. */
  key: string;
}

/** RemoteContent represents content that is fetched from a remote URL. */
export interface RemoteContent {
  httpUrl: string;
  auth?: Authentication | undefined;
}

/** Authentication defines the authentication method to use when fetching remote content. */
export interface Authentication {
  apiKey?: UpstreamAPIKeyAuth | undefined;
  bearerToken?: UpstreamBearerTokenAuth | undefined;
  basicAuth?: UpstreamBasicAuth | undefined;
  oauth2?: UpstreamOAuth2Auth | undefined;
}

/**
 * UpstreamAuthentication defines the authentication method to use when mcpany communicates
 * with an upstream service.
 */
export interface UpstreamAuthentication {
  apiKey?: UpstreamAPIKeyAuth | undefined;
  bearerToken?: UpstreamBearerTokenAuth | undefined;
  basicAuth?: UpstreamBasicAuth | undefined;
  oauth2?: UpstreamOAuth2Auth | undefined;
  mtls?: UpstreamMTLSAuth | undefined;
  useEnvironmentVariable: boolean;
}

/** UpstreamAPIKeyAuth defines authentication using an API key sent to an upstream. */
export interface UpstreamAPIKeyAuth {
  /** The name of the header to carry the API key (e.g., "X-API-Key"). */
  headerName: string;
  /** The API key value. */
  apiKey?: SecretValue | undefined;
}

/** UpstreamBearerTokenAuth defines authentication using a bearer token. */
export interface UpstreamBearerTokenAuth {
  /** The bearer token. */
  token?: SecretValue | undefined;
}

/** UpstreamBasicAuth defines authentication using a username and password. */
export interface UpstreamBasicAuth {
  username: string;
  password?: SecretValue | undefined;
}

/** UpstreamOAuth2Auth defines authentication using the OAuth 2.0 client credentials flow. */
export interface UpstreamOAuth2Auth {
  tokenUrl: string;
  clientId?: SecretValue | undefined;
  clientSecret?: SecretValue | undefined;
  scopes: string;
}

/** UpstreamMTLSAuth defines authentication using mutual TLS. */
export interface UpstreamMTLSAuth {
  /** Path to the client certificate file. */
  clientCertPath: string;
  /** Path to the client private key file. */
  clientKeyPath: string;
  /** Path to the CA certificate file for verifying the server's certificate. */
  caCertPath: string;
}

/** AuthenticationConfig specifies the authentication method to use. */
export interface AuthenticationConfig {
  apiKey?: APIKeyAuth | undefined;
  oauth2?: OAuth2Auth | undefined;
  basicAuth?: BasicAuth | undefined;
  oidc?: OIDCAuth | undefined;
  trustedHeader?: TrustedHeaderAuth | undefined;
}

/**
 * BasicAuth defines authentication using a username and password.
 * The password should be stored as a bcrypt hash.
 */
export interface BasicAuth {
  passwordHash: string;
}

/** OIDCAuth defines authentication using OpenID Connect. */
export interface OIDCAuth {
  issuer: string;
  subject: string;
  email: string;
  audience: string[];
}

/** TrustedHeaderAuth defines authentication using a trusted header (e.g. from an auth proxy). */
export interface TrustedHeaderAuth {
  headerName: string;
  headerValue: string;
}

/** APIKeyAuth defines authentication using an API key. */
export interface APIKeyAuth {
  /** The name of the parameter carrying the key (e.g., "X-API-Key", "api_key"). */
  paramName: string;
  in: APIKeyAuth_Location;
  /** The actual API key value. It's recommended to use a secret management system. */
  keyValue: string;
}

/** Where the API key is located. */
export enum APIKeyAuth_Location {
  HEADER = 0,
  QUERY = 1,
  UNRECOGNIZED = -1,
}

export function aPIKeyAuth_LocationFromJSON(object: any): APIKeyAuth_Location {
  switch (object) {
    case 0:
    case "HEADER":
      return APIKeyAuth_Location.HEADER;
    case 1:
    case "QUERY":
      return APIKeyAuth_Location.QUERY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return APIKeyAuth_Location.UNRECOGNIZED;
  }
}

export function aPIKeyAuth_LocationToJSON(object: APIKeyAuth_Location): string {
  switch (object) {
    case APIKeyAuth_Location.HEADER:
      return "HEADER";
    case APIKeyAuth_Location.QUERY:
      return "QUERY";
    case APIKeyAuth_Location.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** OAuth2Auth defines authentication using the OAuth 2.0 client credentials flow. */
export interface OAuth2Auth {
  tokenUrl: string;
  authorizationUrl: string;
  /** Space-delimited list of scopes. */
  scopes: string;
  issuerUrl: string;
  audience: string;
}

function createBaseSecretValue(): SecretValue {
  return {
    plainText: undefined,
    environmentVariable: undefined,
    filePath: undefined,
    remoteContent: undefined,
    vault: undefined,
    awsSecretManager: undefined,
  };
}

export const SecretValue: MessageFns<SecretValue> = {
  encode(message: SecretValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plainText !== undefined) {
      writer.uint32(10).string(message.plainText);
    }
    if (message.environmentVariable !== undefined) {
      writer.uint32(18).string(message.environmentVariable);
    }
    if (message.filePath !== undefined) {
      writer.uint32(26).string(message.filePath);
    }
    if (message.remoteContent !== undefined) {
      RemoteContent.encode(message.remoteContent, writer.uint32(34).fork()).join();
    }
    if (message.vault !== undefined) {
      VaultSecret.encode(message.vault, writer.uint32(42).fork()).join();
    }
    if (message.awsSecretManager !== undefined) {
      AwsSecretManagerSecret.encode(message.awsSecretManager, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plainText = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentVariable = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remoteContent = RemoteContent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.vault = VaultSecret.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.awsSecretManager = AwsSecretManagerSecret.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretValue {
    return {
      plainText: isSet(object.plainText) ? globalThis.String(object.plainText) : undefined,
      environmentVariable: isSet(object.environmentVariable)
        ? globalThis.String(object.environmentVariable)
        : undefined,
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : undefined,
      remoteContent: isSet(object.remoteContent) ? RemoteContent.fromJSON(object.remoteContent) : undefined,
      vault: isSet(object.vault) ? VaultSecret.fromJSON(object.vault) : undefined,
      awsSecretManager: isSet(object.awsSecretManager)
        ? AwsSecretManagerSecret.fromJSON(object.awsSecretManager)
        : undefined,
    };
  },

  toJSON(message: SecretValue): unknown {
    const obj: any = {};
    if (message.plainText !== undefined) {
      obj.plainText = message.plainText;
    }
    if (message.environmentVariable !== undefined) {
      obj.environmentVariable = message.environmentVariable;
    }
    if (message.filePath !== undefined) {
      obj.filePath = message.filePath;
    }
    if (message.remoteContent !== undefined) {
      obj.remoteContent = RemoteContent.toJSON(message.remoteContent);
    }
    if (message.vault !== undefined) {
      obj.vault = VaultSecret.toJSON(message.vault);
    }
    if (message.awsSecretManager !== undefined) {
      obj.awsSecretManager = AwsSecretManagerSecret.toJSON(message.awsSecretManager);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretValue>, I>>(base?: I): SecretValue {
    return SecretValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretValue>, I>>(object: I): SecretValue {
    const message = createBaseSecretValue();
    message.plainText = object.plainText ?? undefined;
    message.environmentVariable = object.environmentVariable ?? undefined;
    message.filePath = object.filePath ?? undefined;
    message.remoteContent = (object.remoteContent !== undefined && object.remoteContent !== null)
      ? RemoteContent.fromPartial(object.remoteContent)
      : undefined;
    message.vault = (object.vault !== undefined && object.vault !== null)
      ? VaultSecret.fromPartial(object.vault)
      : undefined;
    message.awsSecretManager = (object.awsSecretManager !== undefined && object.awsSecretManager !== null)
      ? AwsSecretManagerSecret.fromPartial(object.awsSecretManager)
      : undefined;
    return message;
  },
};

function createBaseAwsSecretManagerSecret(): AwsSecretManagerSecret {
  return { secretId: "", jsonKey: "", versionStage: "", versionId: "", region: "", profile: "" };
}

export const AwsSecretManagerSecret: MessageFns<AwsSecretManagerSecret> = {
  encode(message: AwsSecretManagerSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretId !== "") {
      writer.uint32(10).string(message.secretId);
    }
    if (message.jsonKey !== "") {
      writer.uint32(18).string(message.jsonKey);
    }
    if (message.versionStage !== "") {
      writer.uint32(26).string(message.versionStage);
    }
    if (message.versionId !== "") {
      writer.uint32(34).string(message.versionId);
    }
    if (message.region !== "") {
      writer.uint32(42).string(message.region);
    }
    if (message.profile !== "") {
      writer.uint32(50).string(message.profile);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSecretManagerSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSecretManagerSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secretId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jsonKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionStage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.profile = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSecretManagerSecret {
    return {
      secretId: isSet(object.secret_id) ? globalThis.String(object.secret_id) : "",
      jsonKey: isSet(object.json_key) ? globalThis.String(object.json_key) : "",
      versionStage: isSet(object.version_stage) ? globalThis.String(object.version_stage) : "",
      versionId: isSet(object.version_id) ? globalThis.String(object.version_id) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
    };
  },

  toJSON(message: AwsSecretManagerSecret): unknown {
    const obj: any = {};
    if (message.secretId !== "") {
      obj.secret_id = message.secretId;
    }
    if (message.jsonKey !== "") {
      obj.json_key = message.jsonKey;
    }
    if (message.versionStage !== "") {
      obj.version_stage = message.versionStage;
    }
    if (message.versionId !== "") {
      obj.version_id = message.versionId;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.profile !== "") {
      obj.profile = message.profile;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AwsSecretManagerSecret>, I>>(base?: I): AwsSecretManagerSecret {
    return AwsSecretManagerSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AwsSecretManagerSecret>, I>>(object: I): AwsSecretManagerSecret {
    const message = createBaseAwsSecretManagerSecret();
    message.secretId = object.secretId ?? "";
    message.jsonKey = object.jsonKey ?? "";
    message.versionStage = object.versionStage ?? "";
    message.versionId = object.versionId ?? "";
    message.region = object.region ?? "";
    message.profile = object.profile ?? "";
    return message;
  },
};

function createBaseVaultSecret(): VaultSecret {
  return { address: "", token: undefined, path: "", key: "" };
}

export const VaultSecret: MessageFns<VaultSecret> = {
  encode(message: VaultSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.token !== undefined) {
      SecretValue.encode(message.token, writer.uint32(18).fork()).join();
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.key !== "") {
      writer.uint32(34).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VaultSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVaultSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VaultSecret {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      token: isSet(object.token) ? SecretValue.fromJSON(object.token) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: VaultSecret): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.token !== undefined) {
      obj.token = SecretValue.toJSON(message.token);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VaultSecret>, I>>(base?: I): VaultSecret {
    return VaultSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VaultSecret>, I>>(object: I): VaultSecret {
    const message = createBaseVaultSecret();
    message.address = object.address ?? "";
    message.token = (object.token !== undefined && object.token !== null)
      ? SecretValue.fromPartial(object.token)
      : undefined;
    message.path = object.path ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseRemoteContent(): RemoteContent {
  return { httpUrl: "", auth: undefined };
}

export const RemoteContent: MessageFns<RemoteContent> = {
  encode(message: RemoteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpUrl !== "") {
      writer.uint32(10).string(message.httpUrl);
    }
    if (message.auth !== undefined) {
      Authentication.encode(message.auth, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.httpUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.auth = Authentication.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteContent {
    return {
      httpUrl: isSet(object.httpUrl) ? globalThis.String(object.httpUrl) : "",
      auth: isSet(object.auth) ? Authentication.fromJSON(object.auth) : undefined,
    };
  },

  toJSON(message: RemoteContent): unknown {
    const obj: any = {};
    if (message.httpUrl !== "") {
      obj.httpUrl = message.httpUrl;
    }
    if (message.auth !== undefined) {
      obj.auth = Authentication.toJSON(message.auth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoteContent>, I>>(base?: I): RemoteContent {
    return RemoteContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoteContent>, I>>(object: I): RemoteContent {
    const message = createBaseRemoteContent();
    message.httpUrl = object.httpUrl ?? "";
    message.auth = (object.auth !== undefined && object.auth !== null)
      ? Authentication.fromPartial(object.auth)
      : undefined;
    return message;
  },
};

function createBaseAuthentication(): Authentication {
  return { apiKey: undefined, bearerToken: undefined, basicAuth: undefined, oauth2: undefined };
}

export const Authentication: MessageFns<Authentication> = {
  encode(message: Authentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== undefined) {
      UpstreamAPIKeyAuth.encode(message.apiKey, writer.uint32(10).fork()).join();
    }
    if (message.bearerToken !== undefined) {
      UpstreamBearerTokenAuth.encode(message.bearerToken, writer.uint32(18).fork()).join();
    }
    if (message.basicAuth !== undefined) {
      UpstreamBasicAuth.encode(message.basicAuth, writer.uint32(26).fork()).join();
    }
    if (message.oauth2 !== undefined) {
      UpstreamOAuth2Auth.encode(message.oauth2, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = UpstreamAPIKeyAuth.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bearerToken = UpstreamBearerTokenAuth.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.basicAuth = UpstreamBasicAuth.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.oauth2 = UpstreamOAuth2Auth.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authentication {
    return {
      apiKey: isSet(object.apiKey) ? UpstreamAPIKeyAuth.fromJSON(object.apiKey) : undefined,
      bearerToken: isSet(object.bearerToken) ? UpstreamBearerTokenAuth.fromJSON(object.bearerToken) : undefined,
      basicAuth: isSet(object.basicAuth) ? UpstreamBasicAuth.fromJSON(object.basicAuth) : undefined,
      oauth2: isSet(object.oauth2) ? UpstreamOAuth2Auth.fromJSON(object.oauth2) : undefined,
    };
  },

  toJSON(message: Authentication): unknown {
    const obj: any = {};
    if (message.apiKey !== undefined) {
      obj.apiKey = UpstreamAPIKeyAuth.toJSON(message.apiKey);
    }
    if (message.bearerToken !== undefined) {
      obj.bearerToken = UpstreamBearerTokenAuth.toJSON(message.bearerToken);
    }
    if (message.basicAuth !== undefined) {
      obj.basicAuth = UpstreamBasicAuth.toJSON(message.basicAuth);
    }
    if (message.oauth2 !== undefined) {
      obj.oauth2 = UpstreamOAuth2Auth.toJSON(message.oauth2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Authentication>, I>>(base?: I): Authentication {
    return Authentication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Authentication>, I>>(object: I): Authentication {
    const message = createBaseAuthentication();
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? UpstreamAPIKeyAuth.fromPartial(object.apiKey)
      : undefined;
    message.bearerToken = (object.bearerToken !== undefined && object.bearerToken !== null)
      ? UpstreamBearerTokenAuth.fromPartial(object.bearerToken)
      : undefined;
    message.basicAuth = (object.basicAuth !== undefined && object.basicAuth !== null)
      ? UpstreamBasicAuth.fromPartial(object.basicAuth)
      : undefined;
    message.oauth2 = (object.oauth2 !== undefined && object.oauth2 !== null)
      ? UpstreamOAuth2Auth.fromPartial(object.oauth2)
      : undefined;
    return message;
  },
};

function createBaseUpstreamAuthentication(): UpstreamAuthentication {
  return {
    apiKey: undefined,
    bearerToken: undefined,
    basicAuth: undefined,
    oauth2: undefined,
    mtls: undefined,
    useEnvironmentVariable: false,
  };
}

export const UpstreamAuthentication: MessageFns<UpstreamAuthentication> = {
  encode(message: UpstreamAuthentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== undefined) {
      UpstreamAPIKeyAuth.encode(message.apiKey, writer.uint32(10).fork()).join();
    }
    if (message.bearerToken !== undefined) {
      UpstreamBearerTokenAuth.encode(message.bearerToken, writer.uint32(18).fork()).join();
    }
    if (message.basicAuth !== undefined) {
      UpstreamBasicAuth.encode(message.basicAuth, writer.uint32(26).fork()).join();
    }
    if (message.oauth2 !== undefined) {
      UpstreamOAuth2Auth.encode(message.oauth2, writer.uint32(42).fork()).join();
    }
    if (message.mtls !== undefined) {
      UpstreamMTLSAuth.encode(message.mtls, writer.uint32(50).fork()).join();
    }
    if (message.useEnvironmentVariable !== false) {
      writer.uint32(32).bool(message.useEnvironmentVariable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamAuthentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = UpstreamAPIKeyAuth.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bearerToken = UpstreamBearerTokenAuth.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.basicAuth = UpstreamBasicAuth.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.oauth2 = UpstreamOAuth2Auth.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mtls = UpstreamMTLSAuth.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.useEnvironmentVariable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamAuthentication {
    return {
      apiKey: isSet(object.apiKey) ? UpstreamAPIKeyAuth.fromJSON(object.apiKey) : undefined,
      bearerToken: isSet(object.bearerToken) ? UpstreamBearerTokenAuth.fromJSON(object.bearerToken) : undefined,
      basicAuth: isSet(object.basicAuth) ? UpstreamBasicAuth.fromJSON(object.basicAuth) : undefined,
      oauth2: isSet(object.oauth2) ? UpstreamOAuth2Auth.fromJSON(object.oauth2) : undefined,
      mtls: isSet(object.mtls) ? UpstreamMTLSAuth.fromJSON(object.mtls) : undefined,
      useEnvironmentVariable: isSet(object.useEnvironmentVariable)
        ? globalThis.Boolean(object.useEnvironmentVariable)
        : false,
    };
  },

  toJSON(message: UpstreamAuthentication): unknown {
    const obj: any = {};
    if (message.apiKey !== undefined) {
      obj.apiKey = UpstreamAPIKeyAuth.toJSON(message.apiKey);
    }
    if (message.bearerToken !== undefined) {
      obj.bearerToken = UpstreamBearerTokenAuth.toJSON(message.bearerToken);
    }
    if (message.basicAuth !== undefined) {
      obj.basicAuth = UpstreamBasicAuth.toJSON(message.basicAuth);
    }
    if (message.oauth2 !== undefined) {
      obj.oauth2 = UpstreamOAuth2Auth.toJSON(message.oauth2);
    }
    if (message.mtls !== undefined) {
      obj.mtls = UpstreamMTLSAuth.toJSON(message.mtls);
    }
    if (message.useEnvironmentVariable !== false) {
      obj.useEnvironmentVariable = message.useEnvironmentVariable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamAuthentication>, I>>(base?: I): UpstreamAuthentication {
    return UpstreamAuthentication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamAuthentication>, I>>(object: I): UpstreamAuthentication {
    const message = createBaseUpstreamAuthentication();
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? UpstreamAPIKeyAuth.fromPartial(object.apiKey)
      : undefined;
    message.bearerToken = (object.bearerToken !== undefined && object.bearerToken !== null)
      ? UpstreamBearerTokenAuth.fromPartial(object.bearerToken)
      : undefined;
    message.basicAuth = (object.basicAuth !== undefined && object.basicAuth !== null)
      ? UpstreamBasicAuth.fromPartial(object.basicAuth)
      : undefined;
    message.oauth2 = (object.oauth2 !== undefined && object.oauth2 !== null)
      ? UpstreamOAuth2Auth.fromPartial(object.oauth2)
      : undefined;
    message.mtls = (object.mtls !== undefined && object.mtls !== null)
      ? UpstreamMTLSAuth.fromPartial(object.mtls)
      : undefined;
    message.useEnvironmentVariable = object.useEnvironmentVariable ?? false;
    return message;
  },
};

function createBaseUpstreamAPIKeyAuth(): UpstreamAPIKeyAuth {
  return { headerName: "", apiKey: undefined };
}

export const UpstreamAPIKeyAuth: MessageFns<UpstreamAPIKeyAuth> = {
  encode(message: UpstreamAPIKeyAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headerName !== "") {
      writer.uint32(10).string(message.headerName);
    }
    if (message.apiKey !== undefined) {
      SecretValue.encode(message.apiKey, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamAPIKeyAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamAPIKeyAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apiKey = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamAPIKeyAuth {
    return {
      headerName: isSet(object.headerName) ? globalThis.String(object.headerName) : "",
      apiKey: isSet(object.apiKey) ? SecretValue.fromJSON(object.apiKey) : undefined,
    };
  },

  toJSON(message: UpstreamAPIKeyAuth): unknown {
    const obj: any = {};
    if (message.headerName !== "") {
      obj.headerName = message.headerName;
    }
    if (message.apiKey !== undefined) {
      obj.apiKey = SecretValue.toJSON(message.apiKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamAPIKeyAuth>, I>>(base?: I): UpstreamAPIKeyAuth {
    return UpstreamAPIKeyAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamAPIKeyAuth>, I>>(object: I): UpstreamAPIKeyAuth {
    const message = createBaseUpstreamAPIKeyAuth();
    message.headerName = object.headerName ?? "";
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? SecretValue.fromPartial(object.apiKey)
      : undefined;
    return message;
  },
};

function createBaseUpstreamBearerTokenAuth(): UpstreamBearerTokenAuth {
  return { token: undefined };
}

export const UpstreamBearerTokenAuth: MessageFns<UpstreamBearerTokenAuth> = {
  encode(message: UpstreamBearerTokenAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== undefined) {
      SecretValue.encode(message.token, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamBearerTokenAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamBearerTokenAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamBearerTokenAuth {
    return { token: isSet(object.token) ? SecretValue.fromJSON(object.token) : undefined };
  },

  toJSON(message: UpstreamBearerTokenAuth): unknown {
    const obj: any = {};
    if (message.token !== undefined) {
      obj.token = SecretValue.toJSON(message.token);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamBearerTokenAuth>, I>>(base?: I): UpstreamBearerTokenAuth {
    return UpstreamBearerTokenAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamBearerTokenAuth>, I>>(object: I): UpstreamBearerTokenAuth {
    const message = createBaseUpstreamBearerTokenAuth();
    message.token = (object.token !== undefined && object.token !== null)
      ? SecretValue.fromPartial(object.token)
      : undefined;
    return message;
  },
};

function createBaseUpstreamBasicAuth(): UpstreamBasicAuth {
  return { username: "", password: undefined };
}

export const UpstreamBasicAuth: MessageFns<UpstreamBasicAuth> = {
  encode(message: UpstreamBasicAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== undefined) {
      SecretValue.encode(message.password, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamBasicAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamBasicAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamBasicAuth {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? SecretValue.fromJSON(object.password) : undefined,
    };
  },

  toJSON(message: UpstreamBasicAuth): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== undefined) {
      obj.password = SecretValue.toJSON(message.password);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamBasicAuth>, I>>(base?: I): UpstreamBasicAuth {
    return UpstreamBasicAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamBasicAuth>, I>>(object: I): UpstreamBasicAuth {
    const message = createBaseUpstreamBasicAuth();
    message.username = object.username ?? "";
    message.password = (object.password !== undefined && object.password !== null)
      ? SecretValue.fromPartial(object.password)
      : undefined;
    return message;
  },
};

function createBaseUpstreamOAuth2Auth(): UpstreamOAuth2Auth {
  return { tokenUrl: "", clientId: undefined, clientSecret: undefined, scopes: "" };
}

export const UpstreamOAuth2Auth: MessageFns<UpstreamOAuth2Auth> = {
  encode(message: UpstreamOAuth2Auth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenUrl !== "") {
      writer.uint32(10).string(message.tokenUrl);
    }
    if (message.clientId !== undefined) {
      SecretValue.encode(message.clientId, writer.uint32(18).fork()).join();
    }
    if (message.clientSecret !== undefined) {
      SecretValue.encode(message.clientSecret, writer.uint32(26).fork()).join();
    }
    if (message.scopes !== "") {
      writer.uint32(34).string(message.scopes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamOAuth2Auth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamOAuth2Auth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientSecret = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scopes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamOAuth2Auth {
    return {
      tokenUrl: isSet(object.tokenUrl) ? globalThis.String(object.tokenUrl) : "",
      clientId: isSet(object.clientId) ? SecretValue.fromJSON(object.clientId) : undefined,
      clientSecret: isSet(object.clientSecret) ? SecretValue.fromJSON(object.clientSecret) : undefined,
      scopes: isSet(object.scopes) ? globalThis.String(object.scopes) : "",
    };
  },

  toJSON(message: UpstreamOAuth2Auth): unknown {
    const obj: any = {};
    if (message.tokenUrl !== "") {
      obj.tokenUrl = message.tokenUrl;
    }
    if (message.clientId !== undefined) {
      obj.clientId = SecretValue.toJSON(message.clientId);
    }
    if (message.clientSecret !== undefined) {
      obj.clientSecret = SecretValue.toJSON(message.clientSecret);
    }
    if (message.scopes !== "") {
      obj.scopes = message.scopes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamOAuth2Auth>, I>>(base?: I): UpstreamOAuth2Auth {
    return UpstreamOAuth2Auth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamOAuth2Auth>, I>>(object: I): UpstreamOAuth2Auth {
    const message = createBaseUpstreamOAuth2Auth();
    message.tokenUrl = object.tokenUrl ?? "";
    message.clientId = (object.clientId !== undefined && object.clientId !== null)
      ? SecretValue.fromPartial(object.clientId)
      : undefined;
    message.clientSecret = (object.clientSecret !== undefined && object.clientSecret !== null)
      ? SecretValue.fromPartial(object.clientSecret)
      : undefined;
    message.scopes = object.scopes ?? "";
    return message;
  },
};

function createBaseUpstreamMTLSAuth(): UpstreamMTLSAuth {
  return { clientCertPath: "", clientKeyPath: "", caCertPath: "" };
}

export const UpstreamMTLSAuth: MessageFns<UpstreamMTLSAuth> = {
  encode(message: UpstreamMTLSAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientCertPath !== "") {
      writer.uint32(10).string(message.clientCertPath);
    }
    if (message.clientKeyPath !== "") {
      writer.uint32(18).string(message.clientKeyPath);
    }
    if (message.caCertPath !== "") {
      writer.uint32(26).string(message.caCertPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamMTLSAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamMTLSAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientCertPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientKeyPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.caCertPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamMTLSAuth {
    return {
      clientCertPath: isSet(object.clientCertPath) ? globalThis.String(object.clientCertPath) : "",
      clientKeyPath: isSet(object.clientKeyPath) ? globalThis.String(object.clientKeyPath) : "",
      caCertPath: isSet(object.caCertPath) ? globalThis.String(object.caCertPath) : "",
    };
  },

  toJSON(message: UpstreamMTLSAuth): unknown {
    const obj: any = {};
    if (message.clientCertPath !== "") {
      obj.clientCertPath = message.clientCertPath;
    }
    if (message.clientKeyPath !== "") {
      obj.clientKeyPath = message.clientKeyPath;
    }
    if (message.caCertPath !== "") {
      obj.caCertPath = message.caCertPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamMTLSAuth>, I>>(base?: I): UpstreamMTLSAuth {
    return UpstreamMTLSAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamMTLSAuth>, I>>(object: I): UpstreamMTLSAuth {
    const message = createBaseUpstreamMTLSAuth();
    message.clientCertPath = object.clientCertPath ?? "";
    message.clientKeyPath = object.clientKeyPath ?? "";
    message.caCertPath = object.caCertPath ?? "";
    return message;
  },
};

function createBaseAuthenticationConfig(): AuthenticationConfig {
  return { apiKey: undefined, oauth2: undefined, basicAuth: undefined, oidc: undefined, trustedHeader: undefined };
}

export const AuthenticationConfig: MessageFns<AuthenticationConfig> = {
  encode(message: AuthenticationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== undefined) {
      APIKeyAuth.encode(message.apiKey, writer.uint32(10).fork()).join();
    }
    if (message.oauth2 !== undefined) {
      OAuth2Auth.encode(message.oauth2, writer.uint32(18).fork()).join();
    }
    if (message.basicAuth !== undefined) {
      BasicAuth.encode(message.basicAuth, writer.uint32(26).fork()).join();
    }
    if (message.oidc !== undefined) {
      OIDCAuth.encode(message.oidc, writer.uint32(34).fork()).join();
    }
    if (message.trustedHeader !== undefined) {
      TrustedHeaderAuth.encode(message.trustedHeader, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = APIKeyAuth.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oauth2 = OAuth2Auth.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.basicAuth = BasicAuth.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oidc = OIDCAuth.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.trustedHeader = TrustedHeaderAuth.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationConfig {
    return {
      apiKey: isSet(object.api_key) ? APIKeyAuth.fromJSON(object.api_key) : undefined,
      oauth2: isSet(object.oauth2) ? OAuth2Auth.fromJSON(object.oauth2) : undefined,
      basicAuth: isSet(object.basic_auth) ? BasicAuth.fromJSON(object.basic_auth) : undefined,
      oidc: isSet(object.oidc) ? OIDCAuth.fromJSON(object.oidc) : undefined,
      trustedHeader: isSet(object.trusted_header) ? TrustedHeaderAuth.fromJSON(object.trusted_header) : undefined,
    };
  },

  toJSON(message: AuthenticationConfig): unknown {
    const obj: any = {};
    if (message.apiKey !== undefined) {
      obj.api_key = APIKeyAuth.toJSON(message.apiKey);
    }
    if (message.oauth2 !== undefined) {
      obj.oauth2 = OAuth2Auth.toJSON(message.oauth2);
    }
    if (message.basicAuth !== undefined) {
      obj.basic_auth = BasicAuth.toJSON(message.basicAuth);
    }
    if (message.oidc !== undefined) {
      obj.oidc = OIDCAuth.toJSON(message.oidc);
    }
    if (message.trustedHeader !== undefined) {
      obj.trusted_header = TrustedHeaderAuth.toJSON(message.trustedHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticationConfig>, I>>(base?: I): AuthenticationConfig {
    return AuthenticationConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticationConfig>, I>>(object: I): AuthenticationConfig {
    const message = createBaseAuthenticationConfig();
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? APIKeyAuth.fromPartial(object.apiKey)
      : undefined;
    message.oauth2 = (object.oauth2 !== undefined && object.oauth2 !== null)
      ? OAuth2Auth.fromPartial(object.oauth2)
      : undefined;
    message.basicAuth = (object.basicAuth !== undefined && object.basicAuth !== null)
      ? BasicAuth.fromPartial(object.basicAuth)
      : undefined;
    message.oidc = (object.oidc !== undefined && object.oidc !== null) ? OIDCAuth.fromPartial(object.oidc) : undefined;
    message.trustedHeader = (object.trustedHeader !== undefined && object.trustedHeader !== null)
      ? TrustedHeaderAuth.fromPartial(object.trustedHeader)
      : undefined;
    return message;
  },
};

function createBaseBasicAuth(): BasicAuth {
  return { passwordHash: "" };
}

export const BasicAuth: MessageFns<BasicAuth> = {
  encode(message: BasicAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.passwordHash !== "") {
      writer.uint32(10).string(message.passwordHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.passwordHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicAuth {
    return { passwordHash: isSet(object.password_hash) ? globalThis.String(object.password_hash) : "" };
  },

  toJSON(message: BasicAuth): unknown {
    const obj: any = {};
    if (message.passwordHash !== "") {
      obj.password_hash = message.passwordHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicAuth>, I>>(base?: I): BasicAuth {
    return BasicAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicAuth>, I>>(object: I): BasicAuth {
    const message = createBaseBasicAuth();
    message.passwordHash = object.passwordHash ?? "";
    return message;
  },
};

function createBaseOIDCAuth(): OIDCAuth {
  return { issuer: "", subject: "", email: "", audience: [] };
}

export const OIDCAuth: MessageFns<OIDCAuth> = {
  encode(message: OIDCAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    for (const v of message.audience) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OIDCAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOIDCAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.audience.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OIDCAuth {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      audience: globalThis.Array.isArray(object?.audience) ? object.audience.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: OIDCAuth): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.audience?.length) {
      obj.audience = message.audience;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OIDCAuth>, I>>(base?: I): OIDCAuth {
    return OIDCAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OIDCAuth>, I>>(object: I): OIDCAuth {
    const message = createBaseOIDCAuth();
    message.issuer = object.issuer ?? "";
    message.subject = object.subject ?? "";
    message.email = object.email ?? "";
    message.audience = object.audience?.map((e) => e) || [];
    return message;
  },
};

function createBaseTrustedHeaderAuth(): TrustedHeaderAuth {
  return { headerName: "", headerValue: "" };
}

export const TrustedHeaderAuth: MessageFns<TrustedHeaderAuth> = {
  encode(message: TrustedHeaderAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headerName !== "") {
      writer.uint32(10).string(message.headerName);
    }
    if (message.headerValue !== "") {
      writer.uint32(18).string(message.headerValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrustedHeaderAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrustedHeaderAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headerValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrustedHeaderAuth {
    return {
      headerName: isSet(object.header_name) ? globalThis.String(object.header_name) : "",
      headerValue: isSet(object.header_value) ? globalThis.String(object.header_value) : "",
    };
  },

  toJSON(message: TrustedHeaderAuth): unknown {
    const obj: any = {};
    if (message.headerName !== "") {
      obj.header_name = message.headerName;
    }
    if (message.headerValue !== "") {
      obj.header_value = message.headerValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrustedHeaderAuth>, I>>(base?: I): TrustedHeaderAuth {
    return TrustedHeaderAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrustedHeaderAuth>, I>>(object: I): TrustedHeaderAuth {
    const message = createBaseTrustedHeaderAuth();
    message.headerName = object.headerName ?? "";
    message.headerValue = object.headerValue ?? "";
    return message;
  },
};

function createBaseAPIKeyAuth(): APIKeyAuth {
  return { paramName: "", in: 0, keyValue: "" };
}

export const APIKeyAuth: MessageFns<APIKeyAuth> = {
  encode(message: APIKeyAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paramName !== "") {
      writer.uint32(10).string(message.paramName);
    }
    if (message.in !== 0) {
      writer.uint32(16).int32(message.in);
    }
    if (message.keyValue !== "") {
      writer.uint32(26).string(message.keyValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): APIKeyAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAPIKeyAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paramName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.in = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keyValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): APIKeyAuth {
    return {
      paramName: isSet(object.param_name) ? globalThis.String(object.param_name) : "",
      in: isSet(object.in) ? aPIKeyAuth_LocationFromJSON(object.in) : 0,
      keyValue: isSet(object.key_value) ? globalThis.String(object.key_value) : "",
    };
  },

  toJSON(message: APIKeyAuth): unknown {
    const obj: any = {};
    if (message.paramName !== "") {
      obj.param_name = message.paramName;
    }
    if (message.in !== 0) {
      obj.in = aPIKeyAuth_LocationToJSON(message.in);
    }
    if (message.keyValue !== "") {
      obj.key_value = message.keyValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<APIKeyAuth>, I>>(base?: I): APIKeyAuth {
    return APIKeyAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<APIKeyAuth>, I>>(object: I): APIKeyAuth {
    const message = createBaseAPIKeyAuth();
    message.paramName = object.paramName ?? "";
    message.in = object.in ?? 0;
    message.keyValue = object.keyValue ?? "";
    return message;
  },
};

function createBaseOAuth2Auth(): OAuth2Auth {
  return { tokenUrl: "", authorizationUrl: "", scopes: "", issuerUrl: "", audience: "" };
}

export const OAuth2Auth: MessageFns<OAuth2Auth> = {
  encode(message: OAuth2Auth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenUrl !== "") {
      writer.uint32(26).string(message.tokenUrl);
    }
    if (message.authorizationUrl !== "") {
      writer.uint32(34).string(message.authorizationUrl);
    }
    if (message.scopes !== "") {
      writer.uint32(42).string(message.scopes);
    }
    if (message.issuerUrl !== "") {
      writer.uint32(50).string(message.issuerUrl);
    }
    if (message.audience !== "") {
      writer.uint32(58).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2Auth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2Auth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scopes = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.issuerUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.audience = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2Auth {
    return {
      tokenUrl: isSet(object.tokenUrl) ? globalThis.String(object.tokenUrl) : "",
      authorizationUrl: isSet(object.authorizationUrl) ? globalThis.String(object.authorizationUrl) : "",
      scopes: isSet(object.scopes) ? globalThis.String(object.scopes) : "",
      issuerUrl: isSet(object.issuerUrl) ? globalThis.String(object.issuerUrl) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: OAuth2Auth): unknown {
    const obj: any = {};
    if (message.tokenUrl !== "") {
      obj.tokenUrl = message.tokenUrl;
    }
    if (message.authorizationUrl !== "") {
      obj.authorizationUrl = message.authorizationUrl;
    }
    if (message.scopes !== "") {
      obj.scopes = message.scopes;
    }
    if (message.issuerUrl !== "") {
      obj.issuerUrl = message.issuerUrl;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2Auth>, I>>(base?: I): OAuth2Auth {
    return OAuth2Auth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2Auth>, I>>(object: I): OAuth2Auth {
    const message = createBaseOAuth2Auth();
    message.tokenUrl = object.tokenUrl ?? "";
    message.authorizationUrl = object.authorizationUrl ?? "";
    message.scopes = object.scopes ?? "";
    message.issuerUrl = object.issuerUrl ?? "";
    message.audience = object.audience ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
