// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: proto/config/v1/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "mcpany.config.v1";

/**
 * SecretValue represents a value that should be treated as a secret.
 * It can be a plain text value, an environment variable, a file path, or content fetched from a remote URL.
 */
export interface SecretValue {
  plainText?: string | undefined;
  environmentVariable?: string | undefined;
  filePath?: string | undefined;
  remoteContent?: RemoteContent | undefined;
  vault?: VaultSecret | undefined;
  awsSecretManager?:
    | AwsSecretManagerSecret
    | undefined;
  /** Optional: A regex to validate the resolved secret value. */
  validationRegex: string;
}

/** AwsSecretManagerSecret defines the parameters for fetching a secret from AWS Secrets Manager. */
export interface AwsSecretManagerSecret {
  /** The name or ARN of the secret. */
  secretId: string;
  /** Optional: The key to extract from the secret JSON. */
  jsonKey: string;
  /** Optional: The version stage (defaults to AWSCURRENT). */
  versionStage: string;
  /** Optional: The version ID. */
  versionId: string;
  /** Optional: The region. If not set, uses environment or profile. */
  region: string;
  /** Optional: Profile to use. */
  profile: string;
}

/** VaultSecret defines the parameters for fetching a secret from HashiCorp Vault. */
export interface VaultSecret {
  /** The address of the Vault server (e.g., "https://vault.example.com"). */
  address: string;
  /** The token to authenticate with Vault. */
  token?:
    | SecretValue
    | undefined;
  /** The path to the secret in Vault (e.g., "secret/data/my-app/db"). */
  path: string;
  /** The key of the secret to retrieve from the path. */
  key: string;
}

/** RemoteContent represents content that is fetched from a remote URL. */
export interface RemoteContent {
  httpUrl: string;
  auth?: Authentication | undefined;
}

/**
 * Authentication defines an authentication method that can be used for both
 * incoming requests (validation) and outgoing requests (client).
 */
export interface Authentication {
  apiKey?: APIKeyAuth | undefined;
  bearerToken?: BearerTokenAuth | undefined;
  basicAuth?: BasicAuth | undefined;
  oauth2?: OAuth2Auth | undefined;
  oidc?: OIDCAuth | undefined;
  mtls?: MTLSAuth | undefined;
  trustedHeader?: TrustedHeaderAuth | undefined;
}

/** APIKeyAuth defines authentication using an API key. */
export interface APIKeyAuth {
  /** The name of the parameter carrying the key (e.g., "X-API-Key", "api_key"). */
  paramName: string;
  in: APIKeyAuth_Location;
  /** The API key value. Used for client authentication (outgoing). */
  value?:
    | SecretValue
    | undefined;
  /**
   * The expected API key value. Used for server validation (incoming).
   * This is a plain string because we compare against it.
   */
  verificationValue: string;
}

/** Where the API key is located. */
export enum APIKeyAuth_Location {
  HEADER = 0,
  QUERY = 1,
  /** COOKIE - Added COOKIE for completeness */
  COOKIE = 2,
  UNRECOGNIZED = -1,
}

export function aPIKeyAuth_LocationFromJSON(object: any): APIKeyAuth_Location {
  switch (object) {
    case 0:
    case "HEADER":
      return APIKeyAuth_Location.HEADER;
    case 1:
    case "QUERY":
      return APIKeyAuth_Location.QUERY;
    case 2:
    case "COOKIE":
      return APIKeyAuth_Location.COOKIE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return APIKeyAuth_Location.UNRECOGNIZED;
  }
}

export function aPIKeyAuth_LocationToJSON(object: APIKeyAuth_Location): string {
  switch (object) {
    case APIKeyAuth_Location.HEADER:
      return "HEADER";
    case APIKeyAuth_Location.QUERY:
      return "QUERY";
    case APIKeyAuth_Location.COOKIE:
      return "COOKIE";
    case APIKeyAuth_Location.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** BearerTokenAuth defines authentication using a bearer token. */
export interface BearerTokenAuth {
  /** The bearer token. */
  token?: SecretValue | undefined;
}

/** BasicAuth defines authentication using a username and password. */
export interface BasicAuth {
  username: string;
  /** The password. Used for client authentication (outgoing). */
  password?:
    | SecretValue
    | undefined;
  /** The bcrypt hash of the password. Used for server validation (incoming). */
  passwordHash: string;
}

/** OAuth2Auth defines authentication using the OAuth 2.0 client credentials flow. */
export interface OAuth2Auth {
  tokenUrl: string;
  clientId?: SecretValue | undefined;
  clientSecret?:
    | SecretValue
    | undefined;
  /** Space-delimited list of scopes. */
  scopes: string;
  /** Issuer URL for validation/discovery. */
  issuerUrl: string;
  /** Audience for validation. */
  audience: string;
  /** Authorization URL (optional, mainly for 3-legged flows if we ever support them). */
  authorizationUrl: string;
}

/** OIDCAuth defines authentication using OpenID Connect. */
export interface OIDCAuth {
  /** The issuer URL. */
  issuer: string;
  /** The subject to validate (incoming). */
  subject: string;
  /** The email to validate (incoming). */
  email: string;
  /** The audience(s) to validate (incoming). */
  audience: string[];
}

/** MTLSAuth defines authentication using mutual TLS. */
export interface MTLSAuth {
  /** Path to the client certificate file. */
  clientCertPath: string;
  /** Path to the client private key file. */
  clientKeyPath: string;
  /** Path to the CA certificate file for verifying the server's certificate. */
  caCertPath: string;
}

/** TrustedHeaderAuth defines authentication using a trusted header. */
export interface TrustedHeaderAuth {
  headerName: string;
  headerValue: string;
}

/** UserToken represents an OAuth2 token stored for a user. */
export interface UserToken {
  /** The ID of the user who owns this token. */
  userId: string;
  /** The ID of the service this token is for. */
  serviceId: string;
  /** The access token. */
  accessToken: string;
  /** The refresh token. */
  refreshToken: string;
  /** The token type (e.g. "Bearer"). */
  tokenType: string;
  /** The expiry time of the token (RFC3339). */
  expiry: string;
  /** The scopes associated with the token. */
  scope: string;
  /** The timestamp when the token was created/updated (RFC3339). */
  updatedAt: string;
  /** The email associated with the token (if available). */
  email: string;
}

/** Credential represents a reusable authentication configuration. */
export interface Credential {
  /** Unique identifier for the credential. */
  id: string;
  /** Human-readable name (e.g. "My GitHub Personal"). */
  name: string;
  /** The authentication configuration. */
  authentication?:
    | Authentication
    | undefined;
  /**
   * Optional: For interactive OAuth, the persisted session/tokens.
   * This allows the proxy to use this credential by refreshing the token.
   */
  token?:
    | UserToken
    | undefined;
  /** The ID of the user who owns this credential. */
  ownerId: string;
}

function createBaseSecretValue(): SecretValue {
  return {
    plainText: undefined,
    environmentVariable: undefined,
    filePath: undefined,
    remoteContent: undefined,
    vault: undefined,
    awsSecretManager: undefined,
    validationRegex: "",
  };
}

export const SecretValue: MessageFns<SecretValue> = {
  encode(message: SecretValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plainText !== undefined) {
      writer.uint32(10).string(message.plainText);
    }
    if (message.environmentVariable !== undefined) {
      writer.uint32(18).string(message.environmentVariable);
    }
    if (message.filePath !== undefined) {
      writer.uint32(26).string(message.filePath);
    }
    if (message.remoteContent !== undefined) {
      RemoteContent.encode(message.remoteContent, writer.uint32(34).fork()).join();
    }
    if (message.vault !== undefined) {
      VaultSecret.encode(message.vault, writer.uint32(42).fork()).join();
    }
    if (message.awsSecretManager !== undefined) {
      AwsSecretManagerSecret.encode(message.awsSecretManager, writer.uint32(50).fork()).join();
    }
    if (message.validationRegex !== "") {
      writer.uint32(58).string(message.validationRegex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plainText = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environmentVariable = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remoteContent = RemoteContent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.vault = VaultSecret.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.awsSecretManager = AwsSecretManagerSecret.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.validationRegex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretValue {
    return {
      plainText: isSet(object.plainText)
        ? globalThis.String(object.plainText)
        : isSet(object.plain_text)
        ? globalThis.String(object.plain_text)
        : undefined,
      environmentVariable: isSet(object.environmentVariable)
        ? globalThis.String(object.environmentVariable)
        : isSet(object.environment_variable)
        ? globalThis.String(object.environment_variable)
        : undefined,
      filePath: isSet(object.filePath)
        ? globalThis.String(object.filePath)
        : isSet(object.file_path)
        ? globalThis.String(object.file_path)
        : undefined,
      remoteContent: isSet(object.remoteContent)
        ? RemoteContent.fromJSON(object.remoteContent)
        : isSet(object.remote_content)
        ? RemoteContent.fromJSON(object.remote_content)
        : undefined,
      vault: isSet(object.vault) ? VaultSecret.fromJSON(object.vault) : undefined,
      awsSecretManager: isSet(object.awsSecretManager)
        ? AwsSecretManagerSecret.fromJSON(object.awsSecretManager)
        : isSet(object.aws_secret_manager)
        ? AwsSecretManagerSecret.fromJSON(object.aws_secret_manager)
        : undefined,
      validationRegex: isSet(object.validation_regex) ? globalThis.String(object.validation_regex) : "",
    };
  },

  toJSON(message: SecretValue): unknown {
    const obj: any = {};
    if (message.plainText !== undefined) {
      obj.plainText = message.plainText;
    }
    if (message.environmentVariable !== undefined) {
      obj.environmentVariable = message.environmentVariable;
    }
    if (message.filePath !== undefined) {
      obj.filePath = message.filePath;
    }
    if (message.remoteContent !== undefined) {
      obj.remoteContent = RemoteContent.toJSON(message.remoteContent);
    }
    if (message.vault !== undefined) {
      obj.vault = VaultSecret.toJSON(message.vault);
    }
    if (message.awsSecretManager !== undefined) {
      obj.awsSecretManager = AwsSecretManagerSecret.toJSON(message.awsSecretManager);
    }
    if (message.validationRegex !== "") {
      obj.validation_regex = message.validationRegex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretValue>, I>>(base?: I): SecretValue {
    return SecretValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretValue>, I>>(object: I): SecretValue {
    const message = createBaseSecretValue();
    message.plainText = object.plainText ?? undefined;
    message.environmentVariable = object.environmentVariable ?? undefined;
    message.filePath = object.filePath ?? undefined;
    message.remoteContent = (object.remoteContent !== undefined && object.remoteContent !== null)
      ? RemoteContent.fromPartial(object.remoteContent)
      : undefined;
    message.vault = (object.vault !== undefined && object.vault !== null)
      ? VaultSecret.fromPartial(object.vault)
      : undefined;
    message.awsSecretManager = (object.awsSecretManager !== undefined && object.awsSecretManager !== null)
      ? AwsSecretManagerSecret.fromPartial(object.awsSecretManager)
      : undefined;
    message.validationRegex = object.validationRegex ?? "";
    return message;
  },
};

function createBaseAwsSecretManagerSecret(): AwsSecretManagerSecret {
  return { secretId: "", jsonKey: "", versionStage: "", versionId: "", region: "", profile: "" };
}

export const AwsSecretManagerSecret: MessageFns<AwsSecretManagerSecret> = {
  encode(message: AwsSecretManagerSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretId !== "") {
      writer.uint32(10).string(message.secretId);
    }
    if (message.jsonKey !== "") {
      writer.uint32(18).string(message.jsonKey);
    }
    if (message.versionStage !== "") {
      writer.uint32(26).string(message.versionStage);
    }
    if (message.versionId !== "") {
      writer.uint32(34).string(message.versionId);
    }
    if (message.region !== "") {
      writer.uint32(42).string(message.region);
    }
    if (message.profile !== "") {
      writer.uint32(50).string(message.profile);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSecretManagerSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSecretManagerSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secretId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jsonKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.versionStage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.versionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.profile = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSecretManagerSecret {
    return {
      secretId: isSet(object.secret_id) ? globalThis.String(object.secret_id) : "",
      jsonKey: isSet(object.json_key) ? globalThis.String(object.json_key) : "",
      versionStage: isSet(object.version_stage) ? globalThis.String(object.version_stage) : "",
      versionId: isSet(object.version_id) ? globalThis.String(object.version_id) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
    };
  },

  toJSON(message: AwsSecretManagerSecret): unknown {
    const obj: any = {};
    if (message.secretId !== "") {
      obj.secret_id = message.secretId;
    }
    if (message.jsonKey !== "") {
      obj.json_key = message.jsonKey;
    }
    if (message.versionStage !== "") {
      obj.version_stage = message.versionStage;
    }
    if (message.versionId !== "") {
      obj.version_id = message.versionId;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.profile !== "") {
      obj.profile = message.profile;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AwsSecretManagerSecret>, I>>(base?: I): AwsSecretManagerSecret {
    return AwsSecretManagerSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AwsSecretManagerSecret>, I>>(object: I): AwsSecretManagerSecret {
    const message = createBaseAwsSecretManagerSecret();
    message.secretId = object.secretId ?? "";
    message.jsonKey = object.jsonKey ?? "";
    message.versionStage = object.versionStage ?? "";
    message.versionId = object.versionId ?? "";
    message.region = object.region ?? "";
    message.profile = object.profile ?? "";
    return message;
  },
};

function createBaseVaultSecret(): VaultSecret {
  return { address: "", token: undefined, path: "", key: "" };
}

export const VaultSecret: MessageFns<VaultSecret> = {
  encode(message: VaultSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.token !== undefined) {
      SecretValue.encode(message.token, writer.uint32(18).fork()).join();
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.key !== "") {
      writer.uint32(34).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VaultSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVaultSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VaultSecret {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      token: isSet(object.token) ? SecretValue.fromJSON(object.token) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: VaultSecret): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.token !== undefined) {
      obj.token = SecretValue.toJSON(message.token);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VaultSecret>, I>>(base?: I): VaultSecret {
    return VaultSecret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VaultSecret>, I>>(object: I): VaultSecret {
    const message = createBaseVaultSecret();
    message.address = object.address ?? "";
    message.token = (object.token !== undefined && object.token !== null)
      ? SecretValue.fromPartial(object.token)
      : undefined;
    message.path = object.path ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseRemoteContent(): RemoteContent {
  return { httpUrl: "", auth: undefined };
}

export const RemoteContent: MessageFns<RemoteContent> = {
  encode(message: RemoteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpUrl !== "") {
      writer.uint32(10).string(message.httpUrl);
    }
    if (message.auth !== undefined) {
      Authentication.encode(message.auth, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.httpUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.auth = Authentication.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteContent {
    return {
      httpUrl: isSet(object.httpUrl)
        ? globalThis.String(object.httpUrl)
        : isSet(object.http_url)
        ? globalThis.String(object.http_url)
        : "",
      auth: isSet(object.auth) ? Authentication.fromJSON(object.auth) : undefined,
    };
  },

  toJSON(message: RemoteContent): unknown {
    const obj: any = {};
    if (message.httpUrl !== "") {
      obj.httpUrl = message.httpUrl;
    }
    if (message.auth !== undefined) {
      obj.auth = Authentication.toJSON(message.auth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoteContent>, I>>(base?: I): RemoteContent {
    return RemoteContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoteContent>, I>>(object: I): RemoteContent {
    const message = createBaseRemoteContent();
    message.httpUrl = object.httpUrl ?? "";
    message.auth = (object.auth !== undefined && object.auth !== null)
      ? Authentication.fromPartial(object.auth)
      : undefined;
    return message;
  },
};

function createBaseAuthentication(): Authentication {
  return {
    apiKey: undefined,
    bearerToken: undefined,
    basicAuth: undefined,
    oauth2: undefined,
    oidc: undefined,
    mtls: undefined,
    trustedHeader: undefined,
  };
}

export const Authentication: MessageFns<Authentication> = {
  encode(message: Authentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== undefined) {
      APIKeyAuth.encode(message.apiKey, writer.uint32(10).fork()).join();
    }
    if (message.bearerToken !== undefined) {
      BearerTokenAuth.encode(message.bearerToken, writer.uint32(18).fork()).join();
    }
    if (message.basicAuth !== undefined) {
      BasicAuth.encode(message.basicAuth, writer.uint32(26).fork()).join();
    }
    if (message.oauth2 !== undefined) {
      OAuth2Auth.encode(message.oauth2, writer.uint32(34).fork()).join();
    }
    if (message.oidc !== undefined) {
      OIDCAuth.encode(message.oidc, writer.uint32(42).fork()).join();
    }
    if (message.mtls !== undefined) {
      MTLSAuth.encode(message.mtls, writer.uint32(50).fork()).join();
    }
    if (message.trustedHeader !== undefined) {
      TrustedHeaderAuth.encode(message.trustedHeader, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = APIKeyAuth.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bearerToken = BearerTokenAuth.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.basicAuth = BasicAuth.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oauth2 = OAuth2Auth.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.oidc = OIDCAuth.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mtls = MTLSAuth.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.trustedHeader = TrustedHeaderAuth.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authentication {
    return {
      apiKey: isSet(object.api_key) ? APIKeyAuth.fromJSON(object.api_key) : undefined,
      bearerToken: isSet(object.bearer_token) ? BearerTokenAuth.fromJSON(object.bearer_token) : undefined,
      basicAuth: isSet(object.basic_auth) ? BasicAuth.fromJSON(object.basic_auth) : undefined,
      oauth2: isSet(object.oauth2) ? OAuth2Auth.fromJSON(object.oauth2) : undefined,
      oidc: isSet(object.oidc) ? OIDCAuth.fromJSON(object.oidc) : undefined,
      mtls: isSet(object.mtls) ? MTLSAuth.fromJSON(object.mtls) : undefined,
      trustedHeader: isSet(object.trusted_header) ? TrustedHeaderAuth.fromJSON(object.trusted_header) : undefined,
    };
  },

  toJSON(message: Authentication): unknown {
    const obj: any = {};
    if (message.apiKey !== undefined) {
      obj.api_key = APIKeyAuth.toJSON(message.apiKey);
    }
    if (message.bearerToken !== undefined) {
      obj.bearer_token = BearerTokenAuth.toJSON(message.bearerToken);
    }
    if (message.basicAuth !== undefined) {
      obj.basic_auth = BasicAuth.toJSON(message.basicAuth);
    }
    if (message.oauth2 !== undefined) {
      obj.oauth2 = OAuth2Auth.toJSON(message.oauth2);
    }
    if (message.oidc !== undefined) {
      obj.oidc = OIDCAuth.toJSON(message.oidc);
    }
    if (message.mtls !== undefined) {
      obj.mtls = MTLSAuth.toJSON(message.mtls);
    }
    if (message.trustedHeader !== undefined) {
      obj.trusted_header = TrustedHeaderAuth.toJSON(message.trustedHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Authentication>, I>>(base?: I): Authentication {
    return Authentication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Authentication>, I>>(object: I): Authentication {
    const message = createBaseAuthentication();
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? APIKeyAuth.fromPartial(object.apiKey)
      : undefined;
    message.bearerToken = (object.bearerToken !== undefined && object.bearerToken !== null)
      ? BearerTokenAuth.fromPartial(object.bearerToken)
      : undefined;
    message.basicAuth = (object.basicAuth !== undefined && object.basicAuth !== null)
      ? BasicAuth.fromPartial(object.basicAuth)
      : undefined;
    message.oauth2 = (object.oauth2 !== undefined && object.oauth2 !== null)
      ? OAuth2Auth.fromPartial(object.oauth2)
      : undefined;
    message.oidc = (object.oidc !== undefined && object.oidc !== null) ? OIDCAuth.fromPartial(object.oidc) : undefined;
    message.mtls = (object.mtls !== undefined && object.mtls !== null) ? MTLSAuth.fromPartial(object.mtls) : undefined;
    message.trustedHeader = (object.trustedHeader !== undefined && object.trustedHeader !== null)
      ? TrustedHeaderAuth.fromPartial(object.trustedHeader)
      : undefined;
    return message;
  },
};

function createBaseAPIKeyAuth(): APIKeyAuth {
  return { paramName: "", in: 0, value: undefined, verificationValue: "" };
}

export const APIKeyAuth: MessageFns<APIKeyAuth> = {
  encode(message: APIKeyAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paramName !== "") {
      writer.uint32(10).string(message.paramName);
    }
    if (message.in !== 0) {
      writer.uint32(16).int32(message.in);
    }
    if (message.value !== undefined) {
      SecretValue.encode(message.value, writer.uint32(26).fork()).join();
    }
    if (message.verificationValue !== "") {
      writer.uint32(34).string(message.verificationValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): APIKeyAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAPIKeyAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paramName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.in = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verificationValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): APIKeyAuth {
    return {
      paramName: isSet(object.param_name) ? globalThis.String(object.param_name) : "",
      in: isSet(object.in) ? aPIKeyAuth_LocationFromJSON(object.in) : 0,
      value: isSet(object.value) ? SecretValue.fromJSON(object.value) : undefined,
      verificationValue: isSet(object.verification_value) ? globalThis.String(object.verification_value) : "",
    };
  },

  toJSON(message: APIKeyAuth): unknown {
    const obj: any = {};
    if (message.paramName !== "") {
      obj.param_name = message.paramName;
    }
    if (message.in !== 0) {
      obj.in = aPIKeyAuth_LocationToJSON(message.in);
    }
    if (message.value !== undefined) {
      obj.value = SecretValue.toJSON(message.value);
    }
    if (message.verificationValue !== "") {
      obj.verification_value = message.verificationValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<APIKeyAuth>, I>>(base?: I): APIKeyAuth {
    return APIKeyAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<APIKeyAuth>, I>>(object: I): APIKeyAuth {
    const message = createBaseAPIKeyAuth();
    message.paramName = object.paramName ?? "";
    message.in = object.in ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretValue.fromPartial(object.value)
      : undefined;
    message.verificationValue = object.verificationValue ?? "";
    return message;
  },
};

function createBaseBearerTokenAuth(): BearerTokenAuth {
  return { token: undefined };
}

export const BearerTokenAuth: MessageFns<BearerTokenAuth> = {
  encode(message: BearerTokenAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== undefined) {
      SecretValue.encode(message.token, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BearerTokenAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBearerTokenAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BearerTokenAuth {
    return { token: isSet(object.token) ? SecretValue.fromJSON(object.token) : undefined };
  },

  toJSON(message: BearerTokenAuth): unknown {
    const obj: any = {};
    if (message.token !== undefined) {
      obj.token = SecretValue.toJSON(message.token);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BearerTokenAuth>, I>>(base?: I): BearerTokenAuth {
    return BearerTokenAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BearerTokenAuth>, I>>(object: I): BearerTokenAuth {
    const message = createBaseBearerTokenAuth();
    message.token = (object.token !== undefined && object.token !== null)
      ? SecretValue.fromPartial(object.token)
      : undefined;
    return message;
  },
};

function createBaseBasicAuth(): BasicAuth {
  return { username: "", password: undefined, passwordHash: "" };
}

export const BasicAuth: MessageFns<BasicAuth> = {
  encode(message: BasicAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== undefined) {
      SecretValue.encode(message.password, writer.uint32(18).fork()).join();
    }
    if (message.passwordHash !== "") {
      writer.uint32(26).string(message.passwordHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.passwordHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicAuth {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? SecretValue.fromJSON(object.password) : undefined,
      passwordHash: isSet(object.password_hash) ? globalThis.String(object.password_hash) : "",
    };
  },

  toJSON(message: BasicAuth): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== undefined) {
      obj.password = SecretValue.toJSON(message.password);
    }
    if (message.passwordHash !== "") {
      obj.password_hash = message.passwordHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicAuth>, I>>(base?: I): BasicAuth {
    return BasicAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicAuth>, I>>(object: I): BasicAuth {
    const message = createBaseBasicAuth();
    message.username = object.username ?? "";
    message.password = (object.password !== undefined && object.password !== null)
      ? SecretValue.fromPartial(object.password)
      : undefined;
    message.passwordHash = object.passwordHash ?? "";
    return message;
  },
};

function createBaseOAuth2Auth(): OAuth2Auth {
  return {
    tokenUrl: "",
    clientId: undefined,
    clientSecret: undefined,
    scopes: "",
    issuerUrl: "",
    audience: "",
    authorizationUrl: "",
  };
}

export const OAuth2Auth: MessageFns<OAuth2Auth> = {
  encode(message: OAuth2Auth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenUrl !== "") {
      writer.uint32(10).string(message.tokenUrl);
    }
    if (message.clientId !== undefined) {
      SecretValue.encode(message.clientId, writer.uint32(18).fork()).join();
    }
    if (message.clientSecret !== undefined) {
      SecretValue.encode(message.clientSecret, writer.uint32(26).fork()).join();
    }
    if (message.scopes !== "") {
      writer.uint32(34).string(message.scopes);
    }
    if (message.issuerUrl !== "") {
      writer.uint32(42).string(message.issuerUrl);
    }
    if (message.audience !== "") {
      writer.uint32(50).string(message.audience);
    }
    if (message.authorizationUrl !== "") {
      writer.uint32(58).string(message.authorizationUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuth2Auth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuth2Auth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientSecret = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scopes = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.issuerUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.audience = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuth2Auth {
    return {
      tokenUrl: isSet(object.token_url) ? globalThis.String(object.token_url) : "",
      clientId: isSet(object.client_id) ? SecretValue.fromJSON(object.client_id) : undefined,
      clientSecret: isSet(object.client_secret) ? SecretValue.fromJSON(object.client_secret) : undefined,
      scopes: isSet(object.scopes) ? globalThis.String(object.scopes) : "",
      issuerUrl: isSet(object.issuer_url) ? globalThis.String(object.issuer_url) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
      authorizationUrl: isSet(object.authorization_url) ? globalThis.String(object.authorization_url) : "",
    };
  },

  toJSON(message: OAuth2Auth): unknown {
    const obj: any = {};
    if (message.tokenUrl !== "") {
      obj.token_url = message.tokenUrl;
    }
    if (message.clientId !== undefined) {
      obj.client_id = SecretValue.toJSON(message.clientId);
    }
    if (message.clientSecret !== undefined) {
      obj.client_secret = SecretValue.toJSON(message.clientSecret);
    }
    if (message.scopes !== "") {
      obj.scopes = message.scopes;
    }
    if (message.issuerUrl !== "") {
      obj.issuer_url = message.issuerUrl;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    if (message.authorizationUrl !== "") {
      obj.authorization_url = message.authorizationUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2Auth>, I>>(base?: I): OAuth2Auth {
    return OAuth2Auth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2Auth>, I>>(object: I): OAuth2Auth {
    const message = createBaseOAuth2Auth();
    message.tokenUrl = object.tokenUrl ?? "";
    message.clientId = (object.clientId !== undefined && object.clientId !== null)
      ? SecretValue.fromPartial(object.clientId)
      : undefined;
    message.clientSecret = (object.clientSecret !== undefined && object.clientSecret !== null)
      ? SecretValue.fromPartial(object.clientSecret)
      : undefined;
    message.scopes = object.scopes ?? "";
    message.issuerUrl = object.issuerUrl ?? "";
    message.audience = object.audience ?? "";
    message.authorizationUrl = object.authorizationUrl ?? "";
    return message;
  },
};

function createBaseOIDCAuth(): OIDCAuth {
  return { issuer: "", subject: "", email: "", audience: [] };
}

export const OIDCAuth: MessageFns<OIDCAuth> = {
  encode(message: OIDCAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    for (const v of message.audience) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OIDCAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOIDCAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.audience.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OIDCAuth {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      audience: globalThis.Array.isArray(object?.audience) ? object.audience.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: OIDCAuth): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.audience?.length) {
      obj.audience = message.audience;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OIDCAuth>, I>>(base?: I): OIDCAuth {
    return OIDCAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OIDCAuth>, I>>(object: I): OIDCAuth {
    const message = createBaseOIDCAuth();
    message.issuer = object.issuer ?? "";
    message.subject = object.subject ?? "";
    message.email = object.email ?? "";
    message.audience = object.audience?.map((e) => e) || [];
    return message;
  },
};

function createBaseMTLSAuth(): MTLSAuth {
  return { clientCertPath: "", clientKeyPath: "", caCertPath: "" };
}

export const MTLSAuth: MessageFns<MTLSAuth> = {
  encode(message: MTLSAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientCertPath !== "") {
      writer.uint32(10).string(message.clientCertPath);
    }
    if (message.clientKeyPath !== "") {
      writer.uint32(18).string(message.clientKeyPath);
    }
    if (message.caCertPath !== "") {
      writer.uint32(26).string(message.caCertPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MTLSAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMTLSAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientCertPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientKeyPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.caCertPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MTLSAuth {
    return {
      clientCertPath: isSet(object.client_cert_path) ? globalThis.String(object.client_cert_path) : "",
      clientKeyPath: isSet(object.client_key_path) ? globalThis.String(object.client_key_path) : "",
      caCertPath: isSet(object.ca_cert_path) ? globalThis.String(object.ca_cert_path) : "",
    };
  },

  toJSON(message: MTLSAuth): unknown {
    const obj: any = {};
    if (message.clientCertPath !== "") {
      obj.client_cert_path = message.clientCertPath;
    }
    if (message.clientKeyPath !== "") {
      obj.client_key_path = message.clientKeyPath;
    }
    if (message.caCertPath !== "") {
      obj.ca_cert_path = message.caCertPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MTLSAuth>, I>>(base?: I): MTLSAuth {
    return MTLSAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MTLSAuth>, I>>(object: I): MTLSAuth {
    const message = createBaseMTLSAuth();
    message.clientCertPath = object.clientCertPath ?? "";
    message.clientKeyPath = object.clientKeyPath ?? "";
    message.caCertPath = object.caCertPath ?? "";
    return message;
  },
};

function createBaseTrustedHeaderAuth(): TrustedHeaderAuth {
  return { headerName: "", headerValue: "" };
}

export const TrustedHeaderAuth: MessageFns<TrustedHeaderAuth> = {
  encode(message: TrustedHeaderAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headerName !== "") {
      writer.uint32(10).string(message.headerName);
    }
    if (message.headerValue !== "") {
      writer.uint32(18).string(message.headerValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrustedHeaderAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrustedHeaderAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.headerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.headerValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrustedHeaderAuth {
    return {
      headerName: isSet(object.header_name) ? globalThis.String(object.header_name) : "",
      headerValue: isSet(object.header_value) ? globalThis.String(object.header_value) : "",
    };
  },

  toJSON(message: TrustedHeaderAuth): unknown {
    const obj: any = {};
    if (message.headerName !== "") {
      obj.header_name = message.headerName;
    }
    if (message.headerValue !== "") {
      obj.header_value = message.headerValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrustedHeaderAuth>, I>>(base?: I): TrustedHeaderAuth {
    return TrustedHeaderAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrustedHeaderAuth>, I>>(object: I): TrustedHeaderAuth {
    const message = createBaseTrustedHeaderAuth();
    message.headerName = object.headerName ?? "";
    message.headerValue = object.headerValue ?? "";
    return message;
  },
};

function createBaseUserToken(): UserToken {
  return {
    userId: "",
    serviceId: "",
    accessToken: "",
    refreshToken: "",
    tokenType: "",
    expiry: "",
    scope: "",
    updatedAt: "",
    email: "",
  };
}

export const UserToken: MessageFns<UserToken> = {
  encode(message: UserToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.serviceId !== "") {
      writer.uint32(18).string(message.serviceId);
    }
    if (message.accessToken !== "") {
      writer.uint32(26).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(34).string(message.refreshToken);
    }
    if (message.tokenType !== "") {
      writer.uint32(42).string(message.tokenType);
    }
    if (message.expiry !== "") {
      writer.uint32(50).string(message.expiry);
    }
    if (message.scope !== "") {
      writer.uint32(58).string(message.scope);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    if (message.email !== "") {
      writer.uint32(74).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiry = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserToken {
    return {
      userId: isSet(object.user_id) ? globalThis.String(object.user_id) : "",
      serviceId: isSet(object.service_id) ? globalThis.String(object.service_id) : "",
      accessToken: isSet(object.access_token) ? globalThis.String(object.access_token) : "",
      refreshToken: isSet(object.refresh_token) ? globalThis.String(object.refresh_token) : "",
      tokenType: isSet(object.token_type) ? globalThis.String(object.token_type) : "",
      expiry: isSet(object.expiry) ? globalThis.String(object.expiry) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      updatedAt: isSet(object.updated_at) ? globalThis.String(object.updated_at) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: UserToken): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.user_id = message.userId;
    }
    if (message.serviceId !== "") {
      obj.service_id = message.serviceId;
    }
    if (message.accessToken !== "") {
      obj.access_token = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refresh_token = message.refreshToken;
    }
    if (message.tokenType !== "") {
      obj.token_type = message.tokenType;
    }
    if (message.expiry !== "") {
      obj.expiry = message.expiry;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.updatedAt !== "") {
      obj.updated_at = message.updatedAt;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserToken>, I>>(base?: I): UserToken {
    return UserToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserToken>, I>>(object: I): UserToken {
    const message = createBaseUserToken();
    message.userId = object.userId ?? "";
    message.serviceId = object.serviceId ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.tokenType = object.tokenType ?? "";
    message.expiry = object.expiry ?? "";
    message.scope = object.scope ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseCredential(): Credential {
  return { id: "", name: "", authentication: undefined, token: undefined, ownerId: "" };
}

export const Credential: MessageFns<Credential> = {
  encode(message: Credential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.authentication !== undefined) {
      Authentication.encode(message.authentication, writer.uint32(26).fork()).join();
    }
    if (message.token !== undefined) {
      UserToken.encode(message.token, writer.uint32(34).fork()).join();
    }
    if (message.ownerId !== "") {
      writer.uint32(42).string(message.ownerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Credential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authentication = Authentication.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.token = UserToken.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Credential {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      authentication: isSet(object.authentication) ? Authentication.fromJSON(object.authentication) : undefined,
      token: isSet(object.token) ? UserToken.fromJSON(object.token) : undefined,
      ownerId: isSet(object.owner_id) ? globalThis.String(object.owner_id) : "",
    };
  },

  toJSON(message: Credential): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.authentication !== undefined) {
      obj.authentication = Authentication.toJSON(message.authentication);
    }
    if (message.token !== undefined) {
      obj.token = UserToken.toJSON(message.token);
    }
    if (message.ownerId !== "") {
      obj.owner_id = message.ownerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Credential>, I>>(base?: I): Credential {
    return Credential.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Credential>, I>>(object: I): Credential {
    const message = createBaseCredential();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.authentication = (object.authentication !== undefined && object.authentication !== null)
      ? Authentication.fromPartial(object.authentication)
      : undefined;
    message.token = (object.token !== undefined && object.token !== null)
      ? UserToken.fromPartial(object.token)
      : undefined;
    message.ownerId = object.ownerId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
