// Copyright 2025 Author(s) of MCP Any
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.1
// source: proto/config/v1/auth.proto

//go:build !protoopaque

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Where the API key is located.
type APIKeyAuth_Location int32

const (
	APIKeyAuth_HEADER APIKeyAuth_Location = 0
	APIKeyAuth_QUERY  APIKeyAuth_Location = 1
	APIKeyAuth_COOKIE APIKeyAuth_Location = 2 // Added COOKIE for completeness
)

// Enum value maps for APIKeyAuth_Location.
var (
	APIKeyAuth_Location_name = map[int32]string{
		0: "HEADER",
		1: "QUERY",
		2: "COOKIE",
	}
	APIKeyAuth_Location_value = map[string]int32{
		"HEADER": 0,
		"QUERY":  1,
		"COOKIE": 2,
	}
)

func (x APIKeyAuth_Location) Enum() *APIKeyAuth_Location {
	p := new(APIKeyAuth_Location)
	*p = x
	return p
}

func (x APIKeyAuth_Location) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (APIKeyAuth_Location) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_auth_proto_enumTypes[0].Descriptor()
}

func (APIKeyAuth_Location) Type() protoreflect.EnumType {
	return &file_proto_config_v1_auth_proto_enumTypes[0]
}

func (x APIKeyAuth_Location) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// SecretValue represents a value that should be treated as a secret.
// It can be a plain text value, an environment variable, a file path, or content fetched from a remote URL.
type SecretValue struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*SecretValue_PlainText
	//	*SecretValue_EnvironmentVariable
	//	*SecretValue_FilePath
	//	*SecretValue_RemoteContent
	//	*SecretValue_Vault
	//	*SecretValue_AwsSecretManager
	Value         isSecretValue_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretValue) Reset() {
	*x = SecretValue{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretValue) ProtoMessage() {}

func (x *SecretValue) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SecretValue) GetValue() isSecretValue_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *SecretValue) GetPlainText() string {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_PlainText); ok {
			return x.PlainText
		}
	}
	return ""
}

func (x *SecretValue) GetEnvironmentVariable() string {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_EnvironmentVariable); ok {
			return x.EnvironmentVariable
		}
	}
	return ""
}

func (x *SecretValue) GetFilePath() string {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_FilePath); ok {
			return x.FilePath
		}
	}
	return ""
}

func (x *SecretValue) GetRemoteContent() *RemoteContent {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_RemoteContent); ok {
			return x.RemoteContent
		}
	}
	return nil
}

func (x *SecretValue) GetVault() *VaultSecret {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_Vault); ok {
			return x.Vault
		}
	}
	return nil
}

func (x *SecretValue) GetAwsSecretManager() *AwsSecretManagerSecret {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_AwsSecretManager); ok {
			return x.AwsSecretManager
		}
	}
	return nil
}

func (x *SecretValue) SetPlainText(v string) {
	x.Value = &SecretValue_PlainText{v}
}

func (x *SecretValue) SetEnvironmentVariable(v string) {
	x.Value = &SecretValue_EnvironmentVariable{v}
}

func (x *SecretValue) SetFilePath(v string) {
	x.Value = &SecretValue_FilePath{v}
}

func (x *SecretValue) SetRemoteContent(v *RemoteContent) {
	if v == nil {
		x.Value = nil
		return
	}
	x.Value = &SecretValue_RemoteContent{v}
}

func (x *SecretValue) SetVault(v *VaultSecret) {
	if v == nil {
		x.Value = nil
		return
	}
	x.Value = &SecretValue_Vault{v}
}

func (x *SecretValue) SetAwsSecretManager(v *AwsSecretManagerSecret) {
	if v == nil {
		x.Value = nil
		return
	}
	x.Value = &SecretValue_AwsSecretManager{v}
}

func (x *SecretValue) HasValue() bool {
	if x == nil {
		return false
	}
	return x.Value != nil
}

func (x *SecretValue) HasPlainText() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_PlainText)
	return ok
}

func (x *SecretValue) HasEnvironmentVariable() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_EnvironmentVariable)
	return ok
}

func (x *SecretValue) HasFilePath() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_FilePath)
	return ok
}

func (x *SecretValue) HasRemoteContent() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_RemoteContent)
	return ok
}

func (x *SecretValue) HasVault() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_Vault)
	return ok
}

func (x *SecretValue) HasAwsSecretManager() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_AwsSecretManager)
	return ok
}

func (x *SecretValue) ClearValue() {
	x.Value = nil
}

func (x *SecretValue) ClearPlainText() {
	if _, ok := x.Value.(*SecretValue_PlainText); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearEnvironmentVariable() {
	if _, ok := x.Value.(*SecretValue_EnvironmentVariable); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearFilePath() {
	if _, ok := x.Value.(*SecretValue_FilePath); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearRemoteContent() {
	if _, ok := x.Value.(*SecretValue_RemoteContent); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearVault() {
	if _, ok := x.Value.(*SecretValue_Vault); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearAwsSecretManager() {
	if _, ok := x.Value.(*SecretValue_AwsSecretManager); ok {
		x.Value = nil
	}
}

const SecretValue_Value_not_set_case case_SecretValue_Value = 0
const SecretValue_PlainText_case case_SecretValue_Value = 1
const SecretValue_EnvironmentVariable_case case_SecretValue_Value = 2
const SecretValue_FilePath_case case_SecretValue_Value = 3
const SecretValue_RemoteContent_case case_SecretValue_Value = 4
const SecretValue_Vault_case case_SecretValue_Value = 5
const SecretValue_AwsSecretManager_case case_SecretValue_Value = 6

func (x *SecretValue) WhichValue() case_SecretValue_Value {
	if x == nil {
		return SecretValue_Value_not_set_case
	}
	switch x.Value.(type) {
	case *SecretValue_PlainText:
		return SecretValue_PlainText_case
	case *SecretValue_EnvironmentVariable:
		return SecretValue_EnvironmentVariable_case
	case *SecretValue_FilePath:
		return SecretValue_FilePath_case
	case *SecretValue_RemoteContent:
		return SecretValue_RemoteContent_case
	case *SecretValue_Vault:
		return SecretValue_Vault_case
	case *SecretValue_AwsSecretManager:
		return SecretValue_AwsSecretManager_case
	default:
		return SecretValue_Value_not_set_case
	}
}

type SecretValue_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof Value:
	PlainText           *string
	EnvironmentVariable *string
	FilePath            *string
	RemoteContent       *RemoteContent
	Vault               *VaultSecret
	AwsSecretManager    *AwsSecretManagerSecret
	// -- end of Value
}

func (b0 SecretValue_builder) Build() *SecretValue {
	m0 := &SecretValue{}
	b, x := &b0, m0
	_, _ = b, x
	if b.PlainText != nil {
		x.Value = &SecretValue_PlainText{*b.PlainText}
	}
	if b.EnvironmentVariable != nil {
		x.Value = &SecretValue_EnvironmentVariable{*b.EnvironmentVariable}
	}
	if b.FilePath != nil {
		x.Value = &SecretValue_FilePath{*b.FilePath}
	}
	if b.RemoteContent != nil {
		x.Value = &SecretValue_RemoteContent{b.RemoteContent}
	}
	if b.Vault != nil {
		x.Value = &SecretValue_Vault{b.Vault}
	}
	if b.AwsSecretManager != nil {
		x.Value = &SecretValue_AwsSecretManager{b.AwsSecretManager}
	}
	return m0
}

type case_SecretValue_Value protoreflect.FieldNumber

func (x case_SecretValue_Value) String() string {
	md := file_proto_config_v1_auth_proto_msgTypes[0].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isSecretValue_Value interface {
	isSecretValue_Value()
}

type SecretValue_PlainText struct {
	PlainText string `protobuf:"bytes,1,opt,name=plain_text,json=plainText,oneof"`
}

type SecretValue_EnvironmentVariable struct {
	EnvironmentVariable string `protobuf:"bytes,2,opt,name=environment_variable,json=environmentVariable,oneof"`
}

type SecretValue_FilePath struct {
	FilePath string `protobuf:"bytes,3,opt,name=file_path,json=filePath,oneof"`
}

type SecretValue_RemoteContent struct {
	RemoteContent *RemoteContent `protobuf:"bytes,4,opt,name=remote_content,json=remoteContent,oneof"`
}

type SecretValue_Vault struct {
	Vault *VaultSecret `protobuf:"bytes,5,opt,name=vault,oneof"`
}

type SecretValue_AwsSecretManager struct {
	AwsSecretManager *AwsSecretManagerSecret `protobuf:"bytes,6,opt,name=aws_secret_manager,json=awsSecretManager,oneof"`
}

func (*SecretValue_PlainText) isSecretValue_Value() {}

func (*SecretValue_EnvironmentVariable) isSecretValue_Value() {}

func (*SecretValue_FilePath) isSecretValue_Value() {}

func (*SecretValue_RemoteContent) isSecretValue_Value() {}

func (*SecretValue_Vault) isSecretValue_Value() {}

func (*SecretValue_AwsSecretManager) isSecretValue_Value() {}

// AwsSecretManagerSecret defines the parameters for fetching a secret from AWS Secrets Manager.
type AwsSecretManagerSecret struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The name or ARN of the secret.
	SecretId *string `protobuf:"bytes,1,opt,name=secret_id" json:"secret_id,omitempty"`
	// Optional: The key to extract from the secret JSON.
	JsonKey *string `protobuf:"bytes,2,opt,name=json_key" json:"json_key,omitempty"`
	// Optional: The version stage (defaults to AWSCURRENT).
	VersionStage *string `protobuf:"bytes,3,opt,name=version_stage" json:"version_stage,omitempty"`
	// Optional: The version ID.
	VersionId *string `protobuf:"bytes,4,opt,name=version_id" json:"version_id,omitempty"`
	// Optional: The region. If not set, uses environment or profile.
	Region *string `protobuf:"bytes,5,opt,name=region" json:"region,omitempty"`
	// Optional: Profile to use.
	Profile       *string `protobuf:"bytes,6,opt,name=profile" json:"profile,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AwsSecretManagerSecret) Reset() {
	*x = AwsSecretManagerSecret{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AwsSecretManagerSecret) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AwsSecretManagerSecret) ProtoMessage() {}

func (x *AwsSecretManagerSecret) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AwsSecretManagerSecret) GetSecretId() string {
	if x != nil && x.SecretId != nil {
		return *x.SecretId
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetJsonKey() string {
	if x != nil && x.JsonKey != nil {
		return *x.JsonKey
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetVersionStage() string {
	if x != nil && x.VersionStage != nil {
		return *x.VersionStage
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetVersionId() string {
	if x != nil && x.VersionId != nil {
		return *x.VersionId
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetRegion() string {
	if x != nil && x.Region != nil {
		return *x.Region
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetProfile() string {
	if x != nil && x.Profile != nil {
		return *x.Profile
	}
	return ""
}

func (x *AwsSecretManagerSecret) SetSecretId(v string) {
	x.SecretId = &v
}

func (x *AwsSecretManagerSecret) SetJsonKey(v string) {
	x.JsonKey = &v
}

func (x *AwsSecretManagerSecret) SetVersionStage(v string) {
	x.VersionStage = &v
}

func (x *AwsSecretManagerSecret) SetVersionId(v string) {
	x.VersionId = &v
}

func (x *AwsSecretManagerSecret) SetRegion(v string) {
	x.Region = &v
}

func (x *AwsSecretManagerSecret) SetProfile(v string) {
	x.Profile = &v
}

func (x *AwsSecretManagerSecret) HasSecretId() bool {
	if x == nil {
		return false
	}
	return x.SecretId != nil
}

func (x *AwsSecretManagerSecret) HasJsonKey() bool {
	if x == nil {
		return false
	}
	return x.JsonKey != nil
}

func (x *AwsSecretManagerSecret) HasVersionStage() bool {
	if x == nil {
		return false
	}
	return x.VersionStage != nil
}

func (x *AwsSecretManagerSecret) HasVersionId() bool {
	if x == nil {
		return false
	}
	return x.VersionId != nil
}

func (x *AwsSecretManagerSecret) HasRegion() bool {
	if x == nil {
		return false
	}
	return x.Region != nil
}

func (x *AwsSecretManagerSecret) HasProfile() bool {
	if x == nil {
		return false
	}
	return x.Profile != nil
}

func (x *AwsSecretManagerSecret) ClearSecretId() {
	x.SecretId = nil
}

func (x *AwsSecretManagerSecret) ClearJsonKey() {
	x.JsonKey = nil
}

func (x *AwsSecretManagerSecret) ClearVersionStage() {
	x.VersionStage = nil
}

func (x *AwsSecretManagerSecret) ClearVersionId() {
	x.VersionId = nil
}

func (x *AwsSecretManagerSecret) ClearRegion() {
	x.Region = nil
}

func (x *AwsSecretManagerSecret) ClearProfile() {
	x.Profile = nil
}

type AwsSecretManagerSecret_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The name or ARN of the secret.
	SecretId *string
	// Optional: The key to extract from the secret JSON.
	JsonKey *string
	// Optional: The version stage (defaults to AWSCURRENT).
	VersionStage *string
	// Optional: The version ID.
	VersionId *string
	// Optional: The region. If not set, uses environment or profile.
	Region *string
	// Optional: Profile to use.
	Profile *string
}

func (b0 AwsSecretManagerSecret_builder) Build() *AwsSecretManagerSecret {
	m0 := &AwsSecretManagerSecret{}
	b, x := &b0, m0
	_, _ = b, x
	x.SecretId = b.SecretId
	x.JsonKey = b.JsonKey
	x.VersionStage = b.VersionStage
	x.VersionId = b.VersionId
	x.Region = b.Region
	x.Profile = b.Profile
	return m0
}

// VaultSecret defines the parameters for fetching a secret from HashiCorp Vault.
type VaultSecret struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The address of the Vault server (e.g., "https://vault.example.com").
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The token to authenticate with Vault.
	Token *SecretValue `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	// The path to the secret in Vault (e.g., "secret/data/my-app/db").
	Path *string `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	// The key of the secret to retrieve from the path.
	Key           *string `protobuf:"bytes,4,opt,name=key" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultSecret) Reset() {
	*x = VaultSecret{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSecret) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSecret) ProtoMessage() {}

func (x *VaultSecret) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *VaultSecret) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *VaultSecret) GetToken() *SecretValue {
	if x != nil {
		return x.Token
	}
	return nil
}

func (x *VaultSecret) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *VaultSecret) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *VaultSecret) SetAddress(v string) {
	x.Address = &v
}

func (x *VaultSecret) SetToken(v *SecretValue) {
	x.Token = v
}

func (x *VaultSecret) SetPath(v string) {
	x.Path = &v
}

func (x *VaultSecret) SetKey(v string) {
	x.Key = &v
}

func (x *VaultSecret) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *VaultSecret) HasToken() bool {
	if x == nil {
		return false
	}
	return x.Token != nil
}

func (x *VaultSecret) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *VaultSecret) HasKey() bool {
	if x == nil {
		return false
	}
	return x.Key != nil
}

func (x *VaultSecret) ClearAddress() {
	x.Address = nil
}

func (x *VaultSecret) ClearToken() {
	x.Token = nil
}

func (x *VaultSecret) ClearPath() {
	x.Path = nil
}

func (x *VaultSecret) ClearKey() {
	x.Key = nil
}

type VaultSecret_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The address of the Vault server (e.g., "https://vault.example.com").
	Address *string
	// The token to authenticate with Vault.
	Token *SecretValue
	// The path to the secret in Vault (e.g., "secret/data/my-app/db").
	Path *string
	// The key of the secret to retrieve from the path.
	Key *string
}

func (b0 VaultSecret_builder) Build() *VaultSecret {
	m0 := &VaultSecret{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.Token = b.Token
	x.Path = b.Path
	x.Key = b.Key
	return m0
}

// RemoteContent represents content that is fetched from a remote URL.
type RemoteContent struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	HttpUrl       *string                `protobuf:"bytes,1,opt,name=http_url,json=httpUrl" json:"http_url,omitempty"`
	Auth          *Authentication        `protobuf:"bytes,2,opt,name=auth" json:"auth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoteContent) Reset() {
	*x = RemoteContent{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteContent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteContent) ProtoMessage() {}

func (x *RemoteContent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *RemoteContent) GetHttpUrl() string {
	if x != nil && x.HttpUrl != nil {
		return *x.HttpUrl
	}
	return ""
}

func (x *RemoteContent) GetAuth() *Authentication {
	if x != nil {
		return x.Auth
	}
	return nil
}

func (x *RemoteContent) SetHttpUrl(v string) {
	x.HttpUrl = &v
}

func (x *RemoteContent) SetAuth(v *Authentication) {
	x.Auth = v
}

func (x *RemoteContent) HasHttpUrl() bool {
	if x == nil {
		return false
	}
	return x.HttpUrl != nil
}

func (x *RemoteContent) HasAuth() bool {
	if x == nil {
		return false
	}
	return x.Auth != nil
}

func (x *RemoteContent) ClearHttpUrl() {
	x.HttpUrl = nil
}

func (x *RemoteContent) ClearAuth() {
	x.Auth = nil
}

type RemoteContent_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	HttpUrl *string
	Auth    *Authentication
}

func (b0 RemoteContent_builder) Build() *RemoteContent {
	m0 := &RemoteContent{}
	b, x := &b0, m0
	_, _ = b, x
	x.HttpUrl = b.HttpUrl
	x.Auth = b.Auth
	return m0
}

// Authentication defines an authentication method that can be used for both
// incoming requests (validation) and outgoing requests (client).
type Authentication struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to AuthMethod:
	//
	//	*Authentication_ApiKey
	//	*Authentication_BearerToken
	//	*Authentication_BasicAuth
	//	*Authentication_Oauth2
	//	*Authentication_Oidc
	//	*Authentication_Mtls
	//	*Authentication_TrustedHeader
	AuthMethod    isAuthentication_AuthMethod `protobuf_oneof:"auth_method"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Authentication) Reset() {
	*x = Authentication{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Authentication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Authentication) ProtoMessage() {}

func (x *Authentication) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Authentication) GetAuthMethod() isAuthentication_AuthMethod {
	if x != nil {
		return x.AuthMethod
	}
	return nil
}

func (x *Authentication) GetApiKey() *APIKeyAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_ApiKey); ok {
			return x.ApiKey
		}
	}
	return nil
}

func (x *Authentication) GetBearerToken() *BearerTokenAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_BearerToken); ok {
			return x.BearerToken
		}
	}
	return nil
}

func (x *Authentication) GetBasicAuth() *BasicAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Authentication) GetOauth2() *OAuth2Auth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_Oauth2); ok {
			return x.Oauth2
		}
	}
	return nil
}

func (x *Authentication) GetOidc() *OIDCAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_Oidc); ok {
			return x.Oidc
		}
	}
	return nil
}

func (x *Authentication) GetMtls() *MTLSAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_Mtls); ok {
			return x.Mtls
		}
	}
	return nil
}

func (x *Authentication) GetTrustedHeader() *TrustedHeaderAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_TrustedHeader); ok {
			return x.TrustedHeader
		}
	}
	return nil
}

func (x *Authentication) SetApiKey(v *APIKeyAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_ApiKey{v}
}

func (x *Authentication) SetBearerToken(v *BearerTokenAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_BearerToken{v}
}

func (x *Authentication) SetBasicAuth(v *BasicAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_BasicAuth{v}
}

func (x *Authentication) SetOauth2(v *OAuth2Auth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_Oauth2{v}
}

func (x *Authentication) SetOidc(v *OIDCAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_Oidc{v}
}

func (x *Authentication) SetMtls(v *MTLSAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_Mtls{v}
}

func (x *Authentication) SetTrustedHeader(v *TrustedHeaderAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_TrustedHeader{v}
}

func (x *Authentication) HasAuthMethod() bool {
	if x == nil {
		return false
	}
	return x.AuthMethod != nil
}

func (x *Authentication) HasApiKey() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_ApiKey)
	return ok
}

func (x *Authentication) HasBearerToken() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_BearerToken)
	return ok
}

func (x *Authentication) HasBasicAuth() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_BasicAuth)
	return ok
}

func (x *Authentication) HasOauth2() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_Oauth2)
	return ok
}

func (x *Authentication) HasOidc() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_Oidc)
	return ok
}

func (x *Authentication) HasMtls() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_Mtls)
	return ok
}

func (x *Authentication) HasTrustedHeader() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_TrustedHeader)
	return ok
}

func (x *Authentication) ClearAuthMethod() {
	x.AuthMethod = nil
}

func (x *Authentication) ClearApiKey() {
	if _, ok := x.AuthMethod.(*Authentication_ApiKey); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearBearerToken() {
	if _, ok := x.AuthMethod.(*Authentication_BearerToken); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearBasicAuth() {
	if _, ok := x.AuthMethod.(*Authentication_BasicAuth); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearOauth2() {
	if _, ok := x.AuthMethod.(*Authentication_Oauth2); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearOidc() {
	if _, ok := x.AuthMethod.(*Authentication_Oidc); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearMtls() {
	if _, ok := x.AuthMethod.(*Authentication_Mtls); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearTrustedHeader() {
	if _, ok := x.AuthMethod.(*Authentication_TrustedHeader); ok {
		x.AuthMethod = nil
	}
}

const Authentication_AuthMethod_not_set_case case_Authentication_AuthMethod = 0
const Authentication_ApiKey_case case_Authentication_AuthMethod = 1
const Authentication_BearerToken_case case_Authentication_AuthMethod = 2
const Authentication_BasicAuth_case case_Authentication_AuthMethod = 3
const Authentication_Oauth2_case case_Authentication_AuthMethod = 4
const Authentication_Oidc_case case_Authentication_AuthMethod = 5
const Authentication_Mtls_case case_Authentication_AuthMethod = 6
const Authentication_TrustedHeader_case case_Authentication_AuthMethod = 7

func (x *Authentication) WhichAuthMethod() case_Authentication_AuthMethod {
	if x == nil {
		return Authentication_AuthMethod_not_set_case
	}
	switch x.AuthMethod.(type) {
	case *Authentication_ApiKey:
		return Authentication_ApiKey_case
	case *Authentication_BearerToken:
		return Authentication_BearerToken_case
	case *Authentication_BasicAuth:
		return Authentication_BasicAuth_case
	case *Authentication_Oauth2:
		return Authentication_Oauth2_case
	case *Authentication_Oidc:
		return Authentication_Oidc_case
	case *Authentication_Mtls:
		return Authentication_Mtls_case
	case *Authentication_TrustedHeader:
		return Authentication_TrustedHeader_case
	default:
		return Authentication_AuthMethod_not_set_case
	}
}

type Authentication_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof AuthMethod:
	ApiKey        *APIKeyAuth
	BearerToken   *BearerTokenAuth
	BasicAuth     *BasicAuth
	Oauth2        *OAuth2Auth
	Oidc          *OIDCAuth
	Mtls          *MTLSAuth
	TrustedHeader *TrustedHeaderAuth
	// -- end of AuthMethod
}

func (b0 Authentication_builder) Build() *Authentication {
	m0 := &Authentication{}
	b, x := &b0, m0
	_, _ = b, x
	if b.ApiKey != nil {
		x.AuthMethod = &Authentication_ApiKey{b.ApiKey}
	}
	if b.BearerToken != nil {
		x.AuthMethod = &Authentication_BearerToken{b.BearerToken}
	}
	if b.BasicAuth != nil {
		x.AuthMethod = &Authentication_BasicAuth{b.BasicAuth}
	}
	if b.Oauth2 != nil {
		x.AuthMethod = &Authentication_Oauth2{b.Oauth2}
	}
	if b.Oidc != nil {
		x.AuthMethod = &Authentication_Oidc{b.Oidc}
	}
	if b.Mtls != nil {
		x.AuthMethod = &Authentication_Mtls{b.Mtls}
	}
	if b.TrustedHeader != nil {
		x.AuthMethod = &Authentication_TrustedHeader{b.TrustedHeader}
	}
	return m0
}

type case_Authentication_AuthMethod protoreflect.FieldNumber

func (x case_Authentication_AuthMethod) String() string {
	md := file_proto_config_v1_auth_proto_msgTypes[4].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isAuthentication_AuthMethod interface {
	isAuthentication_AuthMethod()
}

type Authentication_ApiKey struct {
	ApiKey *APIKeyAuth `protobuf:"bytes,1,opt,name=api_key,oneof"`
}

type Authentication_BearerToken struct {
	BearerToken *BearerTokenAuth `protobuf:"bytes,2,opt,name=bearer_token,oneof"`
}

type Authentication_BasicAuth struct {
	BasicAuth *BasicAuth `protobuf:"bytes,3,opt,name=basic_auth,oneof"`
}

type Authentication_Oauth2 struct {
	Oauth2 *OAuth2Auth `protobuf:"bytes,4,opt,name=oauth2,oneof"`
}

type Authentication_Oidc struct {
	Oidc *OIDCAuth `protobuf:"bytes,5,opt,name=oidc,oneof"`
}

type Authentication_Mtls struct {
	Mtls *MTLSAuth `protobuf:"bytes,6,opt,name=mtls,oneof"`
}

type Authentication_TrustedHeader struct {
	TrustedHeader *TrustedHeaderAuth `protobuf:"bytes,7,opt,name=trusted_header,oneof"`
}

func (*Authentication_ApiKey) isAuthentication_AuthMethod() {}

func (*Authentication_BearerToken) isAuthentication_AuthMethod() {}

func (*Authentication_BasicAuth) isAuthentication_AuthMethod() {}

func (*Authentication_Oauth2) isAuthentication_AuthMethod() {}

func (*Authentication_Oidc) isAuthentication_AuthMethod() {}

func (*Authentication_Mtls) isAuthentication_AuthMethod() {}

func (*Authentication_TrustedHeader) isAuthentication_AuthMethod() {}

// APIKeyAuth defines authentication using an API key.
type APIKeyAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The name of the parameter carrying the key (e.g., "X-API-Key", "api_key").
	ParamName *string              `protobuf:"bytes,1,opt,name=param_name" json:"param_name,omitempty"`
	In        *APIKeyAuth_Location `protobuf:"varint,2,opt,name=in,enum=mcpany.config.v1.APIKeyAuth_Location" json:"in,omitempty"`
	// The API key value. Used for client authentication (outgoing).
	Value *SecretValue `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	// The expected API key value. Used for server validation (incoming).
	// This is a plain string because we compare against it.
	VerificationValue *string `protobuf:"bytes,4,opt,name=verification_value" json:"verification_value,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *APIKeyAuth) Reset() {
	*x = APIKeyAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APIKeyAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APIKeyAuth) ProtoMessage() {}

func (x *APIKeyAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *APIKeyAuth) GetParamName() string {
	if x != nil && x.ParamName != nil {
		return *x.ParamName
	}
	return ""
}

func (x *APIKeyAuth) GetIn() APIKeyAuth_Location {
	if x != nil && x.In != nil {
		return *x.In
	}
	return APIKeyAuth_HEADER
}

func (x *APIKeyAuth) GetValue() *SecretValue {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *APIKeyAuth) GetVerificationValue() string {
	if x != nil && x.VerificationValue != nil {
		return *x.VerificationValue
	}
	return ""
}

func (x *APIKeyAuth) SetParamName(v string) {
	x.ParamName = &v
}

func (x *APIKeyAuth) SetIn(v APIKeyAuth_Location) {
	x.In = &v
}

func (x *APIKeyAuth) SetValue(v *SecretValue) {
	x.Value = v
}

func (x *APIKeyAuth) SetVerificationValue(v string) {
	x.VerificationValue = &v
}

func (x *APIKeyAuth) HasParamName() bool {
	if x == nil {
		return false
	}
	return x.ParamName != nil
}

func (x *APIKeyAuth) HasIn() bool {
	if x == nil {
		return false
	}
	return x.In != nil
}

func (x *APIKeyAuth) HasValue() bool {
	if x == nil {
		return false
	}
	return x.Value != nil
}

func (x *APIKeyAuth) HasVerificationValue() bool {
	if x == nil {
		return false
	}
	return x.VerificationValue != nil
}

func (x *APIKeyAuth) ClearParamName() {
	x.ParamName = nil
}

func (x *APIKeyAuth) ClearIn() {
	x.In = nil
}

func (x *APIKeyAuth) ClearValue() {
	x.Value = nil
}

func (x *APIKeyAuth) ClearVerificationValue() {
	x.VerificationValue = nil
}

type APIKeyAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The name of the parameter carrying the key (e.g., "X-API-Key", "api_key").
	ParamName *string
	In        *APIKeyAuth_Location
	// The API key value. Used for client authentication (outgoing).
	Value *SecretValue
	// The expected API key value. Used for server validation (incoming).
	// This is a plain string because we compare against it.
	VerificationValue *string
}

func (b0 APIKeyAuth_builder) Build() *APIKeyAuth {
	m0 := &APIKeyAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.ParamName = b.ParamName
	x.In = b.In
	x.Value = b.Value
	x.VerificationValue = b.VerificationValue
	return m0
}

// BearerTokenAuth defines authentication using a bearer token.
type BearerTokenAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The bearer token.
	Token         *SecretValue `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BearerTokenAuth) Reset() {
	*x = BearerTokenAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BearerTokenAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BearerTokenAuth) ProtoMessage() {}

func (x *BearerTokenAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *BearerTokenAuth) GetToken() *SecretValue {
	if x != nil {
		return x.Token
	}
	return nil
}

func (x *BearerTokenAuth) SetToken(v *SecretValue) {
	x.Token = v
}

func (x *BearerTokenAuth) HasToken() bool {
	if x == nil {
		return false
	}
	return x.Token != nil
}

func (x *BearerTokenAuth) ClearToken() {
	x.Token = nil
}

type BearerTokenAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The bearer token.
	Token *SecretValue
}

func (b0 BearerTokenAuth_builder) Build() *BearerTokenAuth {
	m0 := &BearerTokenAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.Token = b.Token
	return m0
}

// BasicAuth defines authentication using a username and password.
type BasicAuth struct {
	state    protoimpl.MessageState `protogen:"hybrid.v1"`
	Username *string                `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// The password. Used for client authentication (outgoing).
	Password *SecretValue `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// The bcrypt hash of the password. Used for server validation (incoming).
	PasswordHash  *string `protobuf:"bytes,3,opt,name=password_hash" json:"password_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BasicAuth) Reset() {
	*x = BasicAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BasicAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BasicAuth) ProtoMessage() {}

func (x *BasicAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *BasicAuth) GetUsername() string {
	if x != nil && x.Username != nil {
		return *x.Username
	}
	return ""
}

func (x *BasicAuth) GetPassword() *SecretValue {
	if x != nil {
		return x.Password
	}
	return nil
}

func (x *BasicAuth) GetPasswordHash() string {
	if x != nil && x.PasswordHash != nil {
		return *x.PasswordHash
	}
	return ""
}

func (x *BasicAuth) SetUsername(v string) {
	x.Username = &v
}

func (x *BasicAuth) SetPassword(v *SecretValue) {
	x.Password = v
}

func (x *BasicAuth) SetPasswordHash(v string) {
	x.PasswordHash = &v
}

func (x *BasicAuth) HasUsername() bool {
	if x == nil {
		return false
	}
	return x.Username != nil
}

func (x *BasicAuth) HasPassword() bool {
	if x == nil {
		return false
	}
	return x.Password != nil
}

func (x *BasicAuth) HasPasswordHash() bool {
	if x == nil {
		return false
	}
	return x.PasswordHash != nil
}

func (x *BasicAuth) ClearUsername() {
	x.Username = nil
}

func (x *BasicAuth) ClearPassword() {
	x.Password = nil
}

func (x *BasicAuth) ClearPasswordHash() {
	x.PasswordHash = nil
}

type BasicAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Username *string
	// The password. Used for client authentication (outgoing).
	Password *SecretValue
	// The bcrypt hash of the password. Used for server validation (incoming).
	PasswordHash *string
}

func (b0 BasicAuth_builder) Build() *BasicAuth {
	m0 := &BasicAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.Username = b.Username
	x.Password = b.Password
	x.PasswordHash = b.PasswordHash
	return m0
}

// OAuth2Auth defines authentication using the OAuth 2.0 client credentials flow.
type OAuth2Auth struct {
	state        protoimpl.MessageState `protogen:"hybrid.v1"`
	TokenUrl     *string                `protobuf:"bytes,1,opt,name=token_url" json:"token_url,omitempty"`
	ClientId     *SecretValue           `protobuf:"bytes,2,opt,name=client_id" json:"client_id,omitempty"`
	ClientSecret *SecretValue           `protobuf:"bytes,3,opt,name=client_secret" json:"client_secret,omitempty"`
	// Space-delimited list of scopes.
	Scopes *string `protobuf:"bytes,4,opt,name=scopes" json:"scopes,omitempty"`
	// Issuer URL for validation/discovery.
	IssuerUrl *string `protobuf:"bytes,5,opt,name=issuer_url" json:"issuer_url,omitempty"`
	// Audience for validation.
	Audience *string `protobuf:"bytes,6,opt,name=audience" json:"audience,omitempty"`
	// Authorization URL (optional, mainly for 3-legged flows if we ever support them).
	AuthorizationUrl *string `protobuf:"bytes,7,opt,name=authorization_url" json:"authorization_url,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *OAuth2Auth) Reset() {
	*x = OAuth2Auth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OAuth2Auth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OAuth2Auth) ProtoMessage() {}

func (x *OAuth2Auth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OAuth2Auth) GetTokenUrl() string {
	if x != nil && x.TokenUrl != nil {
		return *x.TokenUrl
	}
	return ""
}

func (x *OAuth2Auth) GetClientId() *SecretValue {
	if x != nil {
		return x.ClientId
	}
	return nil
}

func (x *OAuth2Auth) GetClientSecret() *SecretValue {
	if x != nil {
		return x.ClientSecret
	}
	return nil
}

func (x *OAuth2Auth) GetScopes() string {
	if x != nil && x.Scopes != nil {
		return *x.Scopes
	}
	return ""
}

func (x *OAuth2Auth) GetIssuerUrl() string {
	if x != nil && x.IssuerUrl != nil {
		return *x.IssuerUrl
	}
	return ""
}

func (x *OAuth2Auth) GetAudience() string {
	if x != nil && x.Audience != nil {
		return *x.Audience
	}
	return ""
}

func (x *OAuth2Auth) GetAuthorizationUrl() string {
	if x != nil && x.AuthorizationUrl != nil {
		return *x.AuthorizationUrl
	}
	return ""
}

func (x *OAuth2Auth) SetTokenUrl(v string) {
	x.TokenUrl = &v
}

func (x *OAuth2Auth) SetClientId(v *SecretValue) {
	x.ClientId = v
}

func (x *OAuth2Auth) SetClientSecret(v *SecretValue) {
	x.ClientSecret = v
}

func (x *OAuth2Auth) SetScopes(v string) {
	x.Scopes = &v
}

func (x *OAuth2Auth) SetIssuerUrl(v string) {
	x.IssuerUrl = &v
}

func (x *OAuth2Auth) SetAudience(v string) {
	x.Audience = &v
}

func (x *OAuth2Auth) SetAuthorizationUrl(v string) {
	x.AuthorizationUrl = &v
}

func (x *OAuth2Auth) HasTokenUrl() bool {
	if x == nil {
		return false
	}
	return x.TokenUrl != nil
}

func (x *OAuth2Auth) HasClientId() bool {
	if x == nil {
		return false
	}
	return x.ClientId != nil
}

func (x *OAuth2Auth) HasClientSecret() bool {
	if x == nil {
		return false
	}
	return x.ClientSecret != nil
}

func (x *OAuth2Auth) HasScopes() bool {
	if x == nil {
		return false
	}
	return x.Scopes != nil
}

func (x *OAuth2Auth) HasIssuerUrl() bool {
	if x == nil {
		return false
	}
	return x.IssuerUrl != nil
}

func (x *OAuth2Auth) HasAudience() bool {
	if x == nil {
		return false
	}
	return x.Audience != nil
}

func (x *OAuth2Auth) HasAuthorizationUrl() bool {
	if x == nil {
		return false
	}
	return x.AuthorizationUrl != nil
}

func (x *OAuth2Auth) ClearTokenUrl() {
	x.TokenUrl = nil
}

func (x *OAuth2Auth) ClearClientId() {
	x.ClientId = nil
}

func (x *OAuth2Auth) ClearClientSecret() {
	x.ClientSecret = nil
}

func (x *OAuth2Auth) ClearScopes() {
	x.Scopes = nil
}

func (x *OAuth2Auth) ClearIssuerUrl() {
	x.IssuerUrl = nil
}

func (x *OAuth2Auth) ClearAudience() {
	x.Audience = nil
}

func (x *OAuth2Auth) ClearAuthorizationUrl() {
	x.AuthorizationUrl = nil
}

type OAuth2Auth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	TokenUrl     *string
	ClientId     *SecretValue
	ClientSecret *SecretValue
	// Space-delimited list of scopes.
	Scopes *string
	// Issuer URL for validation/discovery.
	IssuerUrl *string
	// Audience for validation.
	Audience *string
	// Authorization URL (optional, mainly for 3-legged flows if we ever support them).
	AuthorizationUrl *string
}

func (b0 OAuth2Auth_builder) Build() *OAuth2Auth {
	m0 := &OAuth2Auth{}
	b, x := &b0, m0
	_, _ = b, x
	x.TokenUrl = b.TokenUrl
	x.ClientId = b.ClientId
	x.ClientSecret = b.ClientSecret
	x.Scopes = b.Scopes
	x.IssuerUrl = b.IssuerUrl
	x.Audience = b.Audience
	x.AuthorizationUrl = b.AuthorizationUrl
	return m0
}

// OIDCAuth defines authentication using OpenID Connect.
type OIDCAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The issuer URL.
	Issuer *string `protobuf:"bytes,1,opt,name=issuer" json:"issuer,omitempty"`
	// The subject to validate (incoming).
	Subject *string `protobuf:"bytes,2,opt,name=subject" json:"subject,omitempty"`
	// The email to validate (incoming).
	Email *string `protobuf:"bytes,3,opt,name=email" json:"email,omitempty"`
	// The audience(s) to validate (incoming).
	Audience      []string `protobuf:"bytes,4,rep,name=audience" json:"audience,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OIDCAuth) Reset() {
	*x = OIDCAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OIDCAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OIDCAuth) ProtoMessage() {}

func (x *OIDCAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OIDCAuth) GetIssuer() string {
	if x != nil && x.Issuer != nil {
		return *x.Issuer
	}
	return ""
}

func (x *OIDCAuth) GetSubject() string {
	if x != nil && x.Subject != nil {
		return *x.Subject
	}
	return ""
}

func (x *OIDCAuth) GetEmail() string {
	if x != nil && x.Email != nil {
		return *x.Email
	}
	return ""
}

func (x *OIDCAuth) GetAudience() []string {
	if x != nil {
		return x.Audience
	}
	return nil
}

func (x *OIDCAuth) SetIssuer(v string) {
	x.Issuer = &v
}

func (x *OIDCAuth) SetSubject(v string) {
	x.Subject = &v
}

func (x *OIDCAuth) SetEmail(v string) {
	x.Email = &v
}

func (x *OIDCAuth) SetAudience(v []string) {
	x.Audience = v
}

func (x *OIDCAuth) HasIssuer() bool {
	if x == nil {
		return false
	}
	return x.Issuer != nil
}

func (x *OIDCAuth) HasSubject() bool {
	if x == nil {
		return false
	}
	return x.Subject != nil
}

func (x *OIDCAuth) HasEmail() bool {
	if x == nil {
		return false
	}
	return x.Email != nil
}

func (x *OIDCAuth) ClearIssuer() {
	x.Issuer = nil
}

func (x *OIDCAuth) ClearSubject() {
	x.Subject = nil
}

func (x *OIDCAuth) ClearEmail() {
	x.Email = nil
}

type OIDCAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The issuer URL.
	Issuer *string
	// The subject to validate (incoming).
	Subject *string
	// The email to validate (incoming).
	Email *string
	// The audience(s) to validate (incoming).
	Audience []string
}

func (b0 OIDCAuth_builder) Build() *OIDCAuth {
	m0 := &OIDCAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.Issuer = b.Issuer
	x.Subject = b.Subject
	x.Email = b.Email
	x.Audience = b.Audience
	return m0
}

// MTLSAuth defines authentication using mutual TLS.
type MTLSAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Path to the client certificate file.
	ClientCertPath *string `protobuf:"bytes,1,opt,name=client_cert_path" json:"client_cert_path,omitempty"`
	// Path to the client private key file.
	ClientKeyPath *string `protobuf:"bytes,2,opt,name=client_key_path" json:"client_key_path,omitempty"`
	// Path to the CA certificate file for verifying the server's certificate.
	CaCertPath    *string `protobuf:"bytes,3,opt,name=ca_cert_path" json:"ca_cert_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MTLSAuth) Reset() {
	*x = MTLSAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MTLSAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MTLSAuth) ProtoMessage() {}

func (x *MTLSAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *MTLSAuth) GetClientCertPath() string {
	if x != nil && x.ClientCertPath != nil {
		return *x.ClientCertPath
	}
	return ""
}

func (x *MTLSAuth) GetClientKeyPath() string {
	if x != nil && x.ClientKeyPath != nil {
		return *x.ClientKeyPath
	}
	return ""
}

func (x *MTLSAuth) GetCaCertPath() string {
	if x != nil && x.CaCertPath != nil {
		return *x.CaCertPath
	}
	return ""
}

func (x *MTLSAuth) SetClientCertPath(v string) {
	x.ClientCertPath = &v
}

func (x *MTLSAuth) SetClientKeyPath(v string) {
	x.ClientKeyPath = &v
}

func (x *MTLSAuth) SetCaCertPath(v string) {
	x.CaCertPath = &v
}

func (x *MTLSAuth) HasClientCertPath() bool {
	if x == nil {
		return false
	}
	return x.ClientCertPath != nil
}

func (x *MTLSAuth) HasClientKeyPath() bool {
	if x == nil {
		return false
	}
	return x.ClientKeyPath != nil
}

func (x *MTLSAuth) HasCaCertPath() bool {
	if x == nil {
		return false
	}
	return x.CaCertPath != nil
}

func (x *MTLSAuth) ClearClientCertPath() {
	x.ClientCertPath = nil
}

func (x *MTLSAuth) ClearClientKeyPath() {
	x.ClientKeyPath = nil
}

func (x *MTLSAuth) ClearCaCertPath() {
	x.CaCertPath = nil
}

type MTLSAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Path to the client certificate file.
	ClientCertPath *string
	// Path to the client private key file.
	ClientKeyPath *string
	// Path to the CA certificate file for verifying the server's certificate.
	CaCertPath *string
}

func (b0 MTLSAuth_builder) Build() *MTLSAuth {
	m0 := &MTLSAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.ClientCertPath = b.ClientCertPath
	x.ClientKeyPath = b.ClientKeyPath
	x.CaCertPath = b.CaCertPath
	return m0
}

// TrustedHeaderAuth defines authentication using a trusted header.
type TrustedHeaderAuth struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	HeaderName    *string                `protobuf:"bytes,1,opt,name=header_name" json:"header_name,omitempty"`
	HeaderValue   *string                `protobuf:"bytes,2,opt,name=header_value" json:"header_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TrustedHeaderAuth) Reset() {
	*x = TrustedHeaderAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TrustedHeaderAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TrustedHeaderAuth) ProtoMessage() {}

func (x *TrustedHeaderAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TrustedHeaderAuth) GetHeaderName() string {
	if x != nil && x.HeaderName != nil {
		return *x.HeaderName
	}
	return ""
}

func (x *TrustedHeaderAuth) GetHeaderValue() string {
	if x != nil && x.HeaderValue != nil {
		return *x.HeaderValue
	}
	return ""
}

func (x *TrustedHeaderAuth) SetHeaderName(v string) {
	x.HeaderName = &v
}

func (x *TrustedHeaderAuth) SetHeaderValue(v string) {
	x.HeaderValue = &v
}

func (x *TrustedHeaderAuth) HasHeaderName() bool {
	if x == nil {
		return false
	}
	return x.HeaderName != nil
}

func (x *TrustedHeaderAuth) HasHeaderValue() bool {
	if x == nil {
		return false
	}
	return x.HeaderValue != nil
}

func (x *TrustedHeaderAuth) ClearHeaderName() {
	x.HeaderName = nil
}

func (x *TrustedHeaderAuth) ClearHeaderValue() {
	x.HeaderValue = nil
}

type TrustedHeaderAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	HeaderName  *string
	HeaderValue *string
}

func (b0 TrustedHeaderAuth_builder) Build() *TrustedHeaderAuth {
	m0 := &TrustedHeaderAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.HeaderName = b.HeaderName
	x.HeaderValue = b.HeaderValue
	return m0
}

var File_proto_config_v1_auth_proto protoreflect.FileDescriptor

const file_proto_config_v1_auth_proto_rawDesc = "" +
	"\n" +
	"\x1aproto/config/v1/auth.proto\x12\x10mcpany.config.v1\"\xe6\x02\n" +
	"\vSecretValue\x12\x1f\n" +
	"\n" +
	"plain_text\x18\x01 \x01(\tH\x00R\tplainText\x123\n" +
	"\x14environment_variable\x18\x02 \x01(\tH\x00R\x13environmentVariable\x12\x1d\n" +
	"\tfile_path\x18\x03 \x01(\tH\x00R\bfilePath\x12H\n" +
	"\x0eremote_content\x18\x04 \x01(\v2\x1f.mcpany.config.v1.RemoteContentH\x00R\rremoteContent\x125\n" +
	"\x05vault\x18\x05 \x01(\v2\x1d.mcpany.config.v1.VaultSecretH\x00R\x05vault\x12X\n" +
	"\x12aws_secret_manager\x18\x06 \x01(\v2(.mcpany.config.v1.AwsSecretManagerSecretH\x00R\x10awsSecretManagerB\a\n" +
	"\x05value\"\xca\x01\n" +
	"\x16AwsSecretManagerSecret\x12\x1c\n" +
	"\tsecret_id\x18\x01 \x01(\tR\tsecret_id\x12\x1a\n" +
	"\bjson_key\x18\x02 \x01(\tR\bjson_key\x12$\n" +
	"\rversion_stage\x18\x03 \x01(\tR\rversion_stage\x12\x1e\n" +
	"\n" +
	"version_id\x18\x04 \x01(\tR\n" +
	"version_id\x12\x16\n" +
	"\x06region\x18\x05 \x01(\tR\x06region\x12\x18\n" +
	"\aprofile\x18\x06 \x01(\tR\aprofile\"\x82\x01\n" +
	"\vVaultSecret\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x123\n" +
	"\x05token\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05token\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12\x10\n" +
	"\x03key\x18\x04 \x01(\tR\x03key\"`\n" +
	"\rRemoteContent\x12\x19\n" +
	"\bhttp_url\x18\x01 \x01(\tR\ahttpUrl\x124\n" +
	"\x04auth\x18\x02 \x01(\v2 .mcpany.config.v1.AuthenticationR\x04auth\"\xcc\x03\n" +
	"\x0eAuthentication\x128\n" +
	"\aapi_key\x18\x01 \x01(\v2\x1c.mcpany.config.v1.APIKeyAuthH\x00R\aapi_key\x12G\n" +
	"\fbearer_token\x18\x02 \x01(\v2!.mcpany.config.v1.BearerTokenAuthH\x00R\fbearer_token\x12=\n" +
	"\n" +
	"basic_auth\x18\x03 \x01(\v2\x1b.mcpany.config.v1.BasicAuthH\x00R\n" +
	"basic_auth\x126\n" +
	"\x06oauth2\x18\x04 \x01(\v2\x1c.mcpany.config.v1.OAuth2AuthH\x00R\x06oauth2\x120\n" +
	"\x04oidc\x18\x05 \x01(\v2\x1a.mcpany.config.v1.OIDCAuthH\x00R\x04oidc\x120\n" +
	"\x04mtls\x18\x06 \x01(\v2\x1a.mcpany.config.v1.MTLSAuthH\x00R\x04mtls\x12M\n" +
	"\x0etrusted_header\x18\a \x01(\v2#.mcpany.config.v1.TrustedHeaderAuthH\x00R\x0etrusted_headerB\r\n" +
	"\vauth_method\"\xf7\x01\n" +
	"\n" +
	"APIKeyAuth\x12\x1e\n" +
	"\n" +
	"param_name\x18\x01 \x01(\tR\n" +
	"param_name\x125\n" +
	"\x02in\x18\x02 \x01(\x0e2%.mcpany.config.v1.APIKeyAuth.LocationR\x02in\x123\n" +
	"\x05value\x18\x03 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05value\x12.\n" +
	"\x12verification_value\x18\x04 \x01(\tR\x12verification_value\"-\n" +
	"\bLocation\x12\n" +
	"\n" +
	"\x06HEADER\x10\x00\x12\t\n" +
	"\x05QUERY\x10\x01\x12\n" +
	"\n" +
	"\x06COOKIE\x10\x02\"F\n" +
	"\x0fBearerTokenAuth\x123\n" +
	"\x05token\x18\x01 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05token\"\x88\x01\n" +
	"\tBasicAuth\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x129\n" +
	"\bpassword\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\bpassword\x12$\n" +
	"\rpassword_hash\x18\x03 \x01(\tR\rpassword_hash\"\xae\x02\n" +
	"\n" +
	"OAuth2Auth\x12\x1c\n" +
	"\ttoken_url\x18\x01 \x01(\tR\ttoken_url\x12;\n" +
	"\tclient_id\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\tclient_id\x12C\n" +
	"\rclient_secret\x18\x03 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\rclient_secret\x12\x16\n" +
	"\x06scopes\x18\x04 \x01(\tR\x06scopes\x12\x1e\n" +
	"\n" +
	"issuer_url\x18\x05 \x01(\tR\n" +
	"issuer_url\x12\x1a\n" +
	"\baudience\x18\x06 \x01(\tR\baudience\x12,\n" +
	"\x11authorization_url\x18\a \x01(\tR\x11authorization_url\"n\n" +
	"\bOIDCAuth\x12\x16\n" +
	"\x06issuer\x18\x01 \x01(\tR\x06issuer\x12\x18\n" +
	"\asubject\x18\x02 \x01(\tR\asubject\x12\x14\n" +
	"\x05email\x18\x03 \x01(\tR\x05email\x12\x1a\n" +
	"\baudience\x18\x04 \x03(\tR\baudience\"\x84\x01\n" +
	"\bMTLSAuth\x12*\n" +
	"\x10client_cert_path\x18\x01 \x01(\tR\x10client_cert_path\x12(\n" +
	"\x0fclient_key_path\x18\x02 \x01(\tR\x0fclient_key_path\x12\"\n" +
	"\fca_cert_path\x18\x03 \x01(\tR\fca_cert_path\"Y\n" +
	"\x11TrustedHeaderAuth\x12 \n" +
	"\vheader_name\x18\x01 \x01(\tR\vheader_name\x12\"\n" +
	"\fheader_value\x18\x02 \x01(\tR\fheader_valueB3B\tAuthProtoZ&github.com/mcpany/core/proto/config/v1b\beditionsp\xe8\a"

var file_proto_config_v1_auth_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_config_v1_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_proto_config_v1_auth_proto_goTypes = []any{
	(APIKeyAuth_Location)(0),       // 0: mcpany.config.v1.APIKeyAuth.Location
	(*SecretValue)(nil),            // 1: mcpany.config.v1.SecretValue
	(*AwsSecretManagerSecret)(nil), // 2: mcpany.config.v1.AwsSecretManagerSecret
	(*VaultSecret)(nil),            // 3: mcpany.config.v1.VaultSecret
	(*RemoteContent)(nil),          // 4: mcpany.config.v1.RemoteContent
	(*Authentication)(nil),         // 5: mcpany.config.v1.Authentication
	(*APIKeyAuth)(nil),             // 6: mcpany.config.v1.APIKeyAuth
	(*BearerTokenAuth)(nil),        // 7: mcpany.config.v1.BearerTokenAuth
	(*BasicAuth)(nil),              // 8: mcpany.config.v1.BasicAuth
	(*OAuth2Auth)(nil),             // 9: mcpany.config.v1.OAuth2Auth
	(*OIDCAuth)(nil),               // 10: mcpany.config.v1.OIDCAuth
	(*MTLSAuth)(nil),               // 11: mcpany.config.v1.MTLSAuth
	(*TrustedHeaderAuth)(nil),      // 12: mcpany.config.v1.TrustedHeaderAuth
}
var file_proto_config_v1_auth_proto_depIdxs = []int32{
	4,  // 0: mcpany.config.v1.SecretValue.remote_content:type_name -> mcpany.config.v1.RemoteContent
	3,  // 1: mcpany.config.v1.SecretValue.vault:type_name -> mcpany.config.v1.VaultSecret
	2,  // 2: mcpany.config.v1.SecretValue.aws_secret_manager:type_name -> mcpany.config.v1.AwsSecretManagerSecret
	1,  // 3: mcpany.config.v1.VaultSecret.token:type_name -> mcpany.config.v1.SecretValue
	5,  // 4: mcpany.config.v1.RemoteContent.auth:type_name -> mcpany.config.v1.Authentication
	6,  // 5: mcpany.config.v1.Authentication.api_key:type_name -> mcpany.config.v1.APIKeyAuth
	7,  // 6: mcpany.config.v1.Authentication.bearer_token:type_name -> mcpany.config.v1.BearerTokenAuth
	8,  // 7: mcpany.config.v1.Authentication.basic_auth:type_name -> mcpany.config.v1.BasicAuth
	9,  // 8: mcpany.config.v1.Authentication.oauth2:type_name -> mcpany.config.v1.OAuth2Auth
	10, // 9: mcpany.config.v1.Authentication.oidc:type_name -> mcpany.config.v1.OIDCAuth
	11, // 10: mcpany.config.v1.Authentication.mtls:type_name -> mcpany.config.v1.MTLSAuth
	12, // 11: mcpany.config.v1.Authentication.trusted_header:type_name -> mcpany.config.v1.TrustedHeaderAuth
	0,  // 12: mcpany.config.v1.APIKeyAuth.in:type_name -> mcpany.config.v1.APIKeyAuth.Location
	1,  // 13: mcpany.config.v1.APIKeyAuth.value:type_name -> mcpany.config.v1.SecretValue
	1,  // 14: mcpany.config.v1.BearerTokenAuth.token:type_name -> mcpany.config.v1.SecretValue
	1,  // 15: mcpany.config.v1.BasicAuth.password:type_name -> mcpany.config.v1.SecretValue
	1,  // 16: mcpany.config.v1.OAuth2Auth.client_id:type_name -> mcpany.config.v1.SecretValue
	1,  // 17: mcpany.config.v1.OAuth2Auth.client_secret:type_name -> mcpany.config.v1.SecretValue
	18, // [18:18] is the sub-list for method output_type
	18, // [18:18] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_proto_config_v1_auth_proto_init() }
func file_proto_config_v1_auth_proto_init() {
	if File_proto_config_v1_auth_proto != nil {
		return
	}
	file_proto_config_v1_auth_proto_msgTypes[0].OneofWrappers = []any{
		(*SecretValue_PlainText)(nil),
		(*SecretValue_EnvironmentVariable)(nil),
		(*SecretValue_FilePath)(nil),
		(*SecretValue_RemoteContent)(nil),
		(*SecretValue_Vault)(nil),
		(*SecretValue_AwsSecretManager)(nil),
	}
	file_proto_config_v1_auth_proto_msgTypes[4].OneofWrappers = []any{
		(*Authentication_ApiKey)(nil),
		(*Authentication_BearerToken)(nil),
		(*Authentication_BasicAuth)(nil),
		(*Authentication_Oauth2)(nil),
		(*Authentication_Oidc)(nil),
		(*Authentication_Mtls)(nil),
		(*Authentication_TrustedHeader)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_config_v1_auth_proto_rawDesc), len(file_proto_config_v1_auth_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_config_v1_auth_proto_goTypes,
		DependencyIndexes: file_proto_config_v1_auth_proto_depIdxs,
		EnumInfos:         file_proto_config_v1_auth_proto_enumTypes,
		MessageInfos:      file_proto_config_v1_auth_proto_msgTypes,
	}.Build()
	File_proto_config_v1_auth_proto = out.File
	file_proto_config_v1_auth_proto_goTypes = nil
	file_proto_config_v1_auth_proto_depIdxs = nil
}
