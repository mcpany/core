// Copyright 2025 Author(s) of MCP Any
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.1
// source: proto/config/v1/auth.proto

//go:build !protoopaque

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Where the API key is located.
type APIKeyAuth_Location int32

const (
	APIKeyAuth_HEADER APIKeyAuth_Location = 0
	APIKeyAuth_QUERY  APIKeyAuth_Location = 1
)

// Enum value maps for APIKeyAuth_Location.
var (
	APIKeyAuth_Location_name = map[int32]string{
		0: "HEADER",
		1: "QUERY",
	}
	APIKeyAuth_Location_value = map[string]int32{
		"HEADER": 0,
		"QUERY":  1,
	}
)

func (x APIKeyAuth_Location) Enum() *APIKeyAuth_Location {
	p := new(APIKeyAuth_Location)
	*p = x
	return p
}

func (x APIKeyAuth_Location) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (APIKeyAuth_Location) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_auth_proto_enumTypes[0].Descriptor()
}

func (APIKeyAuth_Location) Type() protoreflect.EnumType {
	return &file_proto_config_v1_auth_proto_enumTypes[0]
}

func (x APIKeyAuth_Location) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// SecretValue represents a value that should be treated as a secret.
// It can be a plain text value, an environment variable, a file path, or content fetched from a remote URL.
type SecretValue struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*SecretValue_PlainText
	//	*SecretValue_EnvironmentVariable
	//	*SecretValue_FilePath
	//	*SecretValue_RemoteContent
	//	*SecretValue_Vault
	//	*SecretValue_AwsSecretManager
	Value         isSecretValue_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretValue) Reset() {
	*x = SecretValue{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretValue) ProtoMessage() {}

func (x *SecretValue) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SecretValue) GetValue() isSecretValue_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *SecretValue) GetPlainText() string {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_PlainText); ok {
			return x.PlainText
		}
	}
	return ""
}

func (x *SecretValue) GetEnvironmentVariable() string {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_EnvironmentVariable); ok {
			return x.EnvironmentVariable
		}
	}
	return ""
}

func (x *SecretValue) GetFilePath() string {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_FilePath); ok {
			return x.FilePath
		}
	}
	return ""
}

func (x *SecretValue) GetRemoteContent() *RemoteContent {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_RemoteContent); ok {
			return x.RemoteContent
		}
	}
	return nil
}

func (x *SecretValue) GetVault() *VaultSecret {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_Vault); ok {
			return x.Vault
		}
	}
	return nil
}

func (x *SecretValue) GetAwsSecretManager() *AwsSecretManagerSecret {
	if x != nil {
		if x, ok := x.Value.(*SecretValue_AwsSecretManager); ok {
			return x.AwsSecretManager
		}
	}
	return nil
}

func (x *SecretValue) SetPlainText(v string) {
	x.Value = &SecretValue_PlainText{v}
}

func (x *SecretValue) SetEnvironmentVariable(v string) {
	x.Value = &SecretValue_EnvironmentVariable{v}
}

func (x *SecretValue) SetFilePath(v string) {
	x.Value = &SecretValue_FilePath{v}
}

func (x *SecretValue) SetRemoteContent(v *RemoteContent) {
	if v == nil {
		x.Value = nil
		return
	}
	x.Value = &SecretValue_RemoteContent{v}
}

func (x *SecretValue) SetVault(v *VaultSecret) {
	if v == nil {
		x.Value = nil
		return
	}
	x.Value = &SecretValue_Vault{v}
}

func (x *SecretValue) SetAwsSecretManager(v *AwsSecretManagerSecret) {
	if v == nil {
		x.Value = nil
		return
	}
	x.Value = &SecretValue_AwsSecretManager{v}
}

func (x *SecretValue) HasValue() bool {
	if x == nil {
		return false
	}
	return x.Value != nil
}

func (x *SecretValue) HasPlainText() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_PlainText)
	return ok
}

func (x *SecretValue) HasEnvironmentVariable() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_EnvironmentVariable)
	return ok
}

func (x *SecretValue) HasFilePath() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_FilePath)
	return ok
}

func (x *SecretValue) HasRemoteContent() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_RemoteContent)
	return ok
}

func (x *SecretValue) HasVault() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_Vault)
	return ok
}

func (x *SecretValue) HasAwsSecretManager() bool {
	if x == nil {
		return false
	}
	_, ok := x.Value.(*SecretValue_AwsSecretManager)
	return ok
}

func (x *SecretValue) ClearValue() {
	x.Value = nil
}

func (x *SecretValue) ClearPlainText() {
	if _, ok := x.Value.(*SecretValue_PlainText); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearEnvironmentVariable() {
	if _, ok := x.Value.(*SecretValue_EnvironmentVariable); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearFilePath() {
	if _, ok := x.Value.(*SecretValue_FilePath); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearRemoteContent() {
	if _, ok := x.Value.(*SecretValue_RemoteContent); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearVault() {
	if _, ok := x.Value.(*SecretValue_Vault); ok {
		x.Value = nil
	}
}

func (x *SecretValue) ClearAwsSecretManager() {
	if _, ok := x.Value.(*SecretValue_AwsSecretManager); ok {
		x.Value = nil
	}
}

const SecretValue_Value_not_set_case case_SecretValue_Value = 0
const SecretValue_PlainText_case case_SecretValue_Value = 1
const SecretValue_EnvironmentVariable_case case_SecretValue_Value = 2
const SecretValue_FilePath_case case_SecretValue_Value = 3
const SecretValue_RemoteContent_case case_SecretValue_Value = 4
const SecretValue_Vault_case case_SecretValue_Value = 5
const SecretValue_AwsSecretManager_case case_SecretValue_Value = 6

func (x *SecretValue) WhichValue() case_SecretValue_Value {
	if x == nil {
		return SecretValue_Value_not_set_case
	}
	switch x.Value.(type) {
	case *SecretValue_PlainText:
		return SecretValue_PlainText_case
	case *SecretValue_EnvironmentVariable:
		return SecretValue_EnvironmentVariable_case
	case *SecretValue_FilePath:
		return SecretValue_FilePath_case
	case *SecretValue_RemoteContent:
		return SecretValue_RemoteContent_case
	case *SecretValue_Vault:
		return SecretValue_Vault_case
	case *SecretValue_AwsSecretManager:
		return SecretValue_AwsSecretManager_case
	default:
		return SecretValue_Value_not_set_case
	}
}

type SecretValue_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof Value:
	PlainText           *string
	EnvironmentVariable *string
	FilePath            *string
	RemoteContent       *RemoteContent
	Vault               *VaultSecret
	AwsSecretManager    *AwsSecretManagerSecret
	// -- end of Value
}

func (b0 SecretValue_builder) Build() *SecretValue {
	m0 := &SecretValue{}
	b, x := &b0, m0
	_, _ = b, x
	if b.PlainText != nil {
		x.Value = &SecretValue_PlainText{*b.PlainText}
	}
	if b.EnvironmentVariable != nil {
		x.Value = &SecretValue_EnvironmentVariable{*b.EnvironmentVariable}
	}
	if b.FilePath != nil {
		x.Value = &SecretValue_FilePath{*b.FilePath}
	}
	if b.RemoteContent != nil {
		x.Value = &SecretValue_RemoteContent{b.RemoteContent}
	}
	if b.Vault != nil {
		x.Value = &SecretValue_Vault{b.Vault}
	}
	if b.AwsSecretManager != nil {
		x.Value = &SecretValue_AwsSecretManager{b.AwsSecretManager}
	}
	return m0
}

type case_SecretValue_Value protoreflect.FieldNumber

func (x case_SecretValue_Value) String() string {
	md := file_proto_config_v1_auth_proto_msgTypes[0].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isSecretValue_Value interface {
	isSecretValue_Value()
}

type SecretValue_PlainText struct {
	PlainText string `protobuf:"bytes,1,opt,name=plain_text,json=plainText,oneof"`
}

type SecretValue_EnvironmentVariable struct {
	EnvironmentVariable string `protobuf:"bytes,2,opt,name=environment_variable,json=environmentVariable,oneof"`
}

type SecretValue_FilePath struct {
	FilePath string `protobuf:"bytes,3,opt,name=file_path,json=filePath,oneof"`
}

type SecretValue_RemoteContent struct {
	RemoteContent *RemoteContent `protobuf:"bytes,4,opt,name=remote_content,json=remoteContent,oneof"`
}

type SecretValue_Vault struct {
	Vault *VaultSecret `protobuf:"bytes,5,opt,name=vault,oneof"`
}

type SecretValue_AwsSecretManager struct {
	AwsSecretManager *AwsSecretManagerSecret `protobuf:"bytes,6,opt,name=aws_secret_manager,json=awsSecretManager,oneof"`
}

func (*SecretValue_PlainText) isSecretValue_Value() {}

func (*SecretValue_EnvironmentVariable) isSecretValue_Value() {}

func (*SecretValue_FilePath) isSecretValue_Value() {}

func (*SecretValue_RemoteContent) isSecretValue_Value() {}

func (*SecretValue_Vault) isSecretValue_Value() {}

func (*SecretValue_AwsSecretManager) isSecretValue_Value() {}

// AwsSecretManagerSecret defines the parameters for fetching a secret from AWS Secrets Manager.
type AwsSecretManagerSecret struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The name or ARN of the secret.
	SecretId *string `protobuf:"bytes,1,opt,name=secret_id" json:"secret_id,omitempty"`
	// Optional: The key to extract from the secret JSON.
	JsonKey *string `protobuf:"bytes,2,opt,name=json_key" json:"json_key,omitempty"`
	// Optional: The version stage (defaults to AWSCURRENT).
	VersionStage *string `protobuf:"bytes,3,opt,name=version_stage" json:"version_stage,omitempty"`
	// Optional: The version ID.
	VersionId *string `protobuf:"bytes,4,opt,name=version_id" json:"version_id,omitempty"`
	// Optional: The region. If not set, uses environment or profile.
	Region *string `protobuf:"bytes,5,opt,name=region" json:"region,omitempty"`
	// Optional: Profile to use.
	Profile       *string `protobuf:"bytes,6,opt,name=profile" json:"profile,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AwsSecretManagerSecret) Reset() {
	*x = AwsSecretManagerSecret{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AwsSecretManagerSecret) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AwsSecretManagerSecret) ProtoMessage() {}

func (x *AwsSecretManagerSecret) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AwsSecretManagerSecret) GetSecretId() string {
	if x != nil && x.SecretId != nil {
		return *x.SecretId
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetJsonKey() string {
	if x != nil && x.JsonKey != nil {
		return *x.JsonKey
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetVersionStage() string {
	if x != nil && x.VersionStage != nil {
		return *x.VersionStage
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetVersionId() string {
	if x != nil && x.VersionId != nil {
		return *x.VersionId
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetRegion() string {
	if x != nil && x.Region != nil {
		return *x.Region
	}
	return ""
}

func (x *AwsSecretManagerSecret) GetProfile() string {
	if x != nil && x.Profile != nil {
		return *x.Profile
	}
	return ""
}

func (x *AwsSecretManagerSecret) SetSecretId(v string) {
	x.SecretId = &v
}

func (x *AwsSecretManagerSecret) SetJsonKey(v string) {
	x.JsonKey = &v
}

func (x *AwsSecretManagerSecret) SetVersionStage(v string) {
	x.VersionStage = &v
}

func (x *AwsSecretManagerSecret) SetVersionId(v string) {
	x.VersionId = &v
}

func (x *AwsSecretManagerSecret) SetRegion(v string) {
	x.Region = &v
}

func (x *AwsSecretManagerSecret) SetProfile(v string) {
	x.Profile = &v
}

func (x *AwsSecretManagerSecret) HasSecretId() bool {
	if x == nil {
		return false
	}
	return x.SecretId != nil
}

func (x *AwsSecretManagerSecret) HasJsonKey() bool {
	if x == nil {
		return false
	}
	return x.JsonKey != nil
}

func (x *AwsSecretManagerSecret) HasVersionStage() bool {
	if x == nil {
		return false
	}
	return x.VersionStage != nil
}

func (x *AwsSecretManagerSecret) HasVersionId() bool {
	if x == nil {
		return false
	}
	return x.VersionId != nil
}

func (x *AwsSecretManagerSecret) HasRegion() bool {
	if x == nil {
		return false
	}
	return x.Region != nil
}

func (x *AwsSecretManagerSecret) HasProfile() bool {
	if x == nil {
		return false
	}
	return x.Profile != nil
}

func (x *AwsSecretManagerSecret) ClearSecretId() {
	x.SecretId = nil
}

func (x *AwsSecretManagerSecret) ClearJsonKey() {
	x.JsonKey = nil
}

func (x *AwsSecretManagerSecret) ClearVersionStage() {
	x.VersionStage = nil
}

func (x *AwsSecretManagerSecret) ClearVersionId() {
	x.VersionId = nil
}

func (x *AwsSecretManagerSecret) ClearRegion() {
	x.Region = nil
}

func (x *AwsSecretManagerSecret) ClearProfile() {
	x.Profile = nil
}

type AwsSecretManagerSecret_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The name or ARN of the secret.
	SecretId *string
	// Optional: The key to extract from the secret JSON.
	JsonKey *string
	// Optional: The version stage (defaults to AWSCURRENT).
	VersionStage *string
	// Optional: The version ID.
	VersionId *string
	// Optional: The region. If not set, uses environment or profile.
	Region *string
	// Optional: Profile to use.
	Profile *string
}

func (b0 AwsSecretManagerSecret_builder) Build() *AwsSecretManagerSecret {
	m0 := &AwsSecretManagerSecret{}
	b, x := &b0, m0
	_, _ = b, x
	x.SecretId = b.SecretId
	x.JsonKey = b.JsonKey
	x.VersionStage = b.VersionStage
	x.VersionId = b.VersionId
	x.Region = b.Region
	x.Profile = b.Profile
	return m0
}

// VaultSecret defines the parameters for fetching a secret from HashiCorp Vault.
type VaultSecret struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The address of the Vault server (e.g., "https://vault.example.com").
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The token to authenticate with Vault.
	Token *SecretValue `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	// The path to the secret in Vault (e.g., "secret/data/my-app/db").
	Path *string `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	// The key of the secret to retrieve from the path.
	Key           *string `protobuf:"bytes,4,opt,name=key" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VaultSecret) Reset() {
	*x = VaultSecret{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VaultSecret) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultSecret) ProtoMessage() {}

func (x *VaultSecret) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *VaultSecret) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *VaultSecret) GetToken() *SecretValue {
	if x != nil {
		return x.Token
	}
	return nil
}

func (x *VaultSecret) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *VaultSecret) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *VaultSecret) SetAddress(v string) {
	x.Address = &v
}

func (x *VaultSecret) SetToken(v *SecretValue) {
	x.Token = v
}

func (x *VaultSecret) SetPath(v string) {
	x.Path = &v
}

func (x *VaultSecret) SetKey(v string) {
	x.Key = &v
}

func (x *VaultSecret) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *VaultSecret) HasToken() bool {
	if x == nil {
		return false
	}
	return x.Token != nil
}

func (x *VaultSecret) HasPath() bool {
	if x == nil {
		return false
	}
	return x.Path != nil
}

func (x *VaultSecret) HasKey() bool {
	if x == nil {
		return false
	}
	return x.Key != nil
}

func (x *VaultSecret) ClearAddress() {
	x.Address = nil
}

func (x *VaultSecret) ClearToken() {
	x.Token = nil
}

func (x *VaultSecret) ClearPath() {
	x.Path = nil
}

func (x *VaultSecret) ClearKey() {
	x.Key = nil
}

type VaultSecret_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The address of the Vault server (e.g., "https://vault.example.com").
	Address *string
	// The token to authenticate with Vault.
	Token *SecretValue
	// The path to the secret in Vault (e.g., "secret/data/my-app/db").
	Path *string
	// The key of the secret to retrieve from the path.
	Key *string
}

func (b0 VaultSecret_builder) Build() *VaultSecret {
	m0 := &VaultSecret{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.Token = b.Token
	x.Path = b.Path
	x.Key = b.Key
	return m0
}

// RemoteContent represents content that is fetched from a remote URL.
type RemoteContent struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	HttpUrl       *string                `protobuf:"bytes,1,opt,name=http_url,json=httpUrl" json:"http_url,omitempty"`
	Auth          *Authentication        `protobuf:"bytes,2,opt,name=auth" json:"auth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoteContent) Reset() {
	*x = RemoteContent{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteContent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteContent) ProtoMessage() {}

func (x *RemoteContent) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *RemoteContent) GetHttpUrl() string {
	if x != nil && x.HttpUrl != nil {
		return *x.HttpUrl
	}
	return ""
}

func (x *RemoteContent) GetAuth() *Authentication {
	if x != nil {
		return x.Auth
	}
	return nil
}

func (x *RemoteContent) SetHttpUrl(v string) {
	x.HttpUrl = &v
}

func (x *RemoteContent) SetAuth(v *Authentication) {
	x.Auth = v
}

func (x *RemoteContent) HasHttpUrl() bool {
	if x == nil {
		return false
	}
	return x.HttpUrl != nil
}

func (x *RemoteContent) HasAuth() bool {
	if x == nil {
		return false
	}
	return x.Auth != nil
}

func (x *RemoteContent) ClearHttpUrl() {
	x.HttpUrl = nil
}

func (x *RemoteContent) ClearAuth() {
	x.Auth = nil
}

type RemoteContent_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	HttpUrl *string
	Auth    *Authentication
}

func (b0 RemoteContent_builder) Build() *RemoteContent {
	m0 := &RemoteContent{}
	b, x := &b0, m0
	_, _ = b, x
	x.HttpUrl = b.HttpUrl
	x.Auth = b.Auth
	return m0
}

// Authentication defines the authentication method to use when fetching remote content.
type Authentication struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to AuthMethod:
	//
	//	*Authentication_ApiKey
	//	*Authentication_BearerToken
	//	*Authentication_BasicAuth
	//	*Authentication_Oauth2
	AuthMethod    isAuthentication_AuthMethod `protobuf_oneof:"auth_method"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Authentication) Reset() {
	*x = Authentication{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Authentication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Authentication) ProtoMessage() {}

func (x *Authentication) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Authentication) GetAuthMethod() isAuthentication_AuthMethod {
	if x != nil {
		return x.AuthMethod
	}
	return nil
}

func (x *Authentication) GetApiKey() *UpstreamAPIKeyAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_ApiKey); ok {
			return x.ApiKey
		}
	}
	return nil
}

func (x *Authentication) GetBearerToken() *UpstreamBearerTokenAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_BearerToken); ok {
			return x.BearerToken
		}
	}
	return nil
}

func (x *Authentication) GetBasicAuth() *UpstreamBasicAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Authentication) GetOauth2() *UpstreamOAuth2Auth {
	if x != nil {
		if x, ok := x.AuthMethod.(*Authentication_Oauth2); ok {
			return x.Oauth2
		}
	}
	return nil
}

func (x *Authentication) SetApiKey(v *UpstreamAPIKeyAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_ApiKey{v}
}

func (x *Authentication) SetBearerToken(v *UpstreamBearerTokenAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_BearerToken{v}
}

func (x *Authentication) SetBasicAuth(v *UpstreamBasicAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_BasicAuth{v}
}

func (x *Authentication) SetOauth2(v *UpstreamOAuth2Auth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &Authentication_Oauth2{v}
}

func (x *Authentication) HasAuthMethod() bool {
	if x == nil {
		return false
	}
	return x.AuthMethod != nil
}

func (x *Authentication) HasApiKey() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_ApiKey)
	return ok
}

func (x *Authentication) HasBearerToken() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_BearerToken)
	return ok
}

func (x *Authentication) HasBasicAuth() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_BasicAuth)
	return ok
}

func (x *Authentication) HasOauth2() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*Authentication_Oauth2)
	return ok
}

func (x *Authentication) ClearAuthMethod() {
	x.AuthMethod = nil
}

func (x *Authentication) ClearApiKey() {
	if _, ok := x.AuthMethod.(*Authentication_ApiKey); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearBearerToken() {
	if _, ok := x.AuthMethod.(*Authentication_BearerToken); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearBasicAuth() {
	if _, ok := x.AuthMethod.(*Authentication_BasicAuth); ok {
		x.AuthMethod = nil
	}
}

func (x *Authentication) ClearOauth2() {
	if _, ok := x.AuthMethod.(*Authentication_Oauth2); ok {
		x.AuthMethod = nil
	}
}

const Authentication_AuthMethod_not_set_case case_Authentication_AuthMethod = 0
const Authentication_ApiKey_case case_Authentication_AuthMethod = 1
const Authentication_BearerToken_case case_Authentication_AuthMethod = 2
const Authentication_BasicAuth_case case_Authentication_AuthMethod = 3
const Authentication_Oauth2_case case_Authentication_AuthMethod = 5

func (x *Authentication) WhichAuthMethod() case_Authentication_AuthMethod {
	if x == nil {
		return Authentication_AuthMethod_not_set_case
	}
	switch x.AuthMethod.(type) {
	case *Authentication_ApiKey:
		return Authentication_ApiKey_case
	case *Authentication_BearerToken:
		return Authentication_BearerToken_case
	case *Authentication_BasicAuth:
		return Authentication_BasicAuth_case
	case *Authentication_Oauth2:
		return Authentication_Oauth2_case
	default:
		return Authentication_AuthMethod_not_set_case
	}
}

type Authentication_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof AuthMethod:
	ApiKey      *UpstreamAPIKeyAuth
	BearerToken *UpstreamBearerTokenAuth
	BasicAuth   *UpstreamBasicAuth
	Oauth2      *UpstreamOAuth2Auth
	// -- end of AuthMethod
}

func (b0 Authentication_builder) Build() *Authentication {
	m0 := &Authentication{}
	b, x := &b0, m0
	_, _ = b, x
	if b.ApiKey != nil {
		x.AuthMethod = &Authentication_ApiKey{b.ApiKey}
	}
	if b.BearerToken != nil {
		x.AuthMethod = &Authentication_BearerToken{b.BearerToken}
	}
	if b.BasicAuth != nil {
		x.AuthMethod = &Authentication_BasicAuth{b.BasicAuth}
	}
	if b.Oauth2 != nil {
		x.AuthMethod = &Authentication_Oauth2{b.Oauth2}
	}
	return m0
}

type case_Authentication_AuthMethod protoreflect.FieldNumber

func (x case_Authentication_AuthMethod) String() string {
	md := file_proto_config_v1_auth_proto_msgTypes[4].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isAuthentication_AuthMethod interface {
	isAuthentication_AuthMethod()
}

type Authentication_ApiKey struct {
	ApiKey *UpstreamAPIKeyAuth `protobuf:"bytes,1,opt,name=api_key,json=apiKey,oneof"`
}

type Authentication_BearerToken struct {
	BearerToken *UpstreamBearerTokenAuth `protobuf:"bytes,2,opt,name=bearer_token,json=bearerToken,oneof"`
}

type Authentication_BasicAuth struct {
	BasicAuth *UpstreamBasicAuth `protobuf:"bytes,3,opt,name=basic_auth,json=basicAuth,oneof"`
}

type Authentication_Oauth2 struct {
	Oauth2 *UpstreamOAuth2Auth `protobuf:"bytes,5,opt,name=oauth2,oneof"`
}

func (*Authentication_ApiKey) isAuthentication_AuthMethod() {}

func (*Authentication_BearerToken) isAuthentication_AuthMethod() {}

func (*Authentication_BasicAuth) isAuthentication_AuthMethod() {}

func (*Authentication_Oauth2) isAuthentication_AuthMethod() {}

// UpstreamAuthentication defines the authentication method to use when mcpany communicates
// with an upstream service.
type UpstreamAuthentication struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to AuthMethod:
	//
	//	*UpstreamAuthentication_ApiKey
	//	*UpstreamAuthentication_BearerToken
	//	*UpstreamAuthentication_BasicAuth
	//	*UpstreamAuthentication_Oauth2
	//	*UpstreamAuthentication_Mtls
	AuthMethod             isUpstreamAuthentication_AuthMethod `protobuf_oneof:"auth_method"`
	UseEnvironmentVariable *bool                               `protobuf:"varint,4,opt,name=use_environment_variable,json=useEnvironmentVariable" json:"use_environment_variable,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *UpstreamAuthentication) Reset() {
	*x = UpstreamAuthentication{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamAuthentication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamAuthentication) ProtoMessage() {}

func (x *UpstreamAuthentication) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamAuthentication) GetAuthMethod() isUpstreamAuthentication_AuthMethod {
	if x != nil {
		return x.AuthMethod
	}
	return nil
}

func (x *UpstreamAuthentication) GetApiKey() *UpstreamAPIKeyAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*UpstreamAuthentication_ApiKey); ok {
			return x.ApiKey
		}
	}
	return nil
}

func (x *UpstreamAuthentication) GetBearerToken() *UpstreamBearerTokenAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*UpstreamAuthentication_BearerToken); ok {
			return x.BearerToken
		}
	}
	return nil
}

func (x *UpstreamAuthentication) GetBasicAuth() *UpstreamBasicAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*UpstreamAuthentication_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *UpstreamAuthentication) GetOauth2() *UpstreamOAuth2Auth {
	if x != nil {
		if x, ok := x.AuthMethod.(*UpstreamAuthentication_Oauth2); ok {
			return x.Oauth2
		}
	}
	return nil
}

func (x *UpstreamAuthentication) GetMtls() *UpstreamMTLSAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*UpstreamAuthentication_Mtls); ok {
			return x.Mtls
		}
	}
	return nil
}

func (x *UpstreamAuthentication) GetUseEnvironmentVariable() bool {
	if x != nil && x.UseEnvironmentVariable != nil {
		return *x.UseEnvironmentVariable
	}
	return false
}

func (x *UpstreamAuthentication) SetApiKey(v *UpstreamAPIKeyAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &UpstreamAuthentication_ApiKey{v}
}

func (x *UpstreamAuthentication) SetBearerToken(v *UpstreamBearerTokenAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &UpstreamAuthentication_BearerToken{v}
}

func (x *UpstreamAuthentication) SetBasicAuth(v *UpstreamBasicAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &UpstreamAuthentication_BasicAuth{v}
}

func (x *UpstreamAuthentication) SetOauth2(v *UpstreamOAuth2Auth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &UpstreamAuthentication_Oauth2{v}
}

func (x *UpstreamAuthentication) SetMtls(v *UpstreamMTLSAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &UpstreamAuthentication_Mtls{v}
}

func (x *UpstreamAuthentication) SetUseEnvironmentVariable(v bool) {
	x.UseEnvironmentVariable = &v
}

func (x *UpstreamAuthentication) HasAuthMethod() bool {
	if x == nil {
		return false
	}
	return x.AuthMethod != nil
}

func (x *UpstreamAuthentication) HasApiKey() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*UpstreamAuthentication_ApiKey)
	return ok
}

func (x *UpstreamAuthentication) HasBearerToken() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*UpstreamAuthentication_BearerToken)
	return ok
}

func (x *UpstreamAuthentication) HasBasicAuth() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*UpstreamAuthentication_BasicAuth)
	return ok
}

func (x *UpstreamAuthentication) HasOauth2() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*UpstreamAuthentication_Oauth2)
	return ok
}

func (x *UpstreamAuthentication) HasMtls() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*UpstreamAuthentication_Mtls)
	return ok
}

func (x *UpstreamAuthentication) HasUseEnvironmentVariable() bool {
	if x == nil {
		return false
	}
	return x.UseEnvironmentVariable != nil
}

func (x *UpstreamAuthentication) ClearAuthMethod() {
	x.AuthMethod = nil
}

func (x *UpstreamAuthentication) ClearApiKey() {
	if _, ok := x.AuthMethod.(*UpstreamAuthentication_ApiKey); ok {
		x.AuthMethod = nil
	}
}

func (x *UpstreamAuthentication) ClearBearerToken() {
	if _, ok := x.AuthMethod.(*UpstreamAuthentication_BearerToken); ok {
		x.AuthMethod = nil
	}
}

func (x *UpstreamAuthentication) ClearBasicAuth() {
	if _, ok := x.AuthMethod.(*UpstreamAuthentication_BasicAuth); ok {
		x.AuthMethod = nil
	}
}

func (x *UpstreamAuthentication) ClearOauth2() {
	if _, ok := x.AuthMethod.(*UpstreamAuthentication_Oauth2); ok {
		x.AuthMethod = nil
	}
}

func (x *UpstreamAuthentication) ClearMtls() {
	if _, ok := x.AuthMethod.(*UpstreamAuthentication_Mtls); ok {
		x.AuthMethod = nil
	}
}

func (x *UpstreamAuthentication) ClearUseEnvironmentVariable() {
	x.UseEnvironmentVariable = nil
}

const UpstreamAuthentication_AuthMethod_not_set_case case_UpstreamAuthentication_AuthMethod = 0
const UpstreamAuthentication_ApiKey_case case_UpstreamAuthentication_AuthMethod = 1
const UpstreamAuthentication_BearerToken_case case_UpstreamAuthentication_AuthMethod = 2
const UpstreamAuthentication_BasicAuth_case case_UpstreamAuthentication_AuthMethod = 3
const UpstreamAuthentication_Oauth2_case case_UpstreamAuthentication_AuthMethod = 5
const UpstreamAuthentication_Mtls_case case_UpstreamAuthentication_AuthMethod = 6

func (x *UpstreamAuthentication) WhichAuthMethod() case_UpstreamAuthentication_AuthMethod {
	if x == nil {
		return UpstreamAuthentication_AuthMethod_not_set_case
	}
	switch x.AuthMethod.(type) {
	case *UpstreamAuthentication_ApiKey:
		return UpstreamAuthentication_ApiKey_case
	case *UpstreamAuthentication_BearerToken:
		return UpstreamAuthentication_BearerToken_case
	case *UpstreamAuthentication_BasicAuth:
		return UpstreamAuthentication_BasicAuth_case
	case *UpstreamAuthentication_Oauth2:
		return UpstreamAuthentication_Oauth2_case
	case *UpstreamAuthentication_Mtls:
		return UpstreamAuthentication_Mtls_case
	default:
		return UpstreamAuthentication_AuthMethod_not_set_case
	}
}

type UpstreamAuthentication_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof AuthMethod:
	ApiKey      *UpstreamAPIKeyAuth
	BearerToken *UpstreamBearerTokenAuth
	BasicAuth   *UpstreamBasicAuth
	Oauth2      *UpstreamOAuth2Auth
	Mtls        *UpstreamMTLSAuth
	// -- end of AuthMethod
	UseEnvironmentVariable *bool
}

func (b0 UpstreamAuthentication_builder) Build() *UpstreamAuthentication {
	m0 := &UpstreamAuthentication{}
	b, x := &b0, m0
	_, _ = b, x
	if b.ApiKey != nil {
		x.AuthMethod = &UpstreamAuthentication_ApiKey{b.ApiKey}
	}
	if b.BearerToken != nil {
		x.AuthMethod = &UpstreamAuthentication_BearerToken{b.BearerToken}
	}
	if b.BasicAuth != nil {
		x.AuthMethod = &UpstreamAuthentication_BasicAuth{b.BasicAuth}
	}
	if b.Oauth2 != nil {
		x.AuthMethod = &UpstreamAuthentication_Oauth2{b.Oauth2}
	}
	if b.Mtls != nil {
		x.AuthMethod = &UpstreamAuthentication_Mtls{b.Mtls}
	}
	x.UseEnvironmentVariable = b.UseEnvironmentVariable
	return m0
}

type case_UpstreamAuthentication_AuthMethod protoreflect.FieldNumber

func (x case_UpstreamAuthentication_AuthMethod) String() string {
	md := file_proto_config_v1_auth_proto_msgTypes[5].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isUpstreamAuthentication_AuthMethod interface {
	isUpstreamAuthentication_AuthMethod()
}

type UpstreamAuthentication_ApiKey struct {
	ApiKey *UpstreamAPIKeyAuth `protobuf:"bytes,1,opt,name=api_key,json=apiKey,oneof"`
}

type UpstreamAuthentication_BearerToken struct {
	BearerToken *UpstreamBearerTokenAuth `protobuf:"bytes,2,opt,name=bearer_token,json=bearerToken,oneof"`
}

type UpstreamAuthentication_BasicAuth struct {
	BasicAuth *UpstreamBasicAuth `protobuf:"bytes,3,opt,name=basic_auth,json=basicAuth,oneof"`
}

type UpstreamAuthentication_Oauth2 struct {
	Oauth2 *UpstreamOAuth2Auth `protobuf:"bytes,5,opt,name=oauth2,oneof"`
}

type UpstreamAuthentication_Mtls struct {
	Mtls *UpstreamMTLSAuth `protobuf:"bytes,6,opt,name=mtls,oneof"`
}

func (*UpstreamAuthentication_ApiKey) isUpstreamAuthentication_AuthMethod() {}

func (*UpstreamAuthentication_BearerToken) isUpstreamAuthentication_AuthMethod() {}

func (*UpstreamAuthentication_BasicAuth) isUpstreamAuthentication_AuthMethod() {}

func (*UpstreamAuthentication_Oauth2) isUpstreamAuthentication_AuthMethod() {}

func (*UpstreamAuthentication_Mtls) isUpstreamAuthentication_AuthMethod() {}

// UpstreamAPIKeyAuth defines authentication using an API key sent to an upstream.
type UpstreamAPIKeyAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The name of the header to carry the API key (e.g., "X-API-Key").
	HeaderName *string `protobuf:"bytes,1,opt,name=header_name,json=headerName" json:"header_name,omitempty"`
	// The API key value.
	ApiKey        *SecretValue `protobuf:"bytes,2,opt,name=api_key,json=apiKey" json:"api_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamAPIKeyAuth) Reset() {
	*x = UpstreamAPIKeyAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamAPIKeyAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamAPIKeyAuth) ProtoMessage() {}

func (x *UpstreamAPIKeyAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamAPIKeyAuth) GetHeaderName() string {
	if x != nil && x.HeaderName != nil {
		return *x.HeaderName
	}
	return ""
}

func (x *UpstreamAPIKeyAuth) GetApiKey() *SecretValue {
	if x != nil {
		return x.ApiKey
	}
	return nil
}

func (x *UpstreamAPIKeyAuth) SetHeaderName(v string) {
	x.HeaderName = &v
}

func (x *UpstreamAPIKeyAuth) SetApiKey(v *SecretValue) {
	x.ApiKey = v
}

func (x *UpstreamAPIKeyAuth) HasHeaderName() bool {
	if x == nil {
		return false
	}
	return x.HeaderName != nil
}

func (x *UpstreamAPIKeyAuth) HasApiKey() bool {
	if x == nil {
		return false
	}
	return x.ApiKey != nil
}

func (x *UpstreamAPIKeyAuth) ClearHeaderName() {
	x.HeaderName = nil
}

func (x *UpstreamAPIKeyAuth) ClearApiKey() {
	x.ApiKey = nil
}

type UpstreamAPIKeyAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The name of the header to carry the API key (e.g., "X-API-Key").
	HeaderName *string
	// The API key value.
	ApiKey *SecretValue
}

func (b0 UpstreamAPIKeyAuth_builder) Build() *UpstreamAPIKeyAuth {
	m0 := &UpstreamAPIKeyAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.HeaderName = b.HeaderName
	x.ApiKey = b.ApiKey
	return m0
}

// UpstreamBearerTokenAuth defines authentication using a bearer token.
type UpstreamBearerTokenAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The bearer token.
	Token         *SecretValue `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamBearerTokenAuth) Reset() {
	*x = UpstreamBearerTokenAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamBearerTokenAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamBearerTokenAuth) ProtoMessage() {}

func (x *UpstreamBearerTokenAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamBearerTokenAuth) GetToken() *SecretValue {
	if x != nil {
		return x.Token
	}
	return nil
}

func (x *UpstreamBearerTokenAuth) SetToken(v *SecretValue) {
	x.Token = v
}

func (x *UpstreamBearerTokenAuth) HasToken() bool {
	if x == nil {
		return false
	}
	return x.Token != nil
}

func (x *UpstreamBearerTokenAuth) ClearToken() {
	x.Token = nil
}

type UpstreamBearerTokenAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The bearer token.
	Token *SecretValue
}

func (b0 UpstreamBearerTokenAuth_builder) Build() *UpstreamBearerTokenAuth {
	m0 := &UpstreamBearerTokenAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.Token = b.Token
	return m0
}

// UpstreamBasicAuth defines authentication using a username and password.
type UpstreamBasicAuth struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Username      *string                `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	Password      *SecretValue           `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamBasicAuth) Reset() {
	*x = UpstreamBasicAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamBasicAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamBasicAuth) ProtoMessage() {}

func (x *UpstreamBasicAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamBasicAuth) GetUsername() string {
	if x != nil && x.Username != nil {
		return *x.Username
	}
	return ""
}

func (x *UpstreamBasicAuth) GetPassword() *SecretValue {
	if x != nil {
		return x.Password
	}
	return nil
}

func (x *UpstreamBasicAuth) SetUsername(v string) {
	x.Username = &v
}

func (x *UpstreamBasicAuth) SetPassword(v *SecretValue) {
	x.Password = v
}

func (x *UpstreamBasicAuth) HasUsername() bool {
	if x == nil {
		return false
	}
	return x.Username != nil
}

func (x *UpstreamBasicAuth) HasPassword() bool {
	if x == nil {
		return false
	}
	return x.Password != nil
}

func (x *UpstreamBasicAuth) ClearUsername() {
	x.Username = nil
}

func (x *UpstreamBasicAuth) ClearPassword() {
	x.Password = nil
}

type UpstreamBasicAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Username *string
	Password *SecretValue
}

func (b0 UpstreamBasicAuth_builder) Build() *UpstreamBasicAuth {
	m0 := &UpstreamBasicAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.Username = b.Username
	x.Password = b.Password
	return m0
}

// UpstreamOAuth2Auth defines authentication using the OAuth 2.0 client credentials flow.
type UpstreamOAuth2Auth struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	TokenUrl      *string                `protobuf:"bytes,1,opt,name=token_url,json=tokenUrl" json:"token_url,omitempty"`
	ClientId      *SecretValue           `protobuf:"bytes,2,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	ClientSecret  *SecretValue           `protobuf:"bytes,3,opt,name=client_secret,json=clientSecret" json:"client_secret,omitempty"`
	Scopes        *string                `protobuf:"bytes,4,opt,name=scopes" json:"scopes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamOAuth2Auth) Reset() {
	*x = UpstreamOAuth2Auth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamOAuth2Auth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamOAuth2Auth) ProtoMessage() {}

func (x *UpstreamOAuth2Auth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamOAuth2Auth) GetTokenUrl() string {
	if x != nil && x.TokenUrl != nil {
		return *x.TokenUrl
	}
	return ""
}

func (x *UpstreamOAuth2Auth) GetClientId() *SecretValue {
	if x != nil {
		return x.ClientId
	}
	return nil
}

func (x *UpstreamOAuth2Auth) GetClientSecret() *SecretValue {
	if x != nil {
		return x.ClientSecret
	}
	return nil
}

func (x *UpstreamOAuth2Auth) GetScopes() string {
	if x != nil && x.Scopes != nil {
		return *x.Scopes
	}
	return ""
}

func (x *UpstreamOAuth2Auth) SetTokenUrl(v string) {
	x.TokenUrl = &v
}

func (x *UpstreamOAuth2Auth) SetClientId(v *SecretValue) {
	x.ClientId = v
}

func (x *UpstreamOAuth2Auth) SetClientSecret(v *SecretValue) {
	x.ClientSecret = v
}

func (x *UpstreamOAuth2Auth) SetScopes(v string) {
	x.Scopes = &v
}

func (x *UpstreamOAuth2Auth) HasTokenUrl() bool {
	if x == nil {
		return false
	}
	return x.TokenUrl != nil
}

func (x *UpstreamOAuth2Auth) HasClientId() bool {
	if x == nil {
		return false
	}
	return x.ClientId != nil
}

func (x *UpstreamOAuth2Auth) HasClientSecret() bool {
	if x == nil {
		return false
	}
	return x.ClientSecret != nil
}

func (x *UpstreamOAuth2Auth) HasScopes() bool {
	if x == nil {
		return false
	}
	return x.Scopes != nil
}

func (x *UpstreamOAuth2Auth) ClearTokenUrl() {
	x.TokenUrl = nil
}

func (x *UpstreamOAuth2Auth) ClearClientId() {
	x.ClientId = nil
}

func (x *UpstreamOAuth2Auth) ClearClientSecret() {
	x.ClientSecret = nil
}

func (x *UpstreamOAuth2Auth) ClearScopes() {
	x.Scopes = nil
}

type UpstreamOAuth2Auth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	TokenUrl     *string
	ClientId     *SecretValue
	ClientSecret *SecretValue
	Scopes       *string
}

func (b0 UpstreamOAuth2Auth_builder) Build() *UpstreamOAuth2Auth {
	m0 := &UpstreamOAuth2Auth{}
	b, x := &b0, m0
	_, _ = b, x
	x.TokenUrl = b.TokenUrl
	x.ClientId = b.ClientId
	x.ClientSecret = b.ClientSecret
	x.Scopes = b.Scopes
	return m0
}

// UpstreamMTLSAuth defines authentication using mutual TLS.
type UpstreamMTLSAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Path to the client certificate file.
	ClientCertPath *string `protobuf:"bytes,1,opt,name=client_cert_path,json=clientCertPath" json:"client_cert_path,omitempty"`
	// Path to the client private key file.
	ClientKeyPath *string `protobuf:"bytes,2,opt,name=client_key_path,json=clientKeyPath" json:"client_key_path,omitempty"`
	// Path to the CA certificate file for verifying the server's certificate.
	CaCertPath    *string `protobuf:"bytes,3,opt,name=ca_cert_path,json=caCertPath" json:"ca_cert_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamMTLSAuth) Reset() {
	*x = UpstreamMTLSAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamMTLSAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamMTLSAuth) ProtoMessage() {}

func (x *UpstreamMTLSAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamMTLSAuth) GetClientCertPath() string {
	if x != nil && x.ClientCertPath != nil {
		return *x.ClientCertPath
	}
	return ""
}

func (x *UpstreamMTLSAuth) GetClientKeyPath() string {
	if x != nil && x.ClientKeyPath != nil {
		return *x.ClientKeyPath
	}
	return ""
}

func (x *UpstreamMTLSAuth) GetCaCertPath() string {
	if x != nil && x.CaCertPath != nil {
		return *x.CaCertPath
	}
	return ""
}

func (x *UpstreamMTLSAuth) SetClientCertPath(v string) {
	x.ClientCertPath = &v
}

func (x *UpstreamMTLSAuth) SetClientKeyPath(v string) {
	x.ClientKeyPath = &v
}

func (x *UpstreamMTLSAuth) SetCaCertPath(v string) {
	x.CaCertPath = &v
}

func (x *UpstreamMTLSAuth) HasClientCertPath() bool {
	if x == nil {
		return false
	}
	return x.ClientCertPath != nil
}

func (x *UpstreamMTLSAuth) HasClientKeyPath() bool {
	if x == nil {
		return false
	}
	return x.ClientKeyPath != nil
}

func (x *UpstreamMTLSAuth) HasCaCertPath() bool {
	if x == nil {
		return false
	}
	return x.CaCertPath != nil
}

func (x *UpstreamMTLSAuth) ClearClientCertPath() {
	x.ClientCertPath = nil
}

func (x *UpstreamMTLSAuth) ClearClientKeyPath() {
	x.ClientKeyPath = nil
}

func (x *UpstreamMTLSAuth) ClearCaCertPath() {
	x.CaCertPath = nil
}

type UpstreamMTLSAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Path to the client certificate file.
	ClientCertPath *string
	// Path to the client private key file.
	ClientKeyPath *string
	// Path to the CA certificate file for verifying the server's certificate.
	CaCertPath *string
}

func (b0 UpstreamMTLSAuth_builder) Build() *UpstreamMTLSAuth {
	m0 := &UpstreamMTLSAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.ClientCertPath = b.ClientCertPath
	x.ClientKeyPath = b.ClientKeyPath
	x.CaCertPath = b.CaCertPath
	return m0
}

// AuthenticationConfig specifies the authentication method to use.
type AuthenticationConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to AuthMethod:
	//
	//	*AuthenticationConfig_ApiKey
	//	*AuthenticationConfig_Oauth2
	//	*AuthenticationConfig_BasicAuth
	//	*AuthenticationConfig_Oidc
	//	*AuthenticationConfig_TrustedHeader
	AuthMethod    isAuthenticationConfig_AuthMethod `protobuf_oneof:"auth_method"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticationConfig) Reset() {
	*x = AuthenticationConfig{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticationConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticationConfig) ProtoMessage() {}

func (x *AuthenticationConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *AuthenticationConfig) GetAuthMethod() isAuthenticationConfig_AuthMethod {
	if x != nil {
		return x.AuthMethod
	}
	return nil
}

func (x *AuthenticationConfig) GetApiKey() *APIKeyAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*AuthenticationConfig_ApiKey); ok {
			return x.ApiKey
		}
	}
	return nil
}

func (x *AuthenticationConfig) GetOauth2() *OAuth2Auth {
	if x != nil {
		if x, ok := x.AuthMethod.(*AuthenticationConfig_Oauth2); ok {
			return x.Oauth2
		}
	}
	return nil
}

func (x *AuthenticationConfig) GetBasicAuth() *BasicAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*AuthenticationConfig_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *AuthenticationConfig) GetOidc() *OIDCAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*AuthenticationConfig_Oidc); ok {
			return x.Oidc
		}
	}
	return nil
}

func (x *AuthenticationConfig) GetTrustedHeader() *TrustedHeaderAuth {
	if x != nil {
		if x, ok := x.AuthMethod.(*AuthenticationConfig_TrustedHeader); ok {
			return x.TrustedHeader
		}
	}
	return nil
}

func (x *AuthenticationConfig) SetApiKey(v *APIKeyAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &AuthenticationConfig_ApiKey{v}
}

func (x *AuthenticationConfig) SetOauth2(v *OAuth2Auth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &AuthenticationConfig_Oauth2{v}
}

func (x *AuthenticationConfig) SetBasicAuth(v *BasicAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &AuthenticationConfig_BasicAuth{v}
}

func (x *AuthenticationConfig) SetOidc(v *OIDCAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &AuthenticationConfig_Oidc{v}
}

func (x *AuthenticationConfig) SetTrustedHeader(v *TrustedHeaderAuth) {
	if v == nil {
		x.AuthMethod = nil
		return
	}
	x.AuthMethod = &AuthenticationConfig_TrustedHeader{v}
}

func (x *AuthenticationConfig) HasAuthMethod() bool {
	if x == nil {
		return false
	}
	return x.AuthMethod != nil
}

func (x *AuthenticationConfig) HasApiKey() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*AuthenticationConfig_ApiKey)
	return ok
}

func (x *AuthenticationConfig) HasOauth2() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*AuthenticationConfig_Oauth2)
	return ok
}

func (x *AuthenticationConfig) HasBasicAuth() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*AuthenticationConfig_BasicAuth)
	return ok
}

func (x *AuthenticationConfig) HasOidc() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*AuthenticationConfig_Oidc)
	return ok
}

func (x *AuthenticationConfig) HasTrustedHeader() bool {
	if x == nil {
		return false
	}
	_, ok := x.AuthMethod.(*AuthenticationConfig_TrustedHeader)
	return ok
}

func (x *AuthenticationConfig) ClearAuthMethod() {
	x.AuthMethod = nil
}

func (x *AuthenticationConfig) ClearApiKey() {
	if _, ok := x.AuthMethod.(*AuthenticationConfig_ApiKey); ok {
		x.AuthMethod = nil
	}
}

func (x *AuthenticationConfig) ClearOauth2() {
	if _, ok := x.AuthMethod.(*AuthenticationConfig_Oauth2); ok {
		x.AuthMethod = nil
	}
}

func (x *AuthenticationConfig) ClearBasicAuth() {
	if _, ok := x.AuthMethod.(*AuthenticationConfig_BasicAuth); ok {
		x.AuthMethod = nil
	}
}

func (x *AuthenticationConfig) ClearOidc() {
	if _, ok := x.AuthMethod.(*AuthenticationConfig_Oidc); ok {
		x.AuthMethod = nil
	}
}

func (x *AuthenticationConfig) ClearTrustedHeader() {
	if _, ok := x.AuthMethod.(*AuthenticationConfig_TrustedHeader); ok {
		x.AuthMethod = nil
	}
}

const AuthenticationConfig_AuthMethod_not_set_case case_AuthenticationConfig_AuthMethod = 0
const AuthenticationConfig_ApiKey_case case_AuthenticationConfig_AuthMethod = 1
const AuthenticationConfig_Oauth2_case case_AuthenticationConfig_AuthMethod = 2
const AuthenticationConfig_BasicAuth_case case_AuthenticationConfig_AuthMethod = 3
const AuthenticationConfig_Oidc_case case_AuthenticationConfig_AuthMethod = 4
const AuthenticationConfig_TrustedHeader_case case_AuthenticationConfig_AuthMethod = 5

func (x *AuthenticationConfig) WhichAuthMethod() case_AuthenticationConfig_AuthMethod {
	if x == nil {
		return AuthenticationConfig_AuthMethod_not_set_case
	}
	switch x.AuthMethod.(type) {
	case *AuthenticationConfig_ApiKey:
		return AuthenticationConfig_ApiKey_case
	case *AuthenticationConfig_Oauth2:
		return AuthenticationConfig_Oauth2_case
	case *AuthenticationConfig_BasicAuth:
		return AuthenticationConfig_BasicAuth_case
	case *AuthenticationConfig_Oidc:
		return AuthenticationConfig_Oidc_case
	case *AuthenticationConfig_TrustedHeader:
		return AuthenticationConfig_TrustedHeader_case
	default:
		return AuthenticationConfig_AuthMethod_not_set_case
	}
}

type AuthenticationConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof AuthMethod:
	ApiKey        *APIKeyAuth
	Oauth2        *OAuth2Auth
	BasicAuth     *BasicAuth
	Oidc          *OIDCAuth
	TrustedHeader *TrustedHeaderAuth
	// -- end of AuthMethod
}

func (b0 AuthenticationConfig_builder) Build() *AuthenticationConfig {
	m0 := &AuthenticationConfig{}
	b, x := &b0, m0
	_, _ = b, x
	if b.ApiKey != nil {
		x.AuthMethod = &AuthenticationConfig_ApiKey{b.ApiKey}
	}
	if b.Oauth2 != nil {
		x.AuthMethod = &AuthenticationConfig_Oauth2{b.Oauth2}
	}
	if b.BasicAuth != nil {
		x.AuthMethod = &AuthenticationConfig_BasicAuth{b.BasicAuth}
	}
	if b.Oidc != nil {
		x.AuthMethod = &AuthenticationConfig_Oidc{b.Oidc}
	}
	if b.TrustedHeader != nil {
		x.AuthMethod = &AuthenticationConfig_TrustedHeader{b.TrustedHeader}
	}
	return m0
}

type case_AuthenticationConfig_AuthMethod protoreflect.FieldNumber

func (x case_AuthenticationConfig_AuthMethod) String() string {
	md := file_proto_config_v1_auth_proto_msgTypes[11].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isAuthenticationConfig_AuthMethod interface {
	isAuthenticationConfig_AuthMethod()
}

type AuthenticationConfig_ApiKey struct {
	ApiKey *APIKeyAuth `protobuf:"bytes,1,opt,name=api_key,oneof"`
}

type AuthenticationConfig_Oauth2 struct {
	Oauth2 *OAuth2Auth `protobuf:"bytes,2,opt,name=oauth2,oneof"`
}

type AuthenticationConfig_BasicAuth struct {
	BasicAuth *BasicAuth `protobuf:"bytes,3,opt,name=basic_auth,oneof"`
}

type AuthenticationConfig_Oidc struct {
	Oidc *OIDCAuth `protobuf:"bytes,4,opt,name=oidc,oneof"`
}

type AuthenticationConfig_TrustedHeader struct {
	TrustedHeader *TrustedHeaderAuth `protobuf:"bytes,5,opt,name=trusted_header,oneof"`
}

func (*AuthenticationConfig_ApiKey) isAuthenticationConfig_AuthMethod() {}

func (*AuthenticationConfig_Oauth2) isAuthenticationConfig_AuthMethod() {}

func (*AuthenticationConfig_BasicAuth) isAuthenticationConfig_AuthMethod() {}

func (*AuthenticationConfig_Oidc) isAuthenticationConfig_AuthMethod() {}

func (*AuthenticationConfig_TrustedHeader) isAuthenticationConfig_AuthMethod() {}

// BasicAuth defines authentication using a username and password.
// The password should be stored as a bcrypt hash.
type BasicAuth struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	PasswordHash  *string                `protobuf:"bytes,1,opt,name=password_hash" json:"password_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BasicAuth) Reset() {
	*x = BasicAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BasicAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BasicAuth) ProtoMessage() {}

func (x *BasicAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *BasicAuth) GetPasswordHash() string {
	if x != nil && x.PasswordHash != nil {
		return *x.PasswordHash
	}
	return ""
}

func (x *BasicAuth) SetPasswordHash(v string) {
	x.PasswordHash = &v
}

func (x *BasicAuth) HasPasswordHash() bool {
	if x == nil {
		return false
	}
	return x.PasswordHash != nil
}

func (x *BasicAuth) ClearPasswordHash() {
	x.PasswordHash = nil
}

type BasicAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	PasswordHash *string
}

func (b0 BasicAuth_builder) Build() *BasicAuth {
	m0 := &BasicAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.PasswordHash = b.PasswordHash
	return m0
}

// OIDCAuth defines authentication using OpenID Connect.
type OIDCAuth struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Issuer        *string                `protobuf:"bytes,1,opt,name=issuer" json:"issuer,omitempty"`
	Subject       *string                `protobuf:"bytes,2,opt,name=subject" json:"subject,omitempty"`
	Email         *string                `protobuf:"bytes,3,opt,name=email" json:"email,omitempty"`
	Audience      []string               `protobuf:"bytes,4,rep,name=audience" json:"audience,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OIDCAuth) Reset() {
	*x = OIDCAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OIDCAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OIDCAuth) ProtoMessage() {}

func (x *OIDCAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OIDCAuth) GetIssuer() string {
	if x != nil && x.Issuer != nil {
		return *x.Issuer
	}
	return ""
}

func (x *OIDCAuth) GetSubject() string {
	if x != nil && x.Subject != nil {
		return *x.Subject
	}
	return ""
}

func (x *OIDCAuth) GetEmail() string {
	if x != nil && x.Email != nil {
		return *x.Email
	}
	return ""
}

func (x *OIDCAuth) GetAudience() []string {
	if x != nil {
		return x.Audience
	}
	return nil
}

func (x *OIDCAuth) SetIssuer(v string) {
	x.Issuer = &v
}

func (x *OIDCAuth) SetSubject(v string) {
	x.Subject = &v
}

func (x *OIDCAuth) SetEmail(v string) {
	x.Email = &v
}

func (x *OIDCAuth) SetAudience(v []string) {
	x.Audience = v
}

func (x *OIDCAuth) HasIssuer() bool {
	if x == nil {
		return false
	}
	return x.Issuer != nil
}

func (x *OIDCAuth) HasSubject() bool {
	if x == nil {
		return false
	}
	return x.Subject != nil
}

func (x *OIDCAuth) HasEmail() bool {
	if x == nil {
		return false
	}
	return x.Email != nil
}

func (x *OIDCAuth) ClearIssuer() {
	x.Issuer = nil
}

func (x *OIDCAuth) ClearSubject() {
	x.Subject = nil
}

func (x *OIDCAuth) ClearEmail() {
	x.Email = nil
}

type OIDCAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Issuer   *string
	Subject  *string
	Email    *string
	Audience []string
}

func (b0 OIDCAuth_builder) Build() *OIDCAuth {
	m0 := &OIDCAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.Issuer = b.Issuer
	x.Subject = b.Subject
	x.Email = b.Email
	x.Audience = b.Audience
	return m0
}

// TrustedHeaderAuth defines authentication using a trusted header (e.g. from an auth proxy).
type TrustedHeaderAuth struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	HeaderName    *string                `protobuf:"bytes,1,opt,name=header_name" json:"header_name,omitempty"`
	HeaderValue   *string                `protobuf:"bytes,2,opt,name=header_value" json:"header_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TrustedHeaderAuth) Reset() {
	*x = TrustedHeaderAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TrustedHeaderAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TrustedHeaderAuth) ProtoMessage() {}

func (x *TrustedHeaderAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TrustedHeaderAuth) GetHeaderName() string {
	if x != nil && x.HeaderName != nil {
		return *x.HeaderName
	}
	return ""
}

func (x *TrustedHeaderAuth) GetHeaderValue() string {
	if x != nil && x.HeaderValue != nil {
		return *x.HeaderValue
	}
	return ""
}

func (x *TrustedHeaderAuth) SetHeaderName(v string) {
	x.HeaderName = &v
}

func (x *TrustedHeaderAuth) SetHeaderValue(v string) {
	x.HeaderValue = &v
}

func (x *TrustedHeaderAuth) HasHeaderName() bool {
	if x == nil {
		return false
	}
	return x.HeaderName != nil
}

func (x *TrustedHeaderAuth) HasHeaderValue() bool {
	if x == nil {
		return false
	}
	return x.HeaderValue != nil
}

func (x *TrustedHeaderAuth) ClearHeaderName() {
	x.HeaderName = nil
}

func (x *TrustedHeaderAuth) ClearHeaderValue() {
	x.HeaderValue = nil
}

type TrustedHeaderAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	HeaderName  *string
	HeaderValue *string
}

func (b0 TrustedHeaderAuth_builder) Build() *TrustedHeaderAuth {
	m0 := &TrustedHeaderAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.HeaderName = b.HeaderName
	x.HeaderValue = b.HeaderValue
	return m0
}

// APIKeyAuth defines authentication using an API key.
type APIKeyAuth struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The name of the parameter carrying the key (e.g., "X-API-Key", "api_key").
	ParamName *string              `protobuf:"bytes,1,opt,name=param_name" json:"param_name,omitempty"`
	In        *APIKeyAuth_Location `protobuf:"varint,2,opt,name=in,enum=mcpany.config.v1.APIKeyAuth_Location" json:"in,omitempty"`
	// The actual API key value. It's recommended to use a secret management system.
	KeyValue      *string `protobuf:"bytes,3,opt,name=key_value" json:"key_value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *APIKeyAuth) Reset() {
	*x = APIKeyAuth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APIKeyAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APIKeyAuth) ProtoMessage() {}

func (x *APIKeyAuth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *APIKeyAuth) GetParamName() string {
	if x != nil && x.ParamName != nil {
		return *x.ParamName
	}
	return ""
}

func (x *APIKeyAuth) GetIn() APIKeyAuth_Location {
	if x != nil && x.In != nil {
		return *x.In
	}
	return APIKeyAuth_HEADER
}

func (x *APIKeyAuth) GetKeyValue() string {
	if x != nil && x.KeyValue != nil {
		return *x.KeyValue
	}
	return ""
}

func (x *APIKeyAuth) SetParamName(v string) {
	x.ParamName = &v
}

func (x *APIKeyAuth) SetIn(v APIKeyAuth_Location) {
	x.In = &v
}

func (x *APIKeyAuth) SetKeyValue(v string) {
	x.KeyValue = &v
}

func (x *APIKeyAuth) HasParamName() bool {
	if x == nil {
		return false
	}
	return x.ParamName != nil
}

func (x *APIKeyAuth) HasIn() bool {
	if x == nil {
		return false
	}
	return x.In != nil
}

func (x *APIKeyAuth) HasKeyValue() bool {
	if x == nil {
		return false
	}
	return x.KeyValue != nil
}

func (x *APIKeyAuth) ClearParamName() {
	x.ParamName = nil
}

func (x *APIKeyAuth) ClearIn() {
	x.In = nil
}

func (x *APIKeyAuth) ClearKeyValue() {
	x.KeyValue = nil
}

type APIKeyAuth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The name of the parameter carrying the key (e.g., "X-API-Key", "api_key").
	ParamName *string
	In        *APIKeyAuth_Location
	// The actual API key value. It's recommended to use a secret management system.
	KeyValue *string
}

func (b0 APIKeyAuth_builder) Build() *APIKeyAuth {
	m0 := &APIKeyAuth{}
	b, x := &b0, m0
	_, _ = b, x
	x.ParamName = b.ParamName
	x.In = b.In
	x.KeyValue = b.KeyValue
	return m0
}

// OAuth2Auth defines authentication using the OAuth 2.0 client credentials flow.
type OAuth2Auth struct {
	state            protoimpl.MessageState `protogen:"hybrid.v1"`
	TokenUrl         *string                `protobuf:"bytes,3,opt,name=token_url,json=tokenUrl" json:"token_url,omitempty"`
	AuthorizationUrl *string                `protobuf:"bytes,4,opt,name=authorization_url,json=authorizationUrl" json:"authorization_url,omitempty"`
	// Space-delimited list of scopes.
	Scopes        *string `protobuf:"bytes,5,opt,name=scopes" json:"scopes,omitempty"`
	IssuerUrl     *string `protobuf:"bytes,6,opt,name=issuer_url,json=issuerUrl" json:"issuer_url,omitempty"`
	Audience      *string `protobuf:"bytes,7,opt,name=audience" json:"audience,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OAuth2Auth) Reset() {
	*x = OAuth2Auth{}
	mi := &file_proto_config_v1_auth_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OAuth2Auth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OAuth2Auth) ProtoMessage() {}

func (x *OAuth2Auth) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_auth_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OAuth2Auth) GetTokenUrl() string {
	if x != nil && x.TokenUrl != nil {
		return *x.TokenUrl
	}
	return ""
}

func (x *OAuth2Auth) GetAuthorizationUrl() string {
	if x != nil && x.AuthorizationUrl != nil {
		return *x.AuthorizationUrl
	}
	return ""
}

func (x *OAuth2Auth) GetScopes() string {
	if x != nil && x.Scopes != nil {
		return *x.Scopes
	}
	return ""
}

func (x *OAuth2Auth) GetIssuerUrl() string {
	if x != nil && x.IssuerUrl != nil {
		return *x.IssuerUrl
	}
	return ""
}

func (x *OAuth2Auth) GetAudience() string {
	if x != nil && x.Audience != nil {
		return *x.Audience
	}
	return ""
}

func (x *OAuth2Auth) SetTokenUrl(v string) {
	x.TokenUrl = &v
}

func (x *OAuth2Auth) SetAuthorizationUrl(v string) {
	x.AuthorizationUrl = &v
}

func (x *OAuth2Auth) SetScopes(v string) {
	x.Scopes = &v
}

func (x *OAuth2Auth) SetIssuerUrl(v string) {
	x.IssuerUrl = &v
}

func (x *OAuth2Auth) SetAudience(v string) {
	x.Audience = &v
}

func (x *OAuth2Auth) HasTokenUrl() bool {
	if x == nil {
		return false
	}
	return x.TokenUrl != nil
}

func (x *OAuth2Auth) HasAuthorizationUrl() bool {
	if x == nil {
		return false
	}
	return x.AuthorizationUrl != nil
}

func (x *OAuth2Auth) HasScopes() bool {
	if x == nil {
		return false
	}
	return x.Scopes != nil
}

func (x *OAuth2Auth) HasIssuerUrl() bool {
	if x == nil {
		return false
	}
	return x.IssuerUrl != nil
}

func (x *OAuth2Auth) HasAudience() bool {
	if x == nil {
		return false
	}
	return x.Audience != nil
}

func (x *OAuth2Auth) ClearTokenUrl() {
	x.TokenUrl = nil
}

func (x *OAuth2Auth) ClearAuthorizationUrl() {
	x.AuthorizationUrl = nil
}

func (x *OAuth2Auth) ClearScopes() {
	x.Scopes = nil
}

func (x *OAuth2Auth) ClearIssuerUrl() {
	x.IssuerUrl = nil
}

func (x *OAuth2Auth) ClearAudience() {
	x.Audience = nil
}

type OAuth2Auth_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	TokenUrl         *string
	AuthorizationUrl *string
	// Space-delimited list of scopes.
	Scopes    *string
	IssuerUrl *string
	Audience  *string
}

func (b0 OAuth2Auth_builder) Build() *OAuth2Auth {
	m0 := &OAuth2Auth{}
	b, x := &b0, m0
	_, _ = b, x
	x.TokenUrl = b.TokenUrl
	x.AuthorizationUrl = b.AuthorizationUrl
	x.Scopes = b.Scopes
	x.IssuerUrl = b.IssuerUrl
	x.Audience = b.Audience
	return m0
}

var File_proto_config_v1_auth_proto protoreflect.FileDescriptor

const file_proto_config_v1_auth_proto_rawDesc = "" +
	"\n" +
	"\x1aproto/config/v1/auth.proto\x12\x10mcpany.config.v1\"\xe6\x02\n" +
	"\vSecretValue\x12\x1f\n" +
	"\n" +
	"plain_text\x18\x01 \x01(\tH\x00R\tplainText\x123\n" +
	"\x14environment_variable\x18\x02 \x01(\tH\x00R\x13environmentVariable\x12\x1d\n" +
	"\tfile_path\x18\x03 \x01(\tH\x00R\bfilePath\x12H\n" +
	"\x0eremote_content\x18\x04 \x01(\v2\x1f.mcpany.config.v1.RemoteContentH\x00R\rremoteContent\x125\n" +
	"\x05vault\x18\x05 \x01(\v2\x1d.mcpany.config.v1.VaultSecretH\x00R\x05vault\x12X\n" +
	"\x12aws_secret_manager\x18\x06 \x01(\v2(.mcpany.config.v1.AwsSecretManagerSecretH\x00R\x10awsSecretManagerB\a\n" +
	"\x05value\"\xca\x01\n" +
	"\x16AwsSecretManagerSecret\x12\x1c\n" +
	"\tsecret_id\x18\x01 \x01(\tR\tsecret_id\x12\x1a\n" +
	"\bjson_key\x18\x02 \x01(\tR\bjson_key\x12$\n" +
	"\rversion_stage\x18\x03 \x01(\tR\rversion_stage\x12\x1e\n" +
	"\n" +
	"version_id\x18\x04 \x01(\tR\n" +
	"version_id\x12\x16\n" +
	"\x06region\x18\x05 \x01(\tR\x06region\x12\x18\n" +
	"\aprofile\x18\x06 \x01(\tR\aprofile\"\x82\x01\n" +
	"\vVaultSecret\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x123\n" +
	"\x05token\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05token\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12\x10\n" +
	"\x03key\x18\x04 \x01(\tR\x03key\"`\n" +
	"\rRemoteContent\x12\x19\n" +
	"\bhttp_url\x18\x01 \x01(\tR\ahttpUrl\x124\n" +
	"\x04auth\x18\x02 \x01(\v2 .mcpany.config.v1.AuthenticationR\x04auth\"\xb6\x02\n" +
	"\x0eAuthentication\x12?\n" +
	"\aapi_key\x18\x01 \x01(\v2$.mcpany.config.v1.UpstreamAPIKeyAuthH\x00R\x06apiKey\x12N\n" +
	"\fbearer_token\x18\x02 \x01(\v2).mcpany.config.v1.UpstreamBearerTokenAuthH\x00R\vbearerToken\x12D\n" +
	"\n" +
	"basic_auth\x18\x03 \x01(\v2#.mcpany.config.v1.UpstreamBasicAuthH\x00R\tbasicAuth\x12>\n" +
	"\x06oauth2\x18\x05 \x01(\v2$.mcpany.config.v1.UpstreamOAuth2AuthH\x00R\x06oauth2B\r\n" +
	"\vauth_method\"\xb2\x03\n" +
	"\x16UpstreamAuthentication\x12?\n" +
	"\aapi_key\x18\x01 \x01(\v2$.mcpany.config.v1.UpstreamAPIKeyAuthH\x00R\x06apiKey\x12N\n" +
	"\fbearer_token\x18\x02 \x01(\v2).mcpany.config.v1.UpstreamBearerTokenAuthH\x00R\vbearerToken\x12D\n" +
	"\n" +
	"basic_auth\x18\x03 \x01(\v2#.mcpany.config.v1.UpstreamBasicAuthH\x00R\tbasicAuth\x12>\n" +
	"\x06oauth2\x18\x05 \x01(\v2$.mcpany.config.v1.UpstreamOAuth2AuthH\x00R\x06oauth2\x128\n" +
	"\x04mtls\x18\x06 \x01(\v2\".mcpany.config.v1.UpstreamMTLSAuthH\x00R\x04mtls\x128\n" +
	"\x18use_environment_variable\x18\x04 \x01(\bR\x16useEnvironmentVariableB\r\n" +
	"\vauth_method\"m\n" +
	"\x12UpstreamAPIKeyAuth\x12\x1f\n" +
	"\vheader_name\x18\x01 \x01(\tR\n" +
	"headerName\x126\n" +
	"\aapi_key\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x06apiKey\"N\n" +
	"\x17UpstreamBearerTokenAuth\x123\n" +
	"\x05token\x18\x01 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05token\"j\n" +
	"\x11UpstreamBasicAuth\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x129\n" +
	"\bpassword\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\bpassword\"\xc9\x01\n" +
	"\x12UpstreamOAuth2Auth\x12\x1b\n" +
	"\ttoken_url\x18\x01 \x01(\tR\btokenUrl\x12:\n" +
	"\tclient_id\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\bclientId\x12B\n" +
	"\rclient_secret\x18\x03 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\fclientSecret\x12\x16\n" +
	"\x06scopes\x18\x04 \x01(\tR\x06scopes\"\x86\x01\n" +
	"\x10UpstreamMTLSAuth\x12(\n" +
	"\x10client_cert_path\x18\x01 \x01(\tR\x0eclientCertPath\x12&\n" +
	"\x0fclient_key_path\x18\x02 \x01(\tR\rclientKeyPath\x12 \n" +
	"\fca_cert_path\x18\x03 \x01(\tR\n" +
	"caCertPath\"\xd7\x02\n" +
	"\x14AuthenticationConfig\x128\n" +
	"\aapi_key\x18\x01 \x01(\v2\x1c.mcpany.config.v1.APIKeyAuthH\x00R\aapi_key\x126\n" +
	"\x06oauth2\x18\x02 \x01(\v2\x1c.mcpany.config.v1.OAuth2AuthH\x00R\x06oauth2\x12=\n" +
	"\n" +
	"basic_auth\x18\x03 \x01(\v2\x1b.mcpany.config.v1.BasicAuthH\x00R\n" +
	"basic_auth\x120\n" +
	"\x04oidc\x18\x04 \x01(\v2\x1a.mcpany.config.v1.OIDCAuthH\x00R\x04oidc\x12M\n" +
	"\x0etrusted_header\x18\x05 \x01(\v2#.mcpany.config.v1.TrustedHeaderAuthH\x00R\x0etrusted_headerB\r\n" +
	"\vauth_method\"1\n" +
	"\tBasicAuth\x12$\n" +
	"\rpassword_hash\x18\x01 \x01(\tR\rpassword_hash\"n\n" +
	"\bOIDCAuth\x12\x16\n" +
	"\x06issuer\x18\x01 \x01(\tR\x06issuer\x12\x18\n" +
	"\asubject\x18\x02 \x01(\tR\asubject\x12\x14\n" +
	"\x05email\x18\x03 \x01(\tR\x05email\x12\x1a\n" +
	"\baudience\x18\x04 \x03(\tR\baudience\"Y\n" +
	"\x11TrustedHeaderAuth\x12 \n" +
	"\vheader_name\x18\x01 \x01(\tR\vheader_name\x12\"\n" +
	"\fheader_value\x18\x02 \x01(\tR\fheader_value\"\xa4\x01\n" +
	"\n" +
	"APIKeyAuth\x12\x1e\n" +
	"\n" +
	"param_name\x18\x01 \x01(\tR\n" +
	"param_name\x125\n" +
	"\x02in\x18\x02 \x01(\x0e2%.mcpany.config.v1.APIKeyAuth.LocationR\x02in\x12\x1c\n" +
	"\tkey_value\x18\x03 \x01(\tR\tkey_value\"!\n" +
	"\bLocation\x12\n" +
	"\n" +
	"\x06HEADER\x10\x00\x12\t\n" +
	"\x05QUERY\x10\x01\"\xa9\x01\n" +
	"\n" +
	"OAuth2Auth\x12\x1b\n" +
	"\ttoken_url\x18\x03 \x01(\tR\btokenUrl\x12+\n" +
	"\x11authorization_url\x18\x04 \x01(\tR\x10authorizationUrl\x12\x16\n" +
	"\x06scopes\x18\x05 \x01(\tR\x06scopes\x12\x1d\n" +
	"\n" +
	"issuer_url\x18\x06 \x01(\tR\tissuerUrl\x12\x1a\n" +
	"\baudience\x18\a \x01(\tR\baudienceB3B\tAuthProtoZ&github.com/mcpany/core/proto/config/v1b\beditionsp\xe8\a"

var file_proto_config_v1_auth_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_config_v1_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_proto_config_v1_auth_proto_goTypes = []any{
	(APIKeyAuth_Location)(0),        // 0: mcpany.config.v1.APIKeyAuth.Location
	(*SecretValue)(nil),             // 1: mcpany.config.v1.SecretValue
	(*AwsSecretManagerSecret)(nil),  // 2: mcpany.config.v1.AwsSecretManagerSecret
	(*VaultSecret)(nil),             // 3: mcpany.config.v1.VaultSecret
	(*RemoteContent)(nil),           // 4: mcpany.config.v1.RemoteContent
	(*Authentication)(nil),          // 5: mcpany.config.v1.Authentication
	(*UpstreamAuthentication)(nil),  // 6: mcpany.config.v1.UpstreamAuthentication
	(*UpstreamAPIKeyAuth)(nil),      // 7: mcpany.config.v1.UpstreamAPIKeyAuth
	(*UpstreamBearerTokenAuth)(nil), // 8: mcpany.config.v1.UpstreamBearerTokenAuth
	(*UpstreamBasicAuth)(nil),       // 9: mcpany.config.v1.UpstreamBasicAuth
	(*UpstreamOAuth2Auth)(nil),      // 10: mcpany.config.v1.UpstreamOAuth2Auth
	(*UpstreamMTLSAuth)(nil),        // 11: mcpany.config.v1.UpstreamMTLSAuth
	(*AuthenticationConfig)(nil),    // 12: mcpany.config.v1.AuthenticationConfig
	(*BasicAuth)(nil),               // 13: mcpany.config.v1.BasicAuth
	(*OIDCAuth)(nil),                // 14: mcpany.config.v1.OIDCAuth
	(*TrustedHeaderAuth)(nil),       // 15: mcpany.config.v1.TrustedHeaderAuth
	(*APIKeyAuth)(nil),              // 16: mcpany.config.v1.APIKeyAuth
	(*OAuth2Auth)(nil),              // 17: mcpany.config.v1.OAuth2Auth
}
var file_proto_config_v1_auth_proto_depIdxs = []int32{
	4,  // 0: mcpany.config.v1.SecretValue.remote_content:type_name -> mcpany.config.v1.RemoteContent
	3,  // 1: mcpany.config.v1.SecretValue.vault:type_name -> mcpany.config.v1.VaultSecret
	2,  // 2: mcpany.config.v1.SecretValue.aws_secret_manager:type_name -> mcpany.config.v1.AwsSecretManagerSecret
	1,  // 3: mcpany.config.v1.VaultSecret.token:type_name -> mcpany.config.v1.SecretValue
	5,  // 4: mcpany.config.v1.RemoteContent.auth:type_name -> mcpany.config.v1.Authentication
	7,  // 5: mcpany.config.v1.Authentication.api_key:type_name -> mcpany.config.v1.UpstreamAPIKeyAuth
	8,  // 6: mcpany.config.v1.Authentication.bearer_token:type_name -> mcpany.config.v1.UpstreamBearerTokenAuth
	9,  // 7: mcpany.config.v1.Authentication.basic_auth:type_name -> mcpany.config.v1.UpstreamBasicAuth
	10, // 8: mcpany.config.v1.Authentication.oauth2:type_name -> mcpany.config.v1.UpstreamOAuth2Auth
	7,  // 9: mcpany.config.v1.UpstreamAuthentication.api_key:type_name -> mcpany.config.v1.UpstreamAPIKeyAuth
	8,  // 10: mcpany.config.v1.UpstreamAuthentication.bearer_token:type_name -> mcpany.config.v1.UpstreamBearerTokenAuth
	9,  // 11: mcpany.config.v1.UpstreamAuthentication.basic_auth:type_name -> mcpany.config.v1.UpstreamBasicAuth
	10, // 12: mcpany.config.v1.UpstreamAuthentication.oauth2:type_name -> mcpany.config.v1.UpstreamOAuth2Auth
	11, // 13: mcpany.config.v1.UpstreamAuthentication.mtls:type_name -> mcpany.config.v1.UpstreamMTLSAuth
	1,  // 14: mcpany.config.v1.UpstreamAPIKeyAuth.api_key:type_name -> mcpany.config.v1.SecretValue
	1,  // 15: mcpany.config.v1.UpstreamBearerTokenAuth.token:type_name -> mcpany.config.v1.SecretValue
	1,  // 16: mcpany.config.v1.UpstreamBasicAuth.password:type_name -> mcpany.config.v1.SecretValue
	1,  // 17: mcpany.config.v1.UpstreamOAuth2Auth.client_id:type_name -> mcpany.config.v1.SecretValue
	1,  // 18: mcpany.config.v1.UpstreamOAuth2Auth.client_secret:type_name -> mcpany.config.v1.SecretValue
	16, // 19: mcpany.config.v1.AuthenticationConfig.api_key:type_name -> mcpany.config.v1.APIKeyAuth
	17, // 20: mcpany.config.v1.AuthenticationConfig.oauth2:type_name -> mcpany.config.v1.OAuth2Auth
	13, // 21: mcpany.config.v1.AuthenticationConfig.basic_auth:type_name -> mcpany.config.v1.BasicAuth
	14, // 22: mcpany.config.v1.AuthenticationConfig.oidc:type_name -> mcpany.config.v1.OIDCAuth
	15, // 23: mcpany.config.v1.AuthenticationConfig.trusted_header:type_name -> mcpany.config.v1.TrustedHeaderAuth
	0,  // 24: mcpany.config.v1.APIKeyAuth.in:type_name -> mcpany.config.v1.APIKeyAuth.Location
	25, // [25:25] is the sub-list for method output_type
	25, // [25:25] is the sub-list for method input_type
	25, // [25:25] is the sub-list for extension type_name
	25, // [25:25] is the sub-list for extension extendee
	0,  // [0:25] is the sub-list for field type_name
}

func init() { file_proto_config_v1_auth_proto_init() }
func file_proto_config_v1_auth_proto_init() {
	if File_proto_config_v1_auth_proto != nil {
		return
	}
	file_proto_config_v1_auth_proto_msgTypes[0].OneofWrappers = []any{
		(*SecretValue_PlainText)(nil),
		(*SecretValue_EnvironmentVariable)(nil),
		(*SecretValue_FilePath)(nil),
		(*SecretValue_RemoteContent)(nil),
		(*SecretValue_Vault)(nil),
		(*SecretValue_AwsSecretManager)(nil),
	}
	file_proto_config_v1_auth_proto_msgTypes[4].OneofWrappers = []any{
		(*Authentication_ApiKey)(nil),
		(*Authentication_BearerToken)(nil),
		(*Authentication_BasicAuth)(nil),
		(*Authentication_Oauth2)(nil),
	}
	file_proto_config_v1_auth_proto_msgTypes[5].OneofWrappers = []any{
		(*UpstreamAuthentication_ApiKey)(nil),
		(*UpstreamAuthentication_BearerToken)(nil),
		(*UpstreamAuthentication_BasicAuth)(nil),
		(*UpstreamAuthentication_Oauth2)(nil),
		(*UpstreamAuthentication_Mtls)(nil),
	}
	file_proto_config_v1_auth_proto_msgTypes[11].OneofWrappers = []any{
		(*AuthenticationConfig_ApiKey)(nil),
		(*AuthenticationConfig_Oauth2)(nil),
		(*AuthenticationConfig_BasicAuth)(nil),
		(*AuthenticationConfig_Oidc)(nil),
		(*AuthenticationConfig_TrustedHeader)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_config_v1_auth_proto_rawDesc), len(file_proto_config_v1_auth_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_config_v1_auth_proto_goTypes,
		DependencyIndexes: file_proto_config_v1_auth_proto_depIdxs,
		EnumInfos:         file_proto_config_v1_auth_proto_enumTypes,
		MessageInfos:      file_proto_config_v1_auth_proto_msgTypes,
	}.Build()
	File_proto_config_v1_auth_proto = out.File
	file_proto_config_v1_auth_proto_goTypes = nil
	file_proto_config_v1_auth_proto_depIdxs = nil
}
