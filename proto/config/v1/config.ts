// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: proto/config/v1/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { MessageBus } from "../../bus/bus";
import { SecretValue } from "./auth";
import { Collection } from "./collection";
import { ProfileServiceConfig, RateLimitConfig } from "./profile";
import { UpstreamServiceConfig } from "./upstream_service";
import { User } from "./user";

export const protobufPackage = "mcpany.config.v1";

/**
 * McpAnyServerConfig is the root configuration for the entire MCPANY server.
 * It aggregates global settings, upstream services, user definitions, and merge strategies.
 */
export interface McpAnyServerConfig {
  /** Server-wide operational parameters such as network listeners, logging, and security policies. */
  globalSettings?:
    | GlobalSettings
    | undefined;
  /**
   * A list of all configured upstream services that MCP Any can proxy to.
   * Each entry defines a connection to an external tool or API.
   */
  upstreamServices: UpstreamServiceConfig[];
  /**
   * A list of upstream service collections to load from.
   * Collections allow grouping and reusing service definitions.
   */
  collections: Collection[];
  /**
   * A list of users authorized to access the server.
   * This includes their roles, authentication methods, and profile associations.
   */
  users: User[];
  /** Configuration for how to merge lists when loading from multiple sources (e.g., config files and database). */
  mergeStrategy?: MergeStrategyConfig | undefined;
}

/** MergeStrategyConfig defines how to resolve conflicts when merging configurations from multiple sources. */
export interface MergeStrategyConfig {
  /**
   * Strategy for merging upstream_services list.
   * Options: "extend" (append new services) or "replace" (overwrite existing list).
   */
  upstreamServiceList: string;
  /**
   * Strategy for merging profiles list.
   * Options: "extend" (append new profiles) or "replace" (overwrite existing list).
   */
  profileList: string;
}

/** Secret defines a sensitive value that should be handled securely. */
export interface Secret {
  /** The human-readable name of the secret, used for display purposes. */
  name: string;
  /** The unique identifier for the secret, used for referencing it in configurations. */
  id: string;
  /** The key used to reference the secret (e.g., the environment variable name). */
  key: string;
  /**
   * The actual value of the secret.
   * Note: This may be encrypted or raw depending on the context.
   */
  value: string;
  /** The provider source of the secret (e.g., "openai", "aws", "vault"). */
  provider: string;
  /** The timestamp when the secret was last accessed, in RFC3339 format. */
  lastUsed: string;
  /** The timestamp when the secret was created, in RFC3339 format. */
  createdAt: string;
}

/** SecretList is a container for a list of secrets. */
export interface SecretList {
  /** The list of secrets. */
  secrets: Secret[];
}

/** GlobalSettings defines server-wide operational parameters. */
export interface GlobalSettings {
  /** The address (host:port) on which the MCP server listens for incoming connections (e.g., "0.0.0.0:50051"). */
  mcpListenAddress: string;
  /** The minimum log level to output. Logs below this level will be discarded. */
  logLevel: GlobalSettings_LogLevel;
  /** The master API key used for global authentication to the server. */
  apiKey: string;
  /** The format to use for log output (text or JSON). */
  logFormat: GlobalSettings_LogFormat;
  /** The file path to the persistent database (e.g., "mcpany.db"). */
  dbPath: string;
  /** The database connection string (DSN) for connecting to external databases like PostgreSQL. */
  dbDsn: string;
  /** The database driver to use (e.g., "sqlite", "postgres"). */
  dbDriver: string;
  /** The GitHub API URL to use for checking for self-updates (optional). */
  githubApiUrl: string;
  /** If true, the server will prepend "sudo" to Docker commands. */
  useSudoForDocker: boolean;
  /** Configuration for the internal message bus used for component communication. */
  messageBus?:
    | MessageBus
    | undefined;
  /** Configuration for audit logging of user actions and API calls. */
  audit?:
    | AuditConfig
    | undefined;
  /** Configuration for Data Loss Prevention (DLP) features. */
  dlp?:
    | DLPConfig
    | undefined;
  /** Configuration for Garbage Collection of temporary resources. */
  gcSettings?:
    | GCSettings
    | undefined;
  /** Configuration for OpenID Connect (OIDC) authentication. */
  oidc?:
    | OIDCConfig
    | undefined;
  /** Configuration for global rate limiting to protect the server. */
  rateLimit?:
    | RateLimitConfig
    | undefined;
  /** Configuration for telemetry (metrics and tracing). */
  telemetry?:
    | TelemetryConfig
    | undefined;
  /** A list of profile names to enable globally. */
  profiles: string[];
  /** A list of IP addresses or CIDR ranges allowed to access the server. */
  allowedIps: string[];
  /** Definitions of available profiles that define access control and resource grouping. */
  profileDefinitions: ProfileDefinition[];
  /** The list of middlewares to enable and their configuration. */
  middlewares: Middleware[];
  /** A list of file paths that are explicitly allowed for validation or access. */
  allowedFilePaths: string[];
  /** A list of allowed origins for Cross-Origin Resource Sharing (CORS). */
  allowedOrigins: string[];
  /** Configuration for the Context Optimizer, which reduces prompt size. */
  contextOptimizer?:
    | ContextOptimizerConfig
    | undefined;
  /** Configuration for the Debugger, allowing inspection of internal state. */
  debugger?:
    | DebuggerConfig
    | undefined;
  /**
   * If true, the configuration is considered read-only and cannot be modified via API.
   * @inject_tag: yaml:"-"
   */
  readOnly: boolean;
  /** If true, the server will attempt to auto-discover local services (e.g., Ollama). */
  autoDiscoverLocal: boolean;
  /** Configuration for system health alerts. */
  alerts?: AlertConfig | undefined;
}

/** LogLevel defines the verbosity of logs. */
export enum GlobalSettings_LogLevel {
  LOG_LEVEL_UNSPECIFIED = 0,
  LOG_LEVEL_INFO = 1,
  LOG_LEVEL_WARN = 2,
  LOG_LEVEL_ERROR = 3,
  LOG_LEVEL_DEBUG = 4,
  UNRECOGNIZED = -1,
}

export function globalSettings_LogLevelFromJSON(object: any): GlobalSettings_LogLevel {
  switch (object) {
    case 0:
    case "LOG_LEVEL_UNSPECIFIED":
      return GlobalSettings_LogLevel.LOG_LEVEL_UNSPECIFIED;
    case 1:
    case "LOG_LEVEL_INFO":
      return GlobalSettings_LogLevel.LOG_LEVEL_INFO;
    case 2:
    case "LOG_LEVEL_WARN":
      return GlobalSettings_LogLevel.LOG_LEVEL_WARN;
    case 3:
    case "LOG_LEVEL_ERROR":
      return GlobalSettings_LogLevel.LOG_LEVEL_ERROR;
    case 4:
    case "LOG_LEVEL_DEBUG":
      return GlobalSettings_LogLevel.LOG_LEVEL_DEBUG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GlobalSettings_LogLevel.UNRECOGNIZED;
  }
}

export function globalSettings_LogLevelToJSON(object: GlobalSettings_LogLevel): string {
  switch (object) {
    case GlobalSettings_LogLevel.LOG_LEVEL_UNSPECIFIED:
      return "LOG_LEVEL_UNSPECIFIED";
    case GlobalSettings_LogLevel.LOG_LEVEL_INFO:
      return "LOG_LEVEL_INFO";
    case GlobalSettings_LogLevel.LOG_LEVEL_WARN:
      return "LOG_LEVEL_WARN";
    case GlobalSettings_LogLevel.LOG_LEVEL_ERROR:
      return "LOG_LEVEL_ERROR";
    case GlobalSettings_LogLevel.LOG_LEVEL_DEBUG:
      return "LOG_LEVEL_DEBUG";
    case GlobalSettings_LogLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** LogFormat defines the structure of log output. */
export enum GlobalSettings_LogFormat {
  LOG_FORMAT_UNSPECIFIED = 0,
  LOG_FORMAT_TEXT = 1,
  LOG_FORMAT_JSON = 2,
  UNRECOGNIZED = -1,
}

export function globalSettings_LogFormatFromJSON(object: any): GlobalSettings_LogFormat {
  switch (object) {
    case 0:
    case "LOG_FORMAT_UNSPECIFIED":
      return GlobalSettings_LogFormat.LOG_FORMAT_UNSPECIFIED;
    case 1:
    case "LOG_FORMAT_TEXT":
      return GlobalSettings_LogFormat.LOG_FORMAT_TEXT;
    case 2:
    case "LOG_FORMAT_JSON":
      return GlobalSettings_LogFormat.LOG_FORMAT_JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GlobalSettings_LogFormat.UNRECOGNIZED;
  }
}

export function globalSettings_LogFormatToJSON(object: GlobalSettings_LogFormat): string {
  switch (object) {
    case GlobalSettings_LogFormat.LOG_FORMAT_UNSPECIFIED:
      return "LOG_FORMAT_UNSPECIFIED";
    case GlobalSettings_LogFormat.LOG_FORMAT_TEXT:
      return "LOG_FORMAT_TEXT";
    case GlobalSettings_LogFormat.LOG_FORMAT_JSON:
      return "LOG_FORMAT_JSON";
    case GlobalSettings_LogFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AlertConfig defines settings for system alerts. */
export interface AlertConfig {
  /** If true, system alerts are enabled. */
  enabled: boolean;
  /** The webhook URL to which alerts should be sent (e.g., Slack, Discord). */
  webhookUrl: string;
}

/** ContextOptimizerConfig defines settings for optimizing context size. */
export interface ContextOptimizerConfig {
  /** The maximum number of characters allowed in the context. */
  maxChars: number;
}

/** DebuggerConfig defines settings for the internal debugger. */
export interface DebuggerConfig {
  /** If true, the debugger is enabled. */
  enabled: boolean;
  /** The maximum size of the debug buffer (number of entries). */
  size: number;
}

/** TelemetryConfig defines settings for observability. */
export interface TelemetryConfig {
  /** The exporter to use for traces (e.g., "otlp", "stdout", "none"). */
  tracesExporter: string;
  /** The exporter to use for metrics (e.g., "otlp", "stdout", "none"). */
  metricsExporter: string;
  /** The OTLP endpoint URL for sending telemetry data (shared for traces and metrics if applicable). */
  otlpEndpoint: string;
  /** An optional override for the service name in telemetry data. */
  serviceName: string;
}

/** OIDCConfig defines settings for OpenID Connect authentication. */
export interface OIDCConfig {
  /** The OIDC issuer URL (e.g., "https://accounts.google.com"). */
  issuer: string;
  /** The Client ID for the OIDC application. */
  clientId: string;
  /** The Client Secret for the OIDC application. */
  clientSecret: string;
  /** The callback URL where the OIDC provider redirects after authentication. */
  redirectUrl: string;
}

/** GCSettings defines settings for Garbage Collection. */
export interface GCSettings {
  /** If true, the global GC worker is enabled. */
  enabled: boolean;
  /** The interval at which the GC worker runs (e.g., "1h", "10m"). */
  interval: string;
  /** The time-to-live for temporary files. Files older than this duration will be deleted. */
  ttl: string;
  /**
   * A list of absolute paths to directories that should be scanned for cleanup.
   * The worker will strictly confine its operations to these directories.
   */
  paths: string[];
}

/** DLPConfig defines settings for Data Loss Prevention. */
export interface DLPConfig {
  /** If true, DLP features are enabled. */
  enabled: boolean;
  /**
   * A list of custom regex patterns to redact from logs and outputs.
   * Note: Standard patterns (Email, Credit Card, SSN) are enabled by default if DLP is on.
   */
  customPatterns: string[];
}

/** AuditConfig defines settings for audit logging. */
export interface AuditConfig {
  /** If true, audit logging is enabled. */
  enabled: boolean;
  /** The file path to write audit logs to (used if storage_type is FILE). */
  outputPath: string;
  /**
   * If true, input arguments to API calls will be logged.
   * Warning: This may log sensitive information including secrets.
   */
  logArguments: boolean;
  /**
   * If true, output results from API calls will be logged.
   * Warning: This may log sensitive data returned by tools.
   */
  logResults: boolean;
  /** The storage backend to use for audit logs. */
  storageType: AuditConfig_StorageType;
  /** The webhook URL to send audit events to (used if storage_type is WEBHOOK). */
  webhookUrl: string;
  /** Additional HTTP headers to include in webhook requests. */
  webhookHeaders: { [key: string]: string };
  /** Configuration for Splunk integration. */
  splunk?:
    | SplunkConfig
    | undefined;
  /** Configuration for Datadog integration. */
  datadog?: DatadogConfig | undefined;
}

/** StorageType defines the destination for audit logs. */
export enum AuditConfig_StorageType {
  STORAGE_TYPE_UNSPECIFIED = 0,
  STORAGE_TYPE_FILE = 1,
  STORAGE_TYPE_SQLITE = 2,
  STORAGE_TYPE_POSTGRES = 3,
  STORAGE_TYPE_WEBHOOK = 4,
  STORAGE_TYPE_SPLUNK = 5,
  STORAGE_TYPE_DATADOG = 6,
  UNRECOGNIZED = -1,
}

export function auditConfig_StorageTypeFromJSON(object: any): AuditConfig_StorageType {
  switch (object) {
    case 0:
    case "STORAGE_TYPE_UNSPECIFIED":
      return AuditConfig_StorageType.STORAGE_TYPE_UNSPECIFIED;
    case 1:
    case "STORAGE_TYPE_FILE":
      return AuditConfig_StorageType.STORAGE_TYPE_FILE;
    case 2:
    case "STORAGE_TYPE_SQLITE":
      return AuditConfig_StorageType.STORAGE_TYPE_SQLITE;
    case 3:
    case "STORAGE_TYPE_POSTGRES":
      return AuditConfig_StorageType.STORAGE_TYPE_POSTGRES;
    case 4:
    case "STORAGE_TYPE_WEBHOOK":
      return AuditConfig_StorageType.STORAGE_TYPE_WEBHOOK;
    case 5:
    case "STORAGE_TYPE_SPLUNK":
      return AuditConfig_StorageType.STORAGE_TYPE_SPLUNK;
    case 6:
    case "STORAGE_TYPE_DATADOG":
      return AuditConfig_StorageType.STORAGE_TYPE_DATADOG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuditConfig_StorageType.UNRECOGNIZED;
  }
}

export function auditConfig_StorageTypeToJSON(object: AuditConfig_StorageType): string {
  switch (object) {
    case AuditConfig_StorageType.STORAGE_TYPE_UNSPECIFIED:
      return "STORAGE_TYPE_UNSPECIFIED";
    case AuditConfig_StorageType.STORAGE_TYPE_FILE:
      return "STORAGE_TYPE_FILE";
    case AuditConfig_StorageType.STORAGE_TYPE_SQLITE:
      return "STORAGE_TYPE_SQLITE";
    case AuditConfig_StorageType.STORAGE_TYPE_POSTGRES:
      return "STORAGE_TYPE_POSTGRES";
    case AuditConfig_StorageType.STORAGE_TYPE_WEBHOOK:
      return "STORAGE_TYPE_WEBHOOK";
    case AuditConfig_StorageType.STORAGE_TYPE_SPLUNK:
      return "STORAGE_TYPE_SPLUNK";
    case AuditConfig_StorageType.STORAGE_TYPE_DATADOG:
      return "STORAGE_TYPE_DATADOG";
    case AuditConfig_StorageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AuditConfig_WebhookHeadersEntry {
  key: string;
  value: string;
}

/** SplunkConfig defines settings for Splunk integration. */
export interface SplunkConfig {
  /** The Splunk HTTP Event Collector (HEC) URL. */
  hecUrl: string;
  /** The Splunk HEC token. */
  token: string;
  /** The Splunk index to send events to. */
  index: string;
  /** The source value to attach to events. */
  source: string;
  /** The sourcetype value to attach to events. */
  sourcetype: string;
}

/** DatadogConfig defines settings for Datadog integration. */
export interface DatadogConfig {
  /** The Datadog API key. */
  apiKey: string;
  /** The Datadog site (e.g., "datadoghq.com", "datadoghq.eu"). */
  site: string;
  /** The service name to tag logs with. */
  service: string;
  /** A comma-separated list of tags to attach to logs. */
  tags: string;
}

/** ProfileDefinition defines a set of permissions and configurations for a group of users or tools. */
export interface ProfileDefinition {
  /** The unique name of the profile. */
  name: string;
  /** The selector criteria used to match this profile. */
  selector?:
    | ProfileSelector
    | undefined;
  /** A list of roles that a user must possess to access this profile. */
  requiredRoles: string[];
  /** A list of parent profile IDs to inherit configuration from. */
  parentProfileIds: string[];
  /** Service-specific configurations override for this profile. */
  serviceConfig: { [key: string]: ProfileServiceConfig };
  /** Secrets available to services running under this profile. */
  secrets: { [key: string]: SecretValue };
}

export interface ProfileDefinition_ServiceConfigEntry {
  key: string;
  value?: ProfileServiceConfig | undefined;
}

export interface ProfileDefinition_SecretsEntry {
  key: string;
  value?: SecretValue | undefined;
}

/** ProfileSelector defines criteria for selecting a profile. */
export interface ProfileSelector {
  /** A list of tags that must be present. */
  tags: string[];
  /** A map of tool properties that must match. */
  toolProperties: { [key: string]: string };
}

export interface ProfileSelector_ToolPropertiesEntry {
  key: string;
  value: string;
}

/** Middleware defines the configuration for a specific middleware component. */
export interface Middleware {
  /** The name of the middleware (e.g., "logging", "auth", "ratelimit"). */
  name: string;
  /**
   * The priority of the middleware in the execution chain.
   * Lower values run earlier (outermost in the chain).
   */
  priority: number;
  /** If true, this middleware is disabled. */
  disabled: boolean;
}

function createBaseMcpAnyServerConfig(): McpAnyServerConfig {
  return { globalSettings: undefined, upstreamServices: [], collections: [], users: [], mergeStrategy: undefined };
}

export const McpAnyServerConfig: MessageFns<McpAnyServerConfig> = {
  encode(message: McpAnyServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalSettings !== undefined) {
      GlobalSettings.encode(message.globalSettings, writer.uint32(10).fork()).join();
    }
    for (const v of message.upstreamServices) {
      UpstreamServiceConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.collections) {
      Collection.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.users) {
      User.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.mergeStrategy !== undefined) {
      MergeStrategyConfig.encode(message.mergeStrategy, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpAnyServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpAnyServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.globalSettings = GlobalSettings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.upstreamServices.push(UpstreamServiceConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collections.push(Collection.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mergeStrategy = MergeStrategyConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpAnyServerConfig {
    return {
      globalSettings: isSet(object.global_settings) ? GlobalSettings.fromJSON(object.global_settings) : undefined,
      upstreamServices: globalThis.Array.isArray(object?.upstream_services)
        ? object.upstream_services.map((e: any) => UpstreamServiceConfig.fromJSON(e))
        : [],
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => Collection.fromJSON(e))
        : [],
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      mergeStrategy: isSet(object.merge_strategy) ? MergeStrategyConfig.fromJSON(object.merge_strategy) : undefined,
    };
  },

  toJSON(message: McpAnyServerConfig): unknown {
    const obj: any = {};
    if (message.globalSettings !== undefined) {
      obj.global_settings = GlobalSettings.toJSON(message.globalSettings);
    }
    if (message.upstreamServices?.length) {
      obj.upstream_services = message.upstreamServices.map((e) => UpstreamServiceConfig.toJSON(e));
    }
    if (message.collections?.length) {
      obj.collections = message.collections.map((e) => Collection.toJSON(e));
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.mergeStrategy !== undefined) {
      obj.merge_strategy = MergeStrategyConfig.toJSON(message.mergeStrategy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpAnyServerConfig>, I>>(base?: I): McpAnyServerConfig {
    return McpAnyServerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpAnyServerConfig>, I>>(object: I): McpAnyServerConfig {
    const message = createBaseMcpAnyServerConfig();
    message.globalSettings = (object.globalSettings !== undefined && object.globalSettings !== null)
      ? GlobalSettings.fromPartial(object.globalSettings)
      : undefined;
    message.upstreamServices = object.upstreamServices?.map((e) => UpstreamServiceConfig.fromPartial(e)) || [];
    message.collections = object.collections?.map((e) => Collection.fromPartial(e)) || [];
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.mergeStrategy = (object.mergeStrategy !== undefined && object.mergeStrategy !== null)
      ? MergeStrategyConfig.fromPartial(object.mergeStrategy)
      : undefined;
    return message;
  },
};

function createBaseMergeStrategyConfig(): MergeStrategyConfig {
  return { upstreamServiceList: "", profileList: "" };
}

export const MergeStrategyConfig: MessageFns<MergeStrategyConfig> = {
  encode(message: MergeStrategyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upstreamServiceList !== "") {
      writer.uint32(10).string(message.upstreamServiceList);
    }
    if (message.profileList !== "") {
      writer.uint32(18).string(message.profileList);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeStrategyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeStrategyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upstreamServiceList = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profileList = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeStrategyConfig {
    return {
      upstreamServiceList: isSet(object.upstream_service_list) ? globalThis.String(object.upstream_service_list) : "",
      profileList: isSet(object.profile_list) ? globalThis.String(object.profile_list) : "",
    };
  },

  toJSON(message: MergeStrategyConfig): unknown {
    const obj: any = {};
    if (message.upstreamServiceList !== "") {
      obj.upstream_service_list = message.upstreamServiceList;
    }
    if (message.profileList !== "") {
      obj.profile_list = message.profileList;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MergeStrategyConfig>, I>>(base?: I): MergeStrategyConfig {
    return MergeStrategyConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MergeStrategyConfig>, I>>(object: I): MergeStrategyConfig {
    const message = createBaseMergeStrategyConfig();
    message.upstreamServiceList = object.upstreamServiceList ?? "";
    message.profileList = object.profileList ?? "";
    return message;
  },
};

function createBaseSecret(): Secret {
  return { name: "", id: "", key: "", value: "", provider: "", lastUsed: "", createdAt: "" };
}

export const Secret: MessageFns<Secret> = {
  encode(message: Secret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.provider !== "") {
      writer.uint32(42).string(message.provider);
    }
    if (message.lastUsed !== "") {
      writer.uint32(50).string(message.lastUsed);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Secret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastUsed = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Secret {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      lastUsed: isSet(object.lastUsed)
        ? globalThis.String(object.lastUsed)
        : isSet(object.last_used)
        ? globalThis.String(object.last_used)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
    };
  },

  toJSON(message: Secret): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.lastUsed !== "") {
      obj.lastUsed = message.lastUsed;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Secret>, I>>(base?: I): Secret {
    return Secret.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Secret>, I>>(object: I): Secret {
    const message = createBaseSecret();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.provider = object.provider ?? "";
    message.lastUsed = object.lastUsed ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseSecretList(): SecretList {
  return { secrets: [] };
}

export const SecretList: MessageFns<SecretList> = {
  encode(message: SecretList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.secrets) {
      Secret.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secrets.push(Secret.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretList {
    return {
      secrets: globalThis.Array.isArray(object?.secrets) ? object.secrets.map((e: any) => Secret.fromJSON(e)) : [],
    };
  },

  toJSON(message: SecretList): unknown {
    const obj: any = {};
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecretList>, I>>(base?: I): SecretList {
    return SecretList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecretList>, I>>(object: I): SecretList {
    const message = createBaseSecretList();
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGlobalSettings(): GlobalSettings {
  return {
    mcpListenAddress: "",
    logLevel: 0,
    apiKey: "",
    logFormat: 0,
    dbPath: "",
    dbDsn: "",
    dbDriver: "",
    githubApiUrl: "",
    useSudoForDocker: false,
    messageBus: undefined,
    audit: undefined,
    dlp: undefined,
    gcSettings: undefined,
    oidc: undefined,
    rateLimit: undefined,
    telemetry: undefined,
    profiles: [],
    allowedIps: [],
    profileDefinitions: [],
    middlewares: [],
    allowedFilePaths: [],
    allowedOrigins: [],
    contextOptimizer: undefined,
    debugger: undefined,
    readOnly: false,
    autoDiscoverLocal: false,
    alerts: undefined,
  };
}

export const GlobalSettings: MessageFns<GlobalSettings> = {
  encode(message: GlobalSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpListenAddress !== "") {
      writer.uint32(10).string(message.mcpListenAddress);
    }
    if (message.logLevel !== 0) {
      writer.uint32(16).int32(message.logLevel);
    }
    if (message.apiKey !== "") {
      writer.uint32(26).string(message.apiKey);
    }
    if (message.logFormat !== 0) {
      writer.uint32(32).int32(message.logFormat);
    }
    if (message.dbPath !== "") {
      writer.uint32(42).string(message.dbPath);
    }
    if (message.dbDsn !== "") {
      writer.uint32(50).string(message.dbDsn);
    }
    if (message.dbDriver !== "") {
      writer.uint32(58).string(message.dbDriver);
    }
    if (message.githubApiUrl !== "") {
      writer.uint32(66).string(message.githubApiUrl);
    }
    if (message.useSudoForDocker !== false) {
      writer.uint32(72).bool(message.useSudoForDocker);
    }
    if (message.messageBus !== undefined) {
      MessageBus.encode(message.messageBus, writer.uint32(82).fork()).join();
    }
    if (message.audit !== undefined) {
      AuditConfig.encode(message.audit, writer.uint32(90).fork()).join();
    }
    if (message.dlp !== undefined) {
      DLPConfig.encode(message.dlp, writer.uint32(98).fork()).join();
    }
    if (message.gcSettings !== undefined) {
      GCSettings.encode(message.gcSettings, writer.uint32(106).fork()).join();
    }
    if (message.oidc !== undefined) {
      OIDCConfig.encode(message.oidc, writer.uint32(114).fork()).join();
    }
    if (message.rateLimit !== undefined) {
      RateLimitConfig.encode(message.rateLimit, writer.uint32(122).fork()).join();
    }
    if (message.telemetry !== undefined) {
      TelemetryConfig.encode(message.telemetry, writer.uint32(130).fork()).join();
    }
    for (const v of message.profiles) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.allowedIps) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.profileDefinitions) {
      ProfileDefinition.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.middlewares) {
      Middleware.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.allowedFilePaths) {
      writer.uint32(170).string(v!);
    }
    for (const v of message.allowedOrigins) {
      writer.uint32(178).string(v!);
    }
    if (message.contextOptimizer !== undefined) {
      ContextOptimizerConfig.encode(message.contextOptimizer, writer.uint32(186).fork()).join();
    }
    if (message.debugger !== undefined) {
      DebuggerConfig.encode(message.debugger, writer.uint32(194).fork()).join();
    }
    if (message.readOnly !== false) {
      writer.uint32(200).bool(message.readOnly);
    }
    if (message.autoDiscoverLocal !== false) {
      writer.uint32(208).bool(message.autoDiscoverLocal);
    }
    if (message.alerts !== undefined) {
      AlertConfig.encode(message.alerts, writer.uint32(218).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GlobalSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlobalSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpListenAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.logLevel = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.logFormat = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dbPath = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dbDsn = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dbDriver = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.githubApiUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.useSudoForDocker = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.messageBus = MessageBus.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.audit = AuditConfig.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dlp = DLPConfig.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.gcSettings = GCSettings.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.oidc = OIDCConfig.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.rateLimit = RateLimitConfig.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.telemetry = TelemetryConfig.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.profiles.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.allowedIps.push(reader.string());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.profileDefinitions.push(ProfileDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.middlewares.push(Middleware.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.allowedFilePaths.push(reader.string());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.allowedOrigins.push(reader.string());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.contextOptimizer = ContextOptimizerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.debugger = DebuggerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.autoDiscoverLocal = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.alerts = AlertConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GlobalSettings {
    return {
      mcpListenAddress: isSet(object.mcp_listen_address) ? globalThis.String(object.mcp_listen_address) : "",
      logLevel: isSet(object.log_level) ? globalSettings_LogLevelFromJSON(object.log_level) : 0,
      apiKey: isSet(object.api_key) ? globalThis.String(object.api_key) : "",
      logFormat: isSet(object.log_format) ? globalSettings_LogFormatFromJSON(object.log_format) : 0,
      dbPath: isSet(object.db_path) ? globalThis.String(object.db_path) : "",
      dbDsn: isSet(object.db_dsn) ? globalThis.String(object.db_dsn) : "",
      dbDriver: isSet(object.db_driver) ? globalThis.String(object.db_driver) : "",
      githubApiUrl: isSet(object.github_api_url) ? globalThis.String(object.github_api_url) : "",
      useSudoForDocker: isSet(object.use_sudo_for_docker) ? globalThis.Boolean(object.use_sudo_for_docker) : false,
      messageBus: isSet(object.message_bus) ? MessageBus.fromJSON(object.message_bus) : undefined,
      audit: isSet(object.audit) ? AuditConfig.fromJSON(object.audit) : undefined,
      dlp: isSet(object.dlp) ? DLPConfig.fromJSON(object.dlp) : undefined,
      gcSettings: isSet(object.gc_settings) ? GCSettings.fromJSON(object.gc_settings) : undefined,
      oidc: isSet(object.oidc) ? OIDCConfig.fromJSON(object.oidc) : undefined,
      rateLimit: isSet(object.rate_limit) ? RateLimitConfig.fromJSON(object.rate_limit) : undefined,
      telemetry: isSet(object.telemetry) ? TelemetryConfig.fromJSON(object.telemetry) : undefined,
      profiles: globalThis.Array.isArray(object?.profiles) ? object.profiles.map((e: any) => globalThis.String(e)) : [],
      allowedIps: globalThis.Array.isArray(object?.allowed_ips)
        ? object.allowed_ips.map((e: any) => globalThis.String(e))
        : [],
      profileDefinitions: globalThis.Array.isArray(object?.profile_definitions)
        ? object.profile_definitions.map((e: any) => ProfileDefinition.fromJSON(e))
        : [],
      middlewares: globalThis.Array.isArray(object?.middlewares)
        ? object.middlewares.map((e: any) => Middleware.fromJSON(e))
        : [],
      allowedFilePaths: globalThis.Array.isArray(object?.allowed_file_paths)
        ? object.allowed_file_paths.map((e: any) => globalThis.String(e))
        : [],
      allowedOrigins: globalThis.Array.isArray(object?.allowed_origins)
        ? object.allowed_origins.map((e: any) => globalThis.String(e))
        : [],
      contextOptimizer: isSet(object.context_optimizer)
        ? ContextOptimizerConfig.fromJSON(object.context_optimizer)
        : undefined,
      debugger: isSet(object.debugger) ? DebuggerConfig.fromJSON(object.debugger) : undefined,
      readOnly: isSet(object.read_only) ? globalThis.Boolean(object.read_only) : false,
      autoDiscoverLocal: isSet(object.auto_discover_local) ? globalThis.Boolean(object.auto_discover_local) : false,
      alerts: isSet(object.alerts) ? AlertConfig.fromJSON(object.alerts) : undefined,
    };
  },

  toJSON(message: GlobalSettings): unknown {
    const obj: any = {};
    if (message.mcpListenAddress !== "") {
      obj.mcp_listen_address = message.mcpListenAddress;
    }
    if (message.logLevel !== 0) {
      obj.log_level = globalSettings_LogLevelToJSON(message.logLevel);
    }
    if (message.apiKey !== "") {
      obj.api_key = message.apiKey;
    }
    if (message.logFormat !== 0) {
      obj.log_format = globalSettings_LogFormatToJSON(message.logFormat);
    }
    if (message.dbPath !== "") {
      obj.db_path = message.dbPath;
    }
    if (message.dbDsn !== "") {
      obj.db_dsn = message.dbDsn;
    }
    if (message.dbDriver !== "") {
      obj.db_driver = message.dbDriver;
    }
    if (message.githubApiUrl !== "") {
      obj.github_api_url = message.githubApiUrl;
    }
    if (message.useSudoForDocker !== false) {
      obj.use_sudo_for_docker = message.useSudoForDocker;
    }
    if (message.messageBus !== undefined) {
      obj.message_bus = MessageBus.toJSON(message.messageBus);
    }
    if (message.audit !== undefined) {
      obj.audit = AuditConfig.toJSON(message.audit);
    }
    if (message.dlp !== undefined) {
      obj.dlp = DLPConfig.toJSON(message.dlp);
    }
    if (message.gcSettings !== undefined) {
      obj.gc_settings = GCSettings.toJSON(message.gcSettings);
    }
    if (message.oidc !== undefined) {
      obj.oidc = OIDCConfig.toJSON(message.oidc);
    }
    if (message.rateLimit !== undefined) {
      obj.rate_limit = RateLimitConfig.toJSON(message.rateLimit);
    }
    if (message.telemetry !== undefined) {
      obj.telemetry = TelemetryConfig.toJSON(message.telemetry);
    }
    if (message.profiles?.length) {
      obj.profiles = message.profiles;
    }
    if (message.allowedIps?.length) {
      obj.allowed_ips = message.allowedIps;
    }
    if (message.profileDefinitions?.length) {
      obj.profile_definitions = message.profileDefinitions.map((e) => ProfileDefinition.toJSON(e));
    }
    if (message.middlewares?.length) {
      obj.middlewares = message.middlewares.map((e) => Middleware.toJSON(e));
    }
    if (message.allowedFilePaths?.length) {
      obj.allowed_file_paths = message.allowedFilePaths;
    }
    if (message.allowedOrigins?.length) {
      obj.allowed_origins = message.allowedOrigins;
    }
    if (message.contextOptimizer !== undefined) {
      obj.context_optimizer = ContextOptimizerConfig.toJSON(message.contextOptimizer);
    }
    if (message.debugger !== undefined) {
      obj.debugger = DebuggerConfig.toJSON(message.debugger);
    }
    if (message.readOnly !== false) {
      obj.read_only = message.readOnly;
    }
    if (message.autoDiscoverLocal !== false) {
      obj.auto_discover_local = message.autoDiscoverLocal;
    }
    if (message.alerts !== undefined) {
      obj.alerts = AlertConfig.toJSON(message.alerts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GlobalSettings>, I>>(base?: I): GlobalSettings {
    return GlobalSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GlobalSettings>, I>>(object: I): GlobalSettings {
    const message = createBaseGlobalSettings();
    message.mcpListenAddress = object.mcpListenAddress ?? "";
    message.logLevel = object.logLevel ?? 0;
    message.apiKey = object.apiKey ?? "";
    message.logFormat = object.logFormat ?? 0;
    message.dbPath = object.dbPath ?? "";
    message.dbDsn = object.dbDsn ?? "";
    message.dbDriver = object.dbDriver ?? "";
    message.githubApiUrl = object.githubApiUrl ?? "";
    message.useSudoForDocker = object.useSudoForDocker ?? false;
    message.messageBus = (object.messageBus !== undefined && object.messageBus !== null)
      ? MessageBus.fromPartial(object.messageBus)
      : undefined;
    message.audit = (object.audit !== undefined && object.audit !== null)
      ? AuditConfig.fromPartial(object.audit)
      : undefined;
    message.dlp = (object.dlp !== undefined && object.dlp !== null) ? DLPConfig.fromPartial(object.dlp) : undefined;
    message.gcSettings = (object.gcSettings !== undefined && object.gcSettings !== null)
      ? GCSettings.fromPartial(object.gcSettings)
      : undefined;
    message.oidc = (object.oidc !== undefined && object.oidc !== null)
      ? OIDCConfig.fromPartial(object.oidc)
      : undefined;
    message.rateLimit = (object.rateLimit !== undefined && object.rateLimit !== null)
      ? RateLimitConfig.fromPartial(object.rateLimit)
      : undefined;
    message.telemetry = (object.telemetry !== undefined && object.telemetry !== null)
      ? TelemetryConfig.fromPartial(object.telemetry)
      : undefined;
    message.profiles = object.profiles?.map((e) => e) || [];
    message.allowedIps = object.allowedIps?.map((e) => e) || [];
    message.profileDefinitions = object.profileDefinitions?.map((e) => ProfileDefinition.fromPartial(e)) || [];
    message.middlewares = object.middlewares?.map((e) => Middleware.fromPartial(e)) || [];
    message.allowedFilePaths = object.allowedFilePaths?.map((e) => e) || [];
    message.allowedOrigins = object.allowedOrigins?.map((e) => e) || [];
    message.contextOptimizer = (object.contextOptimizer !== undefined && object.contextOptimizer !== null)
      ? ContextOptimizerConfig.fromPartial(object.contextOptimizer)
      : undefined;
    message.debugger = (object.debugger !== undefined && object.debugger !== null)
      ? DebuggerConfig.fromPartial(object.debugger)
      : undefined;
    message.readOnly = object.readOnly ?? false;
    message.autoDiscoverLocal = object.autoDiscoverLocal ?? false;
    message.alerts = (object.alerts !== undefined && object.alerts !== null)
      ? AlertConfig.fromPartial(object.alerts)
      : undefined;
    return message;
  },
};

function createBaseAlertConfig(): AlertConfig {
  return { enabled: false, webhookUrl: "" };
}

export const AlertConfig: MessageFns<AlertConfig> = {
  encode(message: AlertConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.webhookUrl !== "") {
      writer.uint32(18).string(message.webhookUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.webhookUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      webhookUrl: isSet(object.webhook_url) ? globalThis.String(object.webhook_url) : "",
    };
  },

  toJSON(message: AlertConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.webhookUrl !== "") {
      obj.webhook_url = message.webhookUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlertConfig>, I>>(base?: I): AlertConfig {
    return AlertConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlertConfig>, I>>(object: I): AlertConfig {
    const message = createBaseAlertConfig();
    message.enabled = object.enabled ?? false;
    message.webhookUrl = object.webhookUrl ?? "";
    return message;
  },
};

function createBaseContextOptimizerConfig(): ContextOptimizerConfig {
  return { maxChars: 0 };
}

export const ContextOptimizerConfig: MessageFns<ContextOptimizerConfig> = {
  encode(message: ContextOptimizerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxChars !== 0) {
      writer.uint32(8).int32(message.maxChars);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContextOptimizerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextOptimizerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxChars = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextOptimizerConfig {
    return { maxChars: isSet(object.max_chars) ? globalThis.Number(object.max_chars) : 0 };
  },

  toJSON(message: ContextOptimizerConfig): unknown {
    const obj: any = {};
    if (message.maxChars !== 0) {
      obj.max_chars = Math.round(message.maxChars);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextOptimizerConfig>, I>>(base?: I): ContextOptimizerConfig {
    return ContextOptimizerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextOptimizerConfig>, I>>(object: I): ContextOptimizerConfig {
    const message = createBaseContextOptimizerConfig();
    message.maxChars = object.maxChars ?? 0;
    return message;
  },
};

function createBaseDebuggerConfig(): DebuggerConfig {
  return { enabled: false, size: 0 };
}

export const DebuggerConfig: MessageFns<DebuggerConfig> = {
  encode(message: DebuggerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.size !== 0) {
      writer.uint32(16).int32(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebuggerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebuggerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebuggerConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: DebuggerConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebuggerConfig>, I>>(base?: I): DebuggerConfig {
    return DebuggerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebuggerConfig>, I>>(object: I): DebuggerConfig {
    const message = createBaseDebuggerConfig();
    message.enabled = object.enabled ?? false;
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseTelemetryConfig(): TelemetryConfig {
  return { tracesExporter: "", metricsExporter: "", otlpEndpoint: "", serviceName: "" };
}

export const TelemetryConfig: MessageFns<TelemetryConfig> = {
  encode(message: TelemetryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tracesExporter !== "") {
      writer.uint32(10).string(message.tracesExporter);
    }
    if (message.metricsExporter !== "") {
      writer.uint32(18).string(message.metricsExporter);
    }
    if (message.otlpEndpoint !== "") {
      writer.uint32(26).string(message.otlpEndpoint);
    }
    if (message.serviceName !== "") {
      writer.uint32(34).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TelemetryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tracesExporter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metricsExporter = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otlpEndpoint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TelemetryConfig {
    return {
      tracesExporter: isSet(object.traces_exporter) ? globalThis.String(object.traces_exporter) : "",
      metricsExporter: isSet(object.metrics_exporter) ? globalThis.String(object.metrics_exporter) : "",
      otlpEndpoint: isSet(object.otlp_endpoint) ? globalThis.String(object.otlp_endpoint) : "",
      serviceName: isSet(object.service_name) ? globalThis.String(object.service_name) : "",
    };
  },

  toJSON(message: TelemetryConfig): unknown {
    const obj: any = {};
    if (message.tracesExporter !== "") {
      obj.traces_exporter = message.tracesExporter;
    }
    if (message.metricsExporter !== "") {
      obj.metrics_exporter = message.metricsExporter;
    }
    if (message.otlpEndpoint !== "") {
      obj.otlp_endpoint = message.otlpEndpoint;
    }
    if (message.serviceName !== "") {
      obj.service_name = message.serviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TelemetryConfig>, I>>(base?: I): TelemetryConfig {
    return TelemetryConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TelemetryConfig>, I>>(object: I): TelemetryConfig {
    const message = createBaseTelemetryConfig();
    message.tracesExporter = object.tracesExporter ?? "";
    message.metricsExporter = object.metricsExporter ?? "";
    message.otlpEndpoint = object.otlpEndpoint ?? "";
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseOIDCConfig(): OIDCConfig {
  return { issuer: "", clientId: "", clientSecret: "", redirectUrl: "" };
}

export const OIDCConfig: MessageFns<OIDCConfig> = {
  encode(message: OIDCConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.clientSecret !== "") {
      writer.uint32(26).string(message.clientSecret);
    }
    if (message.redirectUrl !== "") {
      writer.uint32(34).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OIDCConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOIDCConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OIDCConfig {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      clientSecret: isSet(object.client_secret) ? globalThis.String(object.client_secret) : "",
      redirectUrl: isSet(object.redirect_url) ? globalThis.String(object.redirect_url) : "",
    };
  },

  toJSON(message: OIDCConfig): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.clientSecret !== "") {
      obj.client_secret = message.clientSecret;
    }
    if (message.redirectUrl !== "") {
      obj.redirect_url = message.redirectUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OIDCConfig>, I>>(base?: I): OIDCConfig {
    return OIDCConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OIDCConfig>, I>>(object: I): OIDCConfig {
    const message = createBaseOIDCConfig();
    message.issuer = object.issuer ?? "";
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.redirectUrl = object.redirectUrl ?? "";
    return message;
  },
};

function createBaseGCSettings(): GCSettings {
  return { enabled: false, interval: "", ttl: "", paths: [] };
}

export const GCSettings: MessageFns<GCSettings> = {
  encode(message: GCSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.interval !== "") {
      writer.uint32(18).string(message.interval);
    }
    if (message.ttl !== "") {
      writer.uint32(26).string(message.ttl);
    }
    for (const v of message.paths) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GCSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGCSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interval = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ttl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paths.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GCSettings {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      interval: isSet(object.interval) ? globalThis.String(object.interval) : "",
      ttl: isSet(object.ttl) ? globalThis.String(object.ttl) : "",
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GCSettings): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.interval !== "") {
      obj.interval = message.interval;
    }
    if (message.ttl !== "") {
      obj.ttl = message.ttl;
    }
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GCSettings>, I>>(base?: I): GCSettings {
    return GCSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GCSettings>, I>>(object: I): GCSettings {
    const message = createBaseGCSettings();
    message.enabled = object.enabled ?? false;
    message.interval = object.interval ?? "";
    message.ttl = object.ttl ?? "";
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  },
};

function createBaseDLPConfig(): DLPConfig {
  return { enabled: false, customPatterns: [] };
}

export const DLPConfig: MessageFns<DLPConfig> = {
  encode(message: DLPConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.customPatterns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DLPConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDLPConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customPatterns.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DLPConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      customPatterns: globalThis.Array.isArray(object?.custom_patterns)
        ? object.custom_patterns.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DLPConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.customPatterns?.length) {
      obj.custom_patterns = message.customPatterns;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DLPConfig>, I>>(base?: I): DLPConfig {
    return DLPConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DLPConfig>, I>>(object: I): DLPConfig {
    const message = createBaseDLPConfig();
    message.enabled = object.enabled ?? false;
    message.customPatterns = object.customPatterns?.map((e) => e) || [];
    return message;
  },
};

function createBaseAuditConfig(): AuditConfig {
  return {
    enabled: false,
    outputPath: "",
    logArguments: false,
    logResults: false,
    storageType: 0,
    webhookUrl: "",
    webhookHeaders: {},
    splunk: undefined,
    datadog: undefined,
  };
}

export const AuditConfig: MessageFns<AuditConfig> = {
  encode(message: AuditConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.outputPath !== "") {
      writer.uint32(18).string(message.outputPath);
    }
    if (message.logArguments !== false) {
      writer.uint32(24).bool(message.logArguments);
    }
    if (message.logResults !== false) {
      writer.uint32(32).bool(message.logResults);
    }
    if (message.storageType !== 0) {
      writer.uint32(40).int32(message.storageType);
    }
    if (message.webhookUrl !== "") {
      writer.uint32(50).string(message.webhookUrl);
    }
    globalThis.Object.entries(message.webhookHeaders).forEach(([key, value]: [string, string]) => {
      AuditConfig_WebhookHeadersEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.splunk !== undefined) {
      SplunkConfig.encode(message.splunk, writer.uint32(66).fork()).join();
    }
    if (message.datadog !== undefined) {
      DatadogConfig.encode(message.datadog, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.logArguments = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.logResults = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storageType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.webhookUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = AuditConfig_WebhookHeadersEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.webhookHeaders[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.splunk = SplunkConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.datadog = DatadogConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      outputPath: isSet(object.output_path) ? globalThis.String(object.output_path) : "",
      logArguments: isSet(object.log_arguments) ? globalThis.Boolean(object.log_arguments) : false,
      logResults: isSet(object.log_results) ? globalThis.Boolean(object.log_results) : false,
      storageType: isSet(object.storage_type) ? auditConfig_StorageTypeFromJSON(object.storage_type) : 0,
      webhookUrl: isSet(object.webhook_url) ? globalThis.String(object.webhook_url) : "",
      webhookHeaders: isObject(object.webhook_headers)
        ? (globalThis.Object.entries(object.webhook_headers) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      splunk: isSet(object.splunk) ? SplunkConfig.fromJSON(object.splunk) : undefined,
      datadog: isSet(object.datadog) ? DatadogConfig.fromJSON(object.datadog) : undefined,
    };
  },

  toJSON(message: AuditConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.outputPath !== "") {
      obj.output_path = message.outputPath;
    }
    if (message.logArguments !== false) {
      obj.log_arguments = message.logArguments;
    }
    if (message.logResults !== false) {
      obj.log_results = message.logResults;
    }
    if (message.storageType !== 0) {
      obj.storage_type = auditConfig_StorageTypeToJSON(message.storageType);
    }
    if (message.webhookUrl !== "") {
      obj.webhook_url = message.webhookUrl;
    }
    if (message.webhookHeaders) {
      const entries = globalThis.Object.entries(message.webhookHeaders) as [string, string][];
      if (entries.length > 0) {
        obj.webhook_headers = {};
        entries.forEach(([k, v]) => {
          obj.webhook_headers[k] = v;
        });
      }
    }
    if (message.splunk !== undefined) {
      obj.splunk = SplunkConfig.toJSON(message.splunk);
    }
    if (message.datadog !== undefined) {
      obj.datadog = DatadogConfig.toJSON(message.datadog);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditConfig>, I>>(base?: I): AuditConfig {
    return AuditConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditConfig>, I>>(object: I): AuditConfig {
    const message = createBaseAuditConfig();
    message.enabled = object.enabled ?? false;
    message.outputPath = object.outputPath ?? "";
    message.logArguments = object.logArguments ?? false;
    message.logResults = object.logResults ?? false;
    message.storageType = object.storageType ?? 0;
    message.webhookUrl = object.webhookUrl ?? "";
    message.webhookHeaders = (globalThis.Object.entries(object.webhookHeaders ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.splunk = (object.splunk !== undefined && object.splunk !== null)
      ? SplunkConfig.fromPartial(object.splunk)
      : undefined;
    message.datadog = (object.datadog !== undefined && object.datadog !== null)
      ? DatadogConfig.fromPartial(object.datadog)
      : undefined;
    return message;
  },
};

function createBaseAuditConfig_WebhookHeadersEntry(): AuditConfig_WebhookHeadersEntry {
  return { key: "", value: "" };
}

export const AuditConfig_WebhookHeadersEntry: MessageFns<AuditConfig_WebhookHeadersEntry> = {
  encode(message: AuditConfig_WebhookHeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditConfig_WebhookHeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditConfig_WebhookHeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditConfig_WebhookHeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AuditConfig_WebhookHeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditConfig_WebhookHeadersEntry>, I>>(base?: I): AuditConfig_WebhookHeadersEntry {
    return AuditConfig_WebhookHeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditConfig_WebhookHeadersEntry>, I>>(
    object: I,
  ): AuditConfig_WebhookHeadersEntry {
    const message = createBaseAuditConfig_WebhookHeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSplunkConfig(): SplunkConfig {
  return { hecUrl: "", token: "", index: "", source: "", sourcetype: "" };
}

export const SplunkConfig: MessageFns<SplunkConfig> = {
  encode(message: SplunkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hecUrl !== "") {
      writer.uint32(10).string(message.hecUrl);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.index !== "") {
      writer.uint32(26).string(message.index);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    if (message.sourcetype !== "") {
      writer.uint32(42).string(message.sourcetype);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplunkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplunkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hecUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.index = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sourcetype = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplunkConfig {
    return {
      hecUrl: isSet(object.hec_url) ? globalThis.String(object.hec_url) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      sourcetype: isSet(object.sourcetype) ? globalThis.String(object.sourcetype) : "",
    };
  },

  toJSON(message: SplunkConfig): unknown {
    const obj: any = {};
    if (message.hecUrl !== "") {
      obj.hec_url = message.hecUrl;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.sourcetype !== "") {
      obj.sourcetype = message.sourcetype;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SplunkConfig>, I>>(base?: I): SplunkConfig {
    return SplunkConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SplunkConfig>, I>>(object: I): SplunkConfig {
    const message = createBaseSplunkConfig();
    message.hecUrl = object.hecUrl ?? "";
    message.token = object.token ?? "";
    message.index = object.index ?? "";
    message.source = object.source ?? "";
    message.sourcetype = object.sourcetype ?? "";
    return message;
  },
};

function createBaseDatadogConfig(): DatadogConfig {
  return { apiKey: "", site: "", service: "", tags: "" };
}

export const DatadogConfig: MessageFns<DatadogConfig> = {
  encode(message: DatadogConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== "") {
      writer.uint32(10).string(message.apiKey);
    }
    if (message.site !== "") {
      writer.uint32(18).string(message.site);
    }
    if (message.service !== "") {
      writer.uint32(26).string(message.service);
    }
    if (message.tags !== "") {
      writer.uint32(34).string(message.tags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatadogConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatadogConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.site = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatadogConfig {
    return {
      apiKey: isSet(object.api_key) ? globalThis.String(object.api_key) : "",
      site: isSet(object.site) ? globalThis.String(object.site) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      tags: isSet(object.tags) ? globalThis.String(object.tags) : "",
    };
  },

  toJSON(message: DatadogConfig): unknown {
    const obj: any = {};
    if (message.apiKey !== "") {
      obj.api_key = message.apiKey;
    }
    if (message.site !== "") {
      obj.site = message.site;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.tags !== "") {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DatadogConfig>, I>>(base?: I): DatadogConfig {
    return DatadogConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DatadogConfig>, I>>(object: I): DatadogConfig {
    const message = createBaseDatadogConfig();
    message.apiKey = object.apiKey ?? "";
    message.site = object.site ?? "";
    message.service = object.service ?? "";
    message.tags = object.tags ?? "";
    return message;
  },
};

function createBaseProfileDefinition(): ProfileDefinition {
  return { name: "", selector: undefined, requiredRoles: [], parentProfileIds: [], serviceConfig: {}, secrets: {} };
}

export const ProfileDefinition: MessageFns<ProfileDefinition> = {
  encode(message: ProfileDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selector !== undefined) {
      ProfileSelector.encode(message.selector, writer.uint32(18).fork()).join();
    }
    for (const v of message.requiredRoles) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.parentProfileIds) {
      writer.uint32(34).string(v!);
    }
    globalThis.Object.entries(message.serviceConfig).forEach(([key, value]: [string, ProfileServiceConfig]) => {
      ProfileDefinition_ServiceConfigEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    globalThis.Object.entries(message.secrets).forEach(([key, value]: [string, SecretValue]) => {
      ProfileDefinition_SecretsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selector = ProfileSelector.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requiredRoles.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentProfileIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = ProfileDefinition_ServiceConfigEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.serviceConfig[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = ProfileDefinition_SecretsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.secrets[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selector: isSet(object.selector) ? ProfileSelector.fromJSON(object.selector) : undefined,
      requiredRoles: globalThis.Array.isArray(object?.required_roles)
        ? object.required_roles.map((e: any) => globalThis.String(e))
        : [],
      parentProfileIds: globalThis.Array.isArray(object?.parent_profile_ids)
        ? object.parent_profile_ids.map((e: any) => globalThis.String(e))
        : [],
      serviceConfig: isObject(object.service_config)
        ? (globalThis.Object.entries(object.service_config) as [string, any][]).reduce(
          (acc: { [key: string]: ProfileServiceConfig }, [key, value]: [string, any]) => {
            acc[key] = ProfileServiceConfig.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      secrets: isObject(object.secrets)
        ? (globalThis.Object.entries(object.secrets) as [string, any][]).reduce(
          (acc: { [key: string]: SecretValue }, [key, value]: [string, any]) => {
            acc[key] = SecretValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ProfileDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selector !== undefined) {
      obj.selector = ProfileSelector.toJSON(message.selector);
    }
    if (message.requiredRoles?.length) {
      obj.required_roles = message.requiredRoles;
    }
    if (message.parentProfileIds?.length) {
      obj.parent_profile_ids = message.parentProfileIds;
    }
    if (message.serviceConfig) {
      const entries = globalThis.Object.entries(message.serviceConfig) as [string, ProfileServiceConfig][];
      if (entries.length > 0) {
        obj.service_config = {};
        entries.forEach(([k, v]) => {
          obj.service_config[k] = ProfileServiceConfig.toJSON(v);
        });
      }
    }
    if (message.secrets) {
      const entries = globalThis.Object.entries(message.secrets) as [string, SecretValue][];
      if (entries.length > 0) {
        obj.secrets = {};
        entries.forEach(([k, v]) => {
          obj.secrets[k] = SecretValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileDefinition>, I>>(base?: I): ProfileDefinition {
    return ProfileDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileDefinition>, I>>(object: I): ProfileDefinition {
    const message = createBaseProfileDefinition();
    message.name = object.name ?? "";
    message.selector = (object.selector !== undefined && object.selector !== null)
      ? ProfileSelector.fromPartial(object.selector)
      : undefined;
    message.requiredRoles = object.requiredRoles?.map((e) => e) || [];
    message.parentProfileIds = object.parentProfileIds?.map((e) => e) || [];
    message.serviceConfig = (globalThis.Object.entries(object.serviceConfig ?? {}) as [string, ProfileServiceConfig][])
      .reduce((acc: { [key: string]: ProfileServiceConfig }, [key, value]: [string, ProfileServiceConfig]) => {
        if (value !== undefined) {
          acc[key] = ProfileServiceConfig.fromPartial(value);
        }
        return acc;
      }, {});
    message.secrets = (globalThis.Object.entries(object.secrets ?? {}) as [string, SecretValue][]).reduce(
      (acc: { [key: string]: SecretValue }, [key, value]: [string, SecretValue]) => {
        if (value !== undefined) {
          acc[key] = SecretValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProfileDefinition_ServiceConfigEntry(): ProfileDefinition_ServiceConfigEntry {
  return { key: "", value: undefined };
}

export const ProfileDefinition_ServiceConfigEntry: MessageFns<ProfileDefinition_ServiceConfigEntry> = {
  encode(message: ProfileDefinition_ServiceConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ProfileServiceConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileDefinition_ServiceConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileDefinition_ServiceConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProfileServiceConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileDefinition_ServiceConfigEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ProfileServiceConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProfileDefinition_ServiceConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ProfileServiceConfig.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileDefinition_ServiceConfigEntry>, I>>(
    base?: I,
  ): ProfileDefinition_ServiceConfigEntry {
    return ProfileDefinition_ServiceConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileDefinition_ServiceConfigEntry>, I>>(
    object: I,
  ): ProfileDefinition_ServiceConfigEntry {
    const message = createBaseProfileDefinition_ServiceConfigEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ProfileServiceConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProfileDefinition_SecretsEntry(): ProfileDefinition_SecretsEntry {
  return { key: "", value: undefined };
}

export const ProfileDefinition_SecretsEntry: MessageFns<ProfileDefinition_SecretsEntry> = {
  encode(message: ProfileDefinition_SecretsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecretValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileDefinition_SecretsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileDefinition_SecretsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileDefinition_SecretsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecretValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProfileDefinition_SecretsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecretValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileDefinition_SecretsEntry>, I>>(base?: I): ProfileDefinition_SecretsEntry {
    return ProfileDefinition_SecretsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileDefinition_SecretsEntry>, I>>(
    object: I,
  ): ProfileDefinition_SecretsEntry {
    const message = createBaseProfileDefinition_SecretsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProfileSelector(): ProfileSelector {
  return { tags: [], toolProperties: {} };
}

export const ProfileSelector: MessageFns<ProfileSelector> = {
  encode(message: ProfileSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      writer.uint32(10).string(v!);
    }
    globalThis.Object.entries(message.toolProperties).forEach(([key, value]: [string, string]) => {
      ProfileSelector_ToolPropertiesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProfileSelector_ToolPropertiesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.toolProperties[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileSelector {
    return {
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      toolProperties: isObject(object.tool_properties)
        ? (globalThis.Object.entries(object.tool_properties) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ProfileSelector): unknown {
    const obj: any = {};
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.toolProperties) {
      const entries = globalThis.Object.entries(message.toolProperties) as [string, string][];
      if (entries.length > 0) {
        obj.tool_properties = {};
        entries.forEach(([k, v]) => {
          obj.tool_properties[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileSelector>, I>>(base?: I): ProfileSelector {
    return ProfileSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileSelector>, I>>(object: I): ProfileSelector {
    const message = createBaseProfileSelector();
    message.tags = object.tags?.map((e) => e) || [];
    message.toolProperties = (globalThis.Object.entries(object.toolProperties ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProfileSelector_ToolPropertiesEntry(): ProfileSelector_ToolPropertiesEntry {
  return { key: "", value: "" };
}

export const ProfileSelector_ToolPropertiesEntry: MessageFns<ProfileSelector_ToolPropertiesEntry> = {
  encode(message: ProfileSelector_ToolPropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileSelector_ToolPropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileSelector_ToolPropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileSelector_ToolPropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ProfileSelector_ToolPropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileSelector_ToolPropertiesEntry>, I>>(
    base?: I,
  ): ProfileSelector_ToolPropertiesEntry {
    return ProfileSelector_ToolPropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileSelector_ToolPropertiesEntry>, I>>(
    object: I,
  ): ProfileSelector_ToolPropertiesEntry {
    const message = createBaseProfileSelector_ToolPropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMiddleware(): Middleware {
  return { name: "", priority: 0, disabled: false };
}

export const Middleware: MessageFns<Middleware> = {
  encode(message: Middleware, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.priority !== 0) {
      writer.uint32(16).int32(message.priority);
    }
    if (message.disabled !== false) {
      writer.uint32(24).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Middleware {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMiddleware();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Middleware {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: Middleware): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Middleware>, I>>(base?: I): Middleware {
    return Middleware.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Middleware>, I>>(object: I): Middleware {
    const message = createBaseMiddleware();
    message.name = object.name ?? "";
    message.priority = object.priority ?? 0;
    message.disabled = object.disabled ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
