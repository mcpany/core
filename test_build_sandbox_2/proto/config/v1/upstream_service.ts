// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: proto/config/v1/upstream_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../google/protobuf/duration";
import { Authentication, SecretValue } from "./auth";
import {
  CacheConfig,
  CommandLineCallDefinition,
  GraphQLCallDefinition,
  GrpcCallDefinition,
  HttpCallDefinition,
  MCPCallDefinition,
  OpenAPICallDefinition,
  SqlCallDefinition,
  WebrtcCallDefinition,
  WebsocketCallDefinition,
} from "./call";
import {
  CommandLineHealthCheck,
  GrpcHealthCheck,
  HttpHealthCheck,
  WebRTCHealthCheck,
  WebsocketHealthCheck,
} from "./health_check";
import { RateLimitConfig } from "./profile";
import { PromptDefinition } from "./prompt";
import { ResourceDefinition } from "./resource";
import { ToolDefinition } from "./tool";
import { WebhookConfig } from "./webhook";

export const protobufPackage = "mcpany.config.v1";

/** Defines strategies for load balancing across multiple service endpoints. */
export enum LoadBalancingStrategy {
  /** ROUND_ROBIN - Distributes requests sequentially among the available servers. */
  ROUND_ROBIN = 0,
  /** LEAST_CONNECTIONS - Sends the next request to the server that has the fewest active connections. */
  LEAST_CONNECTIONS = 1,
  /** RANDOM - Selects a server at random. */
  RANDOM = 2,
  UNRECOGNIZED = -1,
}

export function loadBalancingStrategyFromJSON(object: any): LoadBalancingStrategy {
  switch (object) {
    case 0:
    case "ROUND_ROBIN":
      return LoadBalancingStrategy.ROUND_ROBIN;
    case 1:
    case "LEAST_CONNECTIONS":
      return LoadBalancingStrategy.LEAST_CONNECTIONS;
    case 2:
    case "RANDOM":
      return LoadBalancingStrategy.RANDOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancingStrategy.UNRECOGNIZED;
  }
}

export function loadBalancingStrategyToJSON(object: LoadBalancingStrategy): string {
  switch (object) {
    case LoadBalancingStrategy.ROUND_ROBIN:
      return "ROUND_ROBIN";
    case LoadBalancingStrategy.LEAST_CONNECTIONS:
      return "LEAST_CONNECTIONS";
    case LoadBalancingStrategy.RANDOM:
      return "RANDOM";
    case LoadBalancingStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * UpstreamServiceConfig is the top-level configuration for a single upstream service
 * that mcpany will proxy. It defines the service's identity, how to connect to it,
 * and policies like authentication, caching, rate limiting, and load balancing.
 */
export interface UpstreamServiceConfig {
  /**
   * The original user-provided name for the upstream service.
   * This name is used for identification, logging, and metrics.
   */
  name: string;
  /**
   * The full SHA256 hash of the service name, used as a unique identifier.
   * This ensures that for the same service name, the ID is always the same.
   */
  id: string;
  /**
   * A sanitized version of the service name, conforming to identifier rules.
   * @inject_tag: yaml:"-"
   *
   * This field is managed internally and should not be set by the user.
   */
  sanitizedName: string;
  /** The version of the upstream service, if known (e.g., "v1.2.3"). */
  version: string;
  /** The priority of the service. Lower numbers have higher priority. */
  priority: number;
  /** If true, this upstream service is disabled. */
  disable: boolean;
  /** If true, automatically convert all API calls to tools. */
  autoDiscoverTool: boolean;
  /**
   * The configuration error if the service failed validation.
   * @inject_tag: yaml:"-"
   */
  configError: string;
  /**
   * If true, this service configuration is read-only (e.g., loaded from a file).
   * @inject_tag: yaml:"-"
   */
  readOnly: boolean;
  /**
   * The last error message encountered by the service (e.g. health check failure).
   * @inject_tag: yaml:"-"
   */
  lastError: string;
  /**
   * The number of tools registered for this service.
   * @inject_tag: yaml:"-"
   */
  toolCount: number;
  /** Configuration for the pool of connections to the upstream service. */
  connectionPool?:
    | ConnectionPoolConfig
    | undefined;
  /** Authentication configuration for mcpany to use when connecting to the upstream service (outgoing). */
  upstreamAuth?:
    | Authentication
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** Rate limiting to protect the upstream service from being overwhelmed. */
  rateLimit?:
    | RateLimitConfig
    | undefined;
  /** Strategy for distributing requests among multiple instances of the service. */
  loadBalancingStrategy: LoadBalancingStrategy;
  /** Advanced resiliency features to handle failures gracefully. */
  resilience?:
    | ResilienceConfig
    | undefined;
  /** Authentication configuration for securing access to this service (incoming). */
  authentication?:
    | Authentication
    | undefined;
  /** Policies to control what is exported to the client. */
  toolExportPolicy?: ExportPolicy | undefined;
  promptExportPolicy?: ExportPolicy | undefined;
  resourceExportPolicy?: ExportPolicy | undefined;
  mcpService?: McpUpstreamService | undefined;
  httpService?: HttpUpstreamService | undefined;
  grpcService?: GrpcUpstreamService | undefined;
  openapiService?: OpenapiUpstreamService | undefined;
  commandLineService?: CommandLineUpstreamService | undefined;
  websocketService?: WebsocketUpstreamService | undefined;
  webrtcService?: WebrtcUpstreamService | undefined;
  graphqlService?: GraphQLUpstreamService | undefined;
  sqlService?: SqlUpstreamService | undefined;
  filesystemService?: FilesystemUpstreamService | undefined;
  vectorService?:
    | VectorUpstreamService
    | undefined;
  /** Policy to control which calls can be made. */
  callPolicies: CallPolicy[];
  /** List of hooks to execute before the call. */
  preCallHooks: CallHook[];
  /** List of hooks to execute after the call. */
  postCallHooks: CallHook[];
  /** The prompts provided by this upstream service. */
  prompts: PromptDefinition[];
  /** Tags for organizing and filtering services. */
  tags: string[];
  /**
   * JSON Schema string defining the configuration parameters (env vars, args) required by this service.
   * This is used by the UI to generate a configuration form.
   */
  configurationSchema: string;
}

export interface CallPolicy {
  /** Default action if no rules match. */
  defaultAction: CallPolicy_Action;
  /** List of rules to apply. First match wins. */
  rules: CallPolicyRule[];
}

export enum CallPolicy_Action {
  ALLOW = 0,
  DENY = 1,
  SAVE_CACHE = 2,
  DELETE_CACHE = 3,
  UNRECOGNIZED = -1,
}

export function callPolicy_ActionFromJSON(object: any): CallPolicy_Action {
  switch (object) {
    case 0:
    case "ALLOW":
      return CallPolicy_Action.ALLOW;
    case 1:
    case "DENY":
      return CallPolicy_Action.DENY;
    case 2:
    case "SAVE_CACHE":
      return CallPolicy_Action.SAVE_CACHE;
    case 3:
    case "DELETE_CACHE":
      return CallPolicy_Action.DELETE_CACHE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CallPolicy_Action.UNRECOGNIZED;
  }
}

export function callPolicy_ActionToJSON(object: CallPolicy_Action): string {
  switch (object) {
    case CallPolicy_Action.ALLOW:
      return "ALLOW";
    case CallPolicy_Action.DENY:
      return "DENY";
    case CallPolicy_Action.SAVE_CACHE:
      return "SAVE_CACHE";
    case CallPolicy_Action.DELETE_CACHE:
      return "DELETE_CACHE";
    case CallPolicy_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CallPolicyRule {
  action: CallPolicy_Action;
  /** Regex to match the call name. Empty means match all. */
  nameRegex: string;
  /**
   * Regex to match request arguments (JSON stringified). Empty means match all.
   * This is a simple regex match on the JSON representation of arguments.
   */
  argumentRegex: string;
  /** Regex to match endpoint path or URL. */
  urlRegex: string;
  /** Regex to match call ID. Empty means match all. */
  callIdRegex: string;
}

export interface ExportPolicy {
  defaultAction: ExportPolicy_Action;
  rules: ExportRule[];
}

export enum ExportPolicy_Action {
  EXPORT_ACTION_UNSPECIFIED = 0,
  EXPORT = 1,
  UNEXPORT = 2,
  UNRECOGNIZED = -1,
}

export function exportPolicy_ActionFromJSON(object: any): ExportPolicy_Action {
  switch (object) {
    case 0:
    case "EXPORT_ACTION_UNSPECIFIED":
      return ExportPolicy_Action.EXPORT_ACTION_UNSPECIFIED;
    case 1:
    case "EXPORT":
      return ExportPolicy_Action.EXPORT;
    case 2:
    case "UNEXPORT":
      return ExportPolicy_Action.UNEXPORT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportPolicy_Action.UNRECOGNIZED;
  }
}

export function exportPolicy_ActionToJSON(object: ExportPolicy_Action): string {
  switch (object) {
    case ExportPolicy_Action.EXPORT_ACTION_UNSPECIFIED:
      return "EXPORT_ACTION_UNSPECIFIED";
    case ExportPolicy_Action.EXPORT:
      return "EXPORT";
    case ExportPolicy_Action.UNEXPORT:
      return "UNEXPORT";
    case ExportPolicy_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ExportRule {
  /** Regex to match the name (tool, prompt, or resource). */
  nameRegex: string;
  action: ExportPolicy_Action;
}

export interface CallHook {
  name: string;
  webhook?: WebhookConfig | undefined;
  callPolicy?: CallPolicy | undefined;
}

/** GrpcUpstreamService defines an upstream service that speaks gRPC. */
export interface GrpcUpstreamService {
  /** The address of the gRPC server (e.g., "localhost:50051"). */
  address: string;
  /** If true, mcpany will use gRPC reflection to discover services and methods. */
  useReflection: boolean;
  /** TLS configuration for the gRPC connection. */
  tlsConfig?:
    | TLSConfig
    | undefined;
  /** Manually defined mappings from MCP tools to gRPC calls. */
  tools: ToolDefinition[];
  /** Health check configuration. */
  healthCheck?:
    | GrpcHealthCheck
    | undefined;
  /** A list of protobuf definitions for the gRPC service. */
  protoDefinitions: ProtoDefinition[];
  /** A collection of protobuf files to be discovered. */
  protoCollection: ProtoCollection[];
  /** A list of resources served by this service. */
  resources: ResourceDefinition[];
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: GrpcCallDefinition };
  /** The prompts provided by this upstream service. */
  prompts: PromptDefinition[];
}

export interface GrpcUpstreamService_CallsEntry {
  key: string;
  value?: GrpcCallDefinition | undefined;
}

export interface ProtoDefinition {
  protoFile?: ProtoFile | undefined;
  protoDescriptor?: ProtoDescriptor | undefined;
}

export interface ProtoFile {
  fileName: string;
  fileContent?: string | undefined;
  filePath?: string | undefined;
}

export interface ProtoDescriptor {
  fileName: string;
  filePath?: string | undefined;
}

export interface ProtoCollection {
  rootPath: string;
  pathMatchRegex: string;
  isRecursive: boolean;
}

/** HttpUpstreamService defines an upstream service that speaks HTTP. */
export interface HttpUpstreamService {
  /** The base URL of the HTTP service (e.g., "https://api.example.com"). */
  address: string;
  /** Manually defined mappings from MCP tools to HTTP calls. */
  tools: ToolDefinition[];
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: HttpCallDefinition };
  /** Configuration for checking the health of the HTTP service. */
  healthCheck?:
    | HttpHealthCheck
    | undefined;
  /** TLS configuration for the HTTP connection. */
  tlsConfig?:
    | TLSConfig
    | undefined;
  /** A list of resources served by this service. */
  resources: ResourceDefinition[];
  /** A list of prompts served by this service. */
  prompts: PromptDefinition[];
}

export interface HttpUpstreamService_CallsEntry {
  key: string;
  value?: HttpCallDefinition | undefined;
}

/** WebsocketUpstreamService defines an upstream service that communicates over Websocket. */
export interface WebsocketUpstreamService {
  /** The URL of the Websocket service (e.g., "ws://api.example.com/ws"). */
  address: string;
  /** Manually defined mappings from MCP tools to websocket calls. */
  tools: ToolDefinition[];
  /** TLS configuration for the Websocket connection. */
  tlsConfig?:
    | TLSConfig
    | undefined;
  /** A list of resources served by this service. */
  resources: ResourceDefinition[];
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: WebsocketCallDefinition };
  /** A list of prompts served by this service. */
  prompts: PromptDefinition[];
  /** Health check configuration. */
  healthCheck?: WebsocketHealthCheck | undefined;
}

export interface WebsocketUpstreamService_CallsEntry {
  key: string;
  value?: WebsocketCallDefinition | undefined;
}

/** WebrtcUpstreamService defines an upstream service that communicates over WebRTC data channels. */
export interface WebrtcUpstreamService {
  /** The URL of the WebRTC signaling service (e.g., "http://api.example.com/signal"). */
  address: string;
  /** Manually defined mappings from MCP tools to webrtc calls. */
  tools: ToolDefinition[];
  /** TLS configuration for the signaling connection. */
  tlsConfig?:
    | TLSConfig
    | undefined;
  /** A list of resources served by this service. */
  resources: ResourceDefinition[];
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: WebrtcCallDefinition };
  /** A list of prompts served by this service. */
  prompts: PromptDefinition[];
  /** Health check configuration. */
  healthCheck?: WebRTCHealthCheck | undefined;
}

export interface WebrtcUpstreamService_CallsEntry {
  key: string;
  value?: WebrtcCallDefinition | undefined;
}

/** OpenapiUpstreamService defines a service based on an OpenAPI/Swagger specification. */
export interface OpenapiUpstreamService {
  /** The base URL of the API. */
  address: string;
  /** The OpenAPI specification content (JSON or YAML). */
  specContent?:
    | string
    | undefined;
  /** The URL to fetch the OpenAPI specification from. */
  specUrl?:
    | string
    | undefined;
  /** Health check configuration. */
  healthCheck?:
    | HttpHealthCheck
    | undefined;
  /** TLS configuration for the connection. */
  tlsConfig?:
    | TLSConfig
    | undefined;
  /** Optional: Overrides or specific configurations for calls discovered from the spec. */
  tools: ToolDefinition[];
  /** A list of resources served by this service. */
  resources: ResourceDefinition[];
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: OpenAPICallDefinition };
  /** A list of prompts served by this service. */
  prompts: PromptDefinition[];
}

export interface OpenapiUpstreamService_CallsEntry {
  key: string;
  value?: OpenAPICallDefinition | undefined;
}

/** CommandLineUpstreamService defines a service that communicates over standard I/O. */
export interface CommandLineUpstreamService {
  /** The command to execute the service. */
  command: string;
  /** The working directory for the command. */
  workingDirectory: string;
  /** Manually defined mappings from MCP tools to command line commands. */
  tools: ToolDefinition[];
  /** Health check configuration. */
  healthCheck?:
    | CommandLineHealthCheck
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** Container environment to run the command in. */
  containerEnvironment?:
    | ContainerEnvironment
    | undefined;
  /** Timeout for the command execution. */
  timeout?:
    | Duration
    | undefined;
  /** A list of resources served by this service. */
  resources: ResourceDefinition[];
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: CommandLineCallDefinition };
  /** A list of prompts served by this service. */
  prompts: PromptDefinition[];
  communicationProtocol: CommandLineUpstreamService_CommunicationProtocol;
  /** If true, the command will be executed on the local filesystem. */
  local: boolean;
  /** Environment variables to set for the command (supports secrets). */
  env: { [key: string]: SecretValue };
}

export enum CommandLineUpstreamService_CommunicationProtocol {
  COMMUNICATION_PROTOCOL_UNSPECIFIED = 0,
  COMMUNICATION_PROTOCOL_JSON = 1,
  UNRECOGNIZED = -1,
}

export function commandLineUpstreamService_CommunicationProtocolFromJSON(
  object: any,
): CommandLineUpstreamService_CommunicationProtocol {
  switch (object) {
    case 0:
    case "COMMUNICATION_PROTOCOL_UNSPECIFIED":
      return CommandLineUpstreamService_CommunicationProtocol.COMMUNICATION_PROTOCOL_UNSPECIFIED;
    case 1:
    case "COMMUNICATION_PROTOCOL_JSON":
      return CommandLineUpstreamService_CommunicationProtocol.COMMUNICATION_PROTOCOL_JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandLineUpstreamService_CommunicationProtocol.UNRECOGNIZED;
  }
}

export function commandLineUpstreamService_CommunicationProtocolToJSON(
  object: CommandLineUpstreamService_CommunicationProtocol,
): string {
  switch (object) {
    case CommandLineUpstreamService_CommunicationProtocol.COMMUNICATION_PROTOCOL_UNSPECIFIED:
      return "COMMUNICATION_PROTOCOL_UNSPECIFIED";
    case CommandLineUpstreamService_CommunicationProtocol.COMMUNICATION_PROTOCOL_JSON:
      return "COMMUNICATION_PROTOCOL_JSON";
    case CommandLineUpstreamService_CommunicationProtocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CommandLineUpstreamService_CallsEntry {
  key: string;
  value?: CommandLineCallDefinition | undefined;
}

export interface CommandLineUpstreamService_EnvEntry {
  key: string;
  value?: SecretValue | undefined;
}

/** GraphQLUpstreamService defines an upstream service that speaks GraphQL. */
export interface GraphQLUpstreamService {
  /** The URL of the GraphQL endpoint (e.g., "http://api.example.com/graphql"). */
  address: string;
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: GraphQLCallDefinition };
}

export interface GraphQLUpstreamService_CallsEntry {
  key: string;
  value?: GraphQLCallDefinition | undefined;
}

/** SqlUpstreamService defines an upstream service that speaks SQL. */
export interface SqlUpstreamService {
  /** The driver name (e.g., "postgres", "mysql", "sqlite"). */
  driver: string;
  /** The data source name (DSN) for connecting to the database. */
  dsn: string;
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: SqlCallDefinition };
}

export interface SqlUpstreamService_CallsEntry {
  key: string;
  value?: SqlCallDefinition | undefined;
}

/** FilesystemUpstreamService defines a service that exposes a local filesystem safely. */
export interface FilesystemUpstreamService {
  /**
   * The root directories that are allowed to be accessed.
   * The key is the virtual path (how it appears to the LLM) and the value is the actual local path.
   * Example: {"/workspace": "/home/user/projects/myproject"}
   */
  rootPaths: { [key: string]: string };
  /** If true, file operations are read-only. */
  readOnly: boolean;
  /** Manually defined mappings (usually not needed as we auto-register FS tools). */
  tools: ToolDefinition[];
  /** Resources (files) that are statically or dynamically exposed. */
  resources: ResourceDefinition[];
  /** Prompts that are exposed. */
  prompts: PromptDefinition[];
  /** List of glob patterns for allowed paths. If empty, all paths under roots are allowed. */
  allowedPaths: string[];
  /** List of glob patterns for denied paths. Checked after allowed_paths. */
  deniedPaths: string[];
  /** The policy for following symlinks. */
  symlinkMode: FilesystemUpstreamService_SymlinkMode;
  os?: OsFs | undefined;
  tmpfs?: MemMapFs | undefined;
  http?: HttpFs | undefined;
  zip?: ZipFs | undefined;
  gcs?: GcsFs | undefined;
  sftp?: SftpFs | undefined;
  s3?: S3Fs | undefined;
}

export enum FilesystemUpstreamService_SymlinkMode {
  SYMLINK_MODE_UNSPECIFIED = 0,
  /** ALLOW - Allow all symlinks (still checked against root_paths target). */
  ALLOW = 1,
  /** DENY - Deny all symlinks. */
  DENY = 2,
  /** INTERNAL_ONLY - Allow symlinks only if target is within the same root. */
  INTERNAL_ONLY = 3,
  UNRECOGNIZED = -1,
}

export function filesystemUpstreamService_SymlinkModeFromJSON(object: any): FilesystemUpstreamService_SymlinkMode {
  switch (object) {
    case 0:
    case "SYMLINK_MODE_UNSPECIFIED":
      return FilesystemUpstreamService_SymlinkMode.SYMLINK_MODE_UNSPECIFIED;
    case 1:
    case "ALLOW":
      return FilesystemUpstreamService_SymlinkMode.ALLOW;
    case 2:
    case "DENY":
      return FilesystemUpstreamService_SymlinkMode.DENY;
    case 3:
    case "INTERNAL_ONLY":
      return FilesystemUpstreamService_SymlinkMode.INTERNAL_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FilesystemUpstreamService_SymlinkMode.UNRECOGNIZED;
  }
}

export function filesystemUpstreamService_SymlinkModeToJSON(object: FilesystemUpstreamService_SymlinkMode): string {
  switch (object) {
    case FilesystemUpstreamService_SymlinkMode.SYMLINK_MODE_UNSPECIFIED:
      return "SYMLINK_MODE_UNSPECIFIED";
    case FilesystemUpstreamService_SymlinkMode.ALLOW:
      return "ALLOW";
    case FilesystemUpstreamService_SymlinkMode.DENY:
      return "DENY";
    case FilesystemUpstreamService_SymlinkMode.INTERNAL_ONLY:
      return "INTERNAL_ONLY";
    case FilesystemUpstreamService_SymlinkMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FilesystemUpstreamService_RootPathsEntry {
  key: string;
  value: string;
}

export interface OsFs {
}

export interface MemMapFs {
}

export interface HttpFs {
  endpoint: string;
}

export interface ZipFs {
  filePath: string;
}

export interface GcsFs {
  bucket: string;
}

export interface S3Fs {
  bucket: string;
  region: string;
  accessKeyId: string;
  secretAccessKey: string;
  sessionToken: string;
  endpoint: string;
}

export interface SftpFs {
  address: string;
  username: string;
  password: string;
  keyPath: string;
}

/** VectorUpstreamService defines a service that connects to a vector database. */
export interface VectorUpstreamService {
  pinecone?: PineconeVectorDB | undefined;
  milvus?:
    | MilvusVectorDB
    | undefined;
  /** Manually defined mappings (usually not needed as we auto-register Vector tools). */
  tools: ToolDefinition[];
  /** Resources that are exposed. */
  resources: ResourceDefinition[];
  /** Prompts that are exposed. */
  prompts: PromptDefinition[];
}

export interface PineconeVectorDB {
  apiKey: string;
  /** e.g., "us-west1-gcp-free" (Legacy) or empty for serverless */
  environment: string;
  indexName: string;
  /** Optional, might be needed for URL construction */
  projectId: string;
  /** Optional: The full host URL (https://index-project.svc.pinecone.io) */
  host: string;
}

export interface MilvusVectorDB {
  /** e.g., "localhost:19530" */
  address: string;
  /** Optional */
  username: string;
  /** Optional */
  password: string;
  collectionName: string;
  /** Defaults to "default" */
  databaseName: string;
  useTls: boolean;
  /** For Zilliz Cloud */
  apiKey: string;
}

/** McpUpstreamService defines an upstream that is already an MCP-compliant service. */
export interface McpUpstreamService {
  httpConnection?:
    | McpStreamableHttpConnection
    | undefined;
  /** Connect via a stdio process. */
  stdioConnection?:
    | McpStdioConnection
    | undefined;
  /** Connect via a bundle. */
  bundleConnection?:
    | McpBundleConnection
    | undefined;
  /** If true, mcpany will automatically discover and proxy all tools from the upstream. */
  toolAutoDiscovery: boolean;
  /** Optional: Overrides or specific configurations for calls discovered from the service. */
  tools: ToolDefinition[];
  /** A list of resources served by this service. */
  resources: ResourceDefinition[];
  /** A map of call definitions, keyed by their unique ID. */
  calls: { [key: string]: MCPCallDefinition };
  /** A list of prompts served by this service. */
  prompts: PromptDefinition[];
}

export interface McpUpstreamService_CallsEntry {
  key: string;
  value?: MCPCallDefinition | undefined;
}

/** McpStdioConnection defines the parameters for a stdio-based connection. */
export interface McpStdioConnection {
  /** The command and arguments to execute the service. */
  command: string;
  /** The working directory for the command. */
  workingDirectory: string;
  /**
   * Optional: The container image to use. If not provided, an image will be
   * selected based on the command.
   */
  containerImage: string;
  /** Arguments to the command. */
  args: string[];
  /** Optional: A list of commands to run as setup before the main command. */
  setupCommands: string[];
  /** Optional: Environment variables to set in the container. */
  env: { [key: string]: SecretValue };
  /** Optional: Validation rules for the environment. */
  validation?: EnvValidation | undefined;
}

export interface McpStdioConnection_EnvEntry {
  key: string;
  value?: SecretValue | undefined;
}

export interface EnvValidation {
  /** A list of environment variables that MUST be set (either inherited or explicit). */
  requiredEnv: string[];
}

export interface McpStreamableHttpConnection {
  /** Connect via HTTP. */
  httpAddress: string;
  /** TLS configuration, applicable if using an http_address. */
  tlsConfig?:
    | TLSConfig
    | undefined;
  /** If true, the client will follow HTTP redirects. Default is false (security hardening). */
  allowHttpRedirect: boolean;
}

/** McpBundleConnection defines the parameters for a bundle-based connection. */
export interface McpBundleConnection {
  /** The path to the bundle file. */
  bundlePath: string;
  /** Optional: The container image to use. If not provided, a default image will be used. */
  containerImage: string;
  /** Optional: Environment variables to pass to the container. */
  env: { [key: string]: SecretValue };
}

export interface McpBundleConnection_EnvEntry {
  key: string;
  value?: SecretValue | undefined;
}

/** ConnectionPoolConfig defines settings for managing a pool of connections to an upstream service. */
export interface ConnectionPoolConfig {
  /** The maximum number of simultaneous connections to allow to the upstream service. */
  maxConnections: number;
  /** The maximum number of idle connections to keep in the pool. */
  maxIdleConnections: number;
  /** The duration a connection can remain idle in the pool before being closed. */
  idleTimeout?: Duration | undefined;
}

/** Defines the container environment for running a command. */
export interface ContainerEnvironment {
  /** The name of the container. */
  name: string;
  /** The image to use for the container. */
  image: string;
  /** The volumes to mount into the container, with destination as key and source as value. */
  volumes: { [key: string]: string };
  /** Environment variables to set in the container (supports secrets). */
  env: { [key: string]: SecretValue };
}

export interface ContainerEnvironment_VolumesEntry {
  key: string;
  value: string;
}

export interface ContainerEnvironment_EnvEntry {
  key: string;
  value?: SecretValue | undefined;
}

/** Configuration for service resilience features like circuit breakers and retries. */
export interface ResilienceConfig {
  /** Circuit breaker configuration to prevent repeated calls to a failing service. */
  circuitBreaker?:
    | CircuitBreakerConfig
    | undefined;
  /** Retry policy for failed requests. */
  retryPolicy?:
    | RetryConfig
    | undefined;
  /** The maximum duration for a request before it is cancelled. */
  timeout?: Duration | undefined;
}

/** CircuitBreakerConfig defines the parameters for the circuit breaker pattern. */
export interface CircuitBreakerConfig {
  /** If the failure rate exceeds this threshold, the circuit opens. (e.g., 0.5 for 50%) */
  failureRateThreshold: number;
  /** The number of consecutive failures required to open the circuit. */
  consecutiveFailures: number;
  /** The duration the circuit remains open before transitioning to half-open. */
  openDuration?:
    | Duration
    | undefined;
  /** The number of requests to allow in the half-open state to test for recovery. */
  halfOpenRequests: number;
}

/** RetryConfig defines the parameters for retrying failed requests. */
export interface RetryConfig {
  /** The number of times to retry a failed request. */
  numberOfRetries: number;
  /** The base duration for the backoff between retries. */
  baseBackoff?:
    | Duration
    | undefined;
  /** The maximum duration for the backoff. */
  maxBackoff?:
    | Duration
    | undefined;
  /** The maximum total time to spend retrying. */
  maxElapsedTime?: Duration | undefined;
}

/** TLSConfig defines the TLS settings for connecting to an upstream service. */
export interface TLSConfig {
  /** The server name to use for SNI. */
  serverName: string;
  /** Path to the CA certificate file for verifying the server's certificate. */
  caCertPath: string;
  /** Path to the client certificate file for mTLS. */
  clientCertPath: string;
  /** Path to the client private key file for mTLS. */
  clientKeyPath: string;
  /** If true, the client will not verify the server's certificate chain. Use with caution. */
  insecureSkipVerify: boolean;
}

function createBaseUpstreamServiceConfig(): UpstreamServiceConfig {
  return {
    name: "",
    id: "",
    sanitizedName: "",
    version: "",
    priority: 0,
    disable: false,
    autoDiscoverTool: false,
    configError: "",
    readOnly: false,
    lastError: "",
    toolCount: 0,
    connectionPool: undefined,
    upstreamAuth: undefined,
    cache: undefined,
    rateLimit: undefined,
    loadBalancingStrategy: 0,
    resilience: undefined,
    authentication: undefined,
    toolExportPolicy: undefined,
    promptExportPolicy: undefined,
    resourceExportPolicy: undefined,
    mcpService: undefined,
    httpService: undefined,
    grpcService: undefined,
    openapiService: undefined,
    commandLineService: undefined,
    websocketService: undefined,
    webrtcService: undefined,
    graphqlService: undefined,
    sqlService: undefined,
    filesystemService: undefined,
    vectorService: undefined,
    callPolicies: [],
    preCallHooks: [],
    postCallHooks: [],
    prompts: [],
    tags: [],
    configurationSchema: "",
  };
}

export const UpstreamServiceConfig: MessageFns<UpstreamServiceConfig> = {
  encode(message: UpstreamServiceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.sanitizedName !== "") {
      writer.uint32(26).string(message.sanitizedName);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.priority !== 0) {
      writer.uint32(40).int32(message.priority);
    }
    if (message.disable !== false) {
      writer.uint32(48).bool(message.disable);
    }
    if (message.autoDiscoverTool !== false) {
      writer.uint32(56).bool(message.autoDiscoverTool);
    }
    if (message.configError !== "") {
      writer.uint32(66).string(message.configError);
    }
    if (message.readOnly !== false) {
      writer.uint32(280).bool(message.readOnly);
    }
    if (message.lastError !== "") {
      writer.uint32(290).string(message.lastError);
    }
    if (message.toolCount !== 0) {
      writer.uint32(296).int32(message.toolCount);
    }
    if (message.connectionPool !== undefined) {
      ConnectionPoolConfig.encode(message.connectionPool, writer.uint32(74).fork()).join();
    }
    if (message.upstreamAuth !== undefined) {
      Authentication.encode(message.upstreamAuth, writer.uint32(82).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(90).fork()).join();
    }
    if (message.rateLimit !== undefined) {
      RateLimitConfig.encode(message.rateLimit, writer.uint32(98).fork()).join();
    }
    if (message.loadBalancingStrategy !== 0) {
      writer.uint32(104).int32(message.loadBalancingStrategy);
    }
    if (message.resilience !== undefined) {
      ResilienceConfig.encode(message.resilience, writer.uint32(114).fork()).join();
    }
    if (message.authentication !== undefined) {
      Authentication.encode(message.authentication, writer.uint32(122).fork()).join();
    }
    if (message.toolExportPolicy !== undefined) {
      ExportPolicy.encode(message.toolExportPolicy, writer.uint32(130).fork()).join();
    }
    if (message.promptExportPolicy !== undefined) {
      ExportPolicy.encode(message.promptExportPolicy, writer.uint32(138).fork()).join();
    }
    if (message.resourceExportPolicy !== undefined) {
      ExportPolicy.encode(message.resourceExportPolicy, writer.uint32(146).fork()).join();
    }
    if (message.mcpService !== undefined) {
      McpUpstreamService.encode(message.mcpService, writer.uint32(154).fork()).join();
    }
    if (message.httpService !== undefined) {
      HttpUpstreamService.encode(message.httpService, writer.uint32(162).fork()).join();
    }
    if (message.grpcService !== undefined) {
      GrpcUpstreamService.encode(message.grpcService, writer.uint32(170).fork()).join();
    }
    if (message.openapiService !== undefined) {
      OpenapiUpstreamService.encode(message.openapiService, writer.uint32(178).fork()).join();
    }
    if (message.commandLineService !== undefined) {
      CommandLineUpstreamService.encode(message.commandLineService, writer.uint32(186).fork()).join();
    }
    if (message.websocketService !== undefined) {
      WebsocketUpstreamService.encode(message.websocketService, writer.uint32(194).fork()).join();
    }
    if (message.webrtcService !== undefined) {
      WebrtcUpstreamService.encode(message.webrtcService, writer.uint32(202).fork()).join();
    }
    if (message.graphqlService !== undefined) {
      GraphQLUpstreamService.encode(message.graphqlService, writer.uint32(210).fork()).join();
    }
    if (message.sqlService !== undefined) {
      SqlUpstreamService.encode(message.sqlService, writer.uint32(218).fork()).join();
    }
    if (message.filesystemService !== undefined) {
      FilesystemUpstreamService.encode(message.filesystemService, writer.uint32(226).fork()).join();
    }
    if (message.vectorService !== undefined) {
      VectorUpstreamService.encode(message.vectorService, writer.uint32(234).fork()).join();
    }
    for (const v of message.callPolicies) {
      CallPolicy.encode(v!, writer.uint32(242).fork()).join();
    }
    for (const v of message.preCallHooks) {
      CallHook.encode(v!, writer.uint32(250).fork()).join();
    }
    for (const v of message.postCallHooks) {
      CallHook.encode(v!, writer.uint32(258).fork()).join();
    }
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(266).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(274).string(v!);
    }
    if (message.configurationSchema !== "") {
      writer.uint32(306).string(message.configurationSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpstreamServiceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpstreamServiceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sanitizedName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.disable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoDiscoverTool = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.configError = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.lastError = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.toolCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.connectionPool = ConnectionPoolConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.upstreamAuth = Authentication.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rateLimit = RateLimitConfig.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.loadBalancingStrategy = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.resilience = ResilienceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.authentication = Authentication.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.toolExportPolicy = ExportPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.promptExportPolicy = ExportPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.resourceExportPolicy = ExportPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.mcpService = McpUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.httpService = HttpUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.grpcService = GrpcUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.openapiService = OpenapiUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.commandLineService = CommandLineUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.websocketService = WebsocketUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.webrtcService = WebrtcUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.graphqlService = GraphQLUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.sqlService = SqlUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.filesystemService = FilesystemUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.vectorService = VectorUpstreamService.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.callPolicies.push(CallPolicy.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.preCallHooks.push(CallHook.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.postCallHooks.push(CallHook.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.configurationSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpstreamServiceConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sanitizedName: isSet(object.sanitized_name) ? globalThis.String(object.sanitized_name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      disable: isSet(object.disable) ? globalThis.Boolean(object.disable) : false,
      autoDiscoverTool: isSet(object.auto_discover_tool) ? globalThis.Boolean(object.auto_discover_tool) : false,
      configError: isSet(object.config_error) ? globalThis.String(object.config_error) : "",
      readOnly: isSet(object.read_only) ? globalThis.Boolean(object.read_only) : false,
      lastError: isSet(object.last_error) ? globalThis.String(object.last_error) : "",
      toolCount: isSet(object.tool_count) ? globalThis.Number(object.tool_count) : 0,
      connectionPool: isSet(object.connection_pool) ? ConnectionPoolConfig.fromJSON(object.connection_pool) : undefined,
      upstreamAuth: isSet(object.upstream_auth) ? Authentication.fromJSON(object.upstream_auth) : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      rateLimit: isSet(object.rate_limit) ? RateLimitConfig.fromJSON(object.rate_limit) : undefined,
      loadBalancingStrategy: isSet(object.load_balancing_strategy)
        ? loadBalancingStrategyFromJSON(object.load_balancing_strategy)
        : 0,
      resilience: isSet(object.resilience) ? ResilienceConfig.fromJSON(object.resilience) : undefined,
      authentication: isSet(object.authentication) ? Authentication.fromJSON(object.authentication) : undefined,
      toolExportPolicy: isSet(object.tool_export_policy) ? ExportPolicy.fromJSON(object.tool_export_policy) : undefined,
      promptExportPolicy: isSet(object.prompt_export_policy)
        ? ExportPolicy.fromJSON(object.prompt_export_policy)
        : undefined,
      resourceExportPolicy: isSet(object.resource_export_policy)
        ? ExportPolicy.fromJSON(object.resource_export_policy)
        : undefined,
      mcpService: isSet(object.mcp_service) ? McpUpstreamService.fromJSON(object.mcp_service) : undefined,
      httpService: isSet(object.http_service) ? HttpUpstreamService.fromJSON(object.http_service) : undefined,
      grpcService: isSet(object.grpc_service) ? GrpcUpstreamService.fromJSON(object.grpc_service) : undefined,
      openapiService: isSet(object.openapi_service)
        ? OpenapiUpstreamService.fromJSON(object.openapi_service)
        : undefined,
      commandLineService: isSet(object.command_line_service)
        ? CommandLineUpstreamService.fromJSON(object.command_line_service)
        : undefined,
      websocketService: isSet(object.websocket_service)
        ? WebsocketUpstreamService.fromJSON(object.websocket_service)
        : undefined,
      webrtcService: isSet(object.webrtc_service) ? WebrtcUpstreamService.fromJSON(object.webrtc_service) : undefined,
      graphqlService: isSet(object.graphql_service)
        ? GraphQLUpstreamService.fromJSON(object.graphql_service)
        : undefined,
      sqlService: isSet(object.sql_service) ? SqlUpstreamService.fromJSON(object.sql_service) : undefined,
      filesystemService: isSet(object.filesystem_service)
        ? FilesystemUpstreamService.fromJSON(object.filesystem_service)
        : undefined,
      vectorService: isSet(object.vector_service) ? VectorUpstreamService.fromJSON(object.vector_service) : undefined,
      callPolicies: globalThis.Array.isArray(object?.call_policies)
        ? object.call_policies.map((e: any) => CallPolicy.fromJSON(e))
        : [],
      preCallHooks: globalThis.Array.isArray(object?.pre_call_hooks)
        ? object.pre_call_hooks.map((e: any) => CallHook.fromJSON(e))
        : [],
      postCallHooks: globalThis.Array.isArray(object?.post_call_hooks)
        ? object.post_call_hooks.map((e: any) => CallHook.fromJSON(e))
        : [],
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      configurationSchema: isSet(object.configuration_schema) ? globalThis.String(object.configuration_schema) : "",
    };
  },

  toJSON(message: UpstreamServiceConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sanitizedName !== "") {
      obj.sanitized_name = message.sanitizedName;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.disable !== false) {
      obj.disable = message.disable;
    }
    if (message.autoDiscoverTool !== false) {
      obj.auto_discover_tool = message.autoDiscoverTool;
    }
    if (message.configError !== "") {
      obj.config_error = message.configError;
    }
    if (message.readOnly !== false) {
      obj.read_only = message.readOnly;
    }
    if (message.lastError !== "") {
      obj.last_error = message.lastError;
    }
    if (message.toolCount !== 0) {
      obj.tool_count = Math.round(message.toolCount);
    }
    if (message.connectionPool !== undefined) {
      obj.connection_pool = ConnectionPoolConfig.toJSON(message.connectionPool);
    }
    if (message.upstreamAuth !== undefined) {
      obj.upstream_auth = Authentication.toJSON(message.upstreamAuth);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.rateLimit !== undefined) {
      obj.rate_limit = RateLimitConfig.toJSON(message.rateLimit);
    }
    if (message.loadBalancingStrategy !== 0) {
      obj.load_balancing_strategy = loadBalancingStrategyToJSON(message.loadBalancingStrategy);
    }
    if (message.resilience !== undefined) {
      obj.resilience = ResilienceConfig.toJSON(message.resilience);
    }
    if (message.authentication !== undefined) {
      obj.authentication = Authentication.toJSON(message.authentication);
    }
    if (message.toolExportPolicy !== undefined) {
      obj.tool_export_policy = ExportPolicy.toJSON(message.toolExportPolicy);
    }
    if (message.promptExportPolicy !== undefined) {
      obj.prompt_export_policy = ExportPolicy.toJSON(message.promptExportPolicy);
    }
    if (message.resourceExportPolicy !== undefined) {
      obj.resource_export_policy = ExportPolicy.toJSON(message.resourceExportPolicy);
    }
    if (message.mcpService !== undefined) {
      obj.mcp_service = McpUpstreamService.toJSON(message.mcpService);
    }
    if (message.httpService !== undefined) {
      obj.http_service = HttpUpstreamService.toJSON(message.httpService);
    }
    if (message.grpcService !== undefined) {
      obj.grpc_service = GrpcUpstreamService.toJSON(message.grpcService);
    }
    if (message.openapiService !== undefined) {
      obj.openapi_service = OpenapiUpstreamService.toJSON(message.openapiService);
    }
    if (message.commandLineService !== undefined) {
      obj.command_line_service = CommandLineUpstreamService.toJSON(message.commandLineService);
    }
    if (message.websocketService !== undefined) {
      obj.websocket_service = WebsocketUpstreamService.toJSON(message.websocketService);
    }
    if (message.webrtcService !== undefined) {
      obj.webrtc_service = WebrtcUpstreamService.toJSON(message.webrtcService);
    }
    if (message.graphqlService !== undefined) {
      obj.graphql_service = GraphQLUpstreamService.toJSON(message.graphqlService);
    }
    if (message.sqlService !== undefined) {
      obj.sql_service = SqlUpstreamService.toJSON(message.sqlService);
    }
    if (message.filesystemService !== undefined) {
      obj.filesystem_service = FilesystemUpstreamService.toJSON(message.filesystemService);
    }
    if (message.vectorService !== undefined) {
      obj.vector_service = VectorUpstreamService.toJSON(message.vectorService);
    }
    if (message.callPolicies?.length) {
      obj.call_policies = message.callPolicies.map((e) => CallPolicy.toJSON(e));
    }
    if (message.preCallHooks?.length) {
      obj.pre_call_hooks = message.preCallHooks.map((e) => CallHook.toJSON(e));
    }
    if (message.postCallHooks?.length) {
      obj.post_call_hooks = message.postCallHooks.map((e) => CallHook.toJSON(e));
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.configurationSchema !== "") {
      obj.configuration_schema = message.configurationSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpstreamServiceConfig>, I>>(base?: I): UpstreamServiceConfig {
    return UpstreamServiceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpstreamServiceConfig>, I>>(object: I): UpstreamServiceConfig {
    const message = createBaseUpstreamServiceConfig();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.sanitizedName = object.sanitizedName ?? "";
    message.version = object.version ?? "";
    message.priority = object.priority ?? 0;
    message.disable = object.disable ?? false;
    message.autoDiscoverTool = object.autoDiscoverTool ?? false;
    message.configError = object.configError ?? "";
    message.readOnly = object.readOnly ?? false;
    message.lastError = object.lastError ?? "";
    message.toolCount = object.toolCount ?? 0;
    message.connectionPool = (object.connectionPool !== undefined && object.connectionPool !== null)
      ? ConnectionPoolConfig.fromPartial(object.connectionPool)
      : undefined;
    message.upstreamAuth = (object.upstreamAuth !== undefined && object.upstreamAuth !== null)
      ? Authentication.fromPartial(object.upstreamAuth)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.rateLimit = (object.rateLimit !== undefined && object.rateLimit !== null)
      ? RateLimitConfig.fromPartial(object.rateLimit)
      : undefined;
    message.loadBalancingStrategy = object.loadBalancingStrategy ?? 0;
    message.resilience = (object.resilience !== undefined && object.resilience !== null)
      ? ResilienceConfig.fromPartial(object.resilience)
      : undefined;
    message.authentication = (object.authentication !== undefined && object.authentication !== null)
      ? Authentication.fromPartial(object.authentication)
      : undefined;
    message.toolExportPolicy = (object.toolExportPolicy !== undefined && object.toolExportPolicy !== null)
      ? ExportPolicy.fromPartial(object.toolExportPolicy)
      : undefined;
    message.promptExportPolicy = (object.promptExportPolicy !== undefined && object.promptExportPolicy !== null)
      ? ExportPolicy.fromPartial(object.promptExportPolicy)
      : undefined;
    message.resourceExportPolicy = (object.resourceExportPolicy !== undefined && object.resourceExportPolicy !== null)
      ? ExportPolicy.fromPartial(object.resourceExportPolicy)
      : undefined;
    message.mcpService = (object.mcpService !== undefined && object.mcpService !== null)
      ? McpUpstreamService.fromPartial(object.mcpService)
      : undefined;
    message.httpService = (object.httpService !== undefined && object.httpService !== null)
      ? HttpUpstreamService.fromPartial(object.httpService)
      : undefined;
    message.grpcService = (object.grpcService !== undefined && object.grpcService !== null)
      ? GrpcUpstreamService.fromPartial(object.grpcService)
      : undefined;
    message.openapiService = (object.openapiService !== undefined && object.openapiService !== null)
      ? OpenapiUpstreamService.fromPartial(object.openapiService)
      : undefined;
    message.commandLineService = (object.commandLineService !== undefined && object.commandLineService !== null)
      ? CommandLineUpstreamService.fromPartial(object.commandLineService)
      : undefined;
    message.websocketService = (object.websocketService !== undefined && object.websocketService !== null)
      ? WebsocketUpstreamService.fromPartial(object.websocketService)
      : undefined;
    message.webrtcService = (object.webrtcService !== undefined && object.webrtcService !== null)
      ? WebrtcUpstreamService.fromPartial(object.webrtcService)
      : undefined;
    message.graphqlService = (object.graphqlService !== undefined && object.graphqlService !== null)
      ? GraphQLUpstreamService.fromPartial(object.graphqlService)
      : undefined;
    message.sqlService = (object.sqlService !== undefined && object.sqlService !== null)
      ? SqlUpstreamService.fromPartial(object.sqlService)
      : undefined;
    message.filesystemService = (object.filesystemService !== undefined && object.filesystemService !== null)
      ? FilesystemUpstreamService.fromPartial(object.filesystemService)
      : undefined;
    message.vectorService = (object.vectorService !== undefined && object.vectorService !== null)
      ? VectorUpstreamService.fromPartial(object.vectorService)
      : undefined;
    message.callPolicies = object.callPolicies?.map((e) => CallPolicy.fromPartial(e)) || [];
    message.preCallHooks = object.preCallHooks?.map((e) => CallHook.fromPartial(e)) || [];
    message.postCallHooks = object.postCallHooks?.map((e) => CallHook.fromPartial(e)) || [];
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.configurationSchema = object.configurationSchema ?? "";
    return message;
  },
};

function createBaseCallPolicy(): CallPolicy {
  return { defaultAction: 0, rules: [] };
}

export const CallPolicy: MessageFns<CallPolicy> = {
  encode(message: CallPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultAction !== 0) {
      writer.uint32(8).int32(message.defaultAction);
    }
    for (const v of message.rules) {
      CallPolicyRule.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultAction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rules.push(CallPolicyRule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallPolicy {
    return {
      defaultAction: isSet(object.defaultAction)
        ? callPolicy_ActionFromJSON(object.defaultAction)
        : isSet(object.default_action)
        ? callPolicy_ActionFromJSON(object.default_action)
        : 0,
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => CallPolicyRule.fromJSON(e)) : [],
    };
  },

  toJSON(message: CallPolicy): unknown {
    const obj: any = {};
    if (message.defaultAction !== 0) {
      obj.defaultAction = callPolicy_ActionToJSON(message.defaultAction);
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => CallPolicyRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallPolicy>, I>>(base?: I): CallPolicy {
    return CallPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallPolicy>, I>>(object: I): CallPolicy {
    const message = createBaseCallPolicy();
    message.defaultAction = object.defaultAction ?? 0;
    message.rules = object.rules?.map((e) => CallPolicyRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCallPolicyRule(): CallPolicyRule {
  return { action: 0, nameRegex: "", argumentRegex: "", urlRegex: "", callIdRegex: "" };
}

export const CallPolicyRule: MessageFns<CallPolicyRule> = {
  encode(message: CallPolicyRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.nameRegex !== "") {
      writer.uint32(18).string(message.nameRegex);
    }
    if (message.argumentRegex !== "") {
      writer.uint32(26).string(message.argumentRegex);
    }
    if (message.urlRegex !== "") {
      writer.uint32(34).string(message.urlRegex);
    }
    if (message.callIdRegex !== "") {
      writer.uint32(42).string(message.callIdRegex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallPolicyRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallPolicyRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nameRegex = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.argumentRegex = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.urlRegex = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.callIdRegex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallPolicyRule {
    return {
      action: isSet(object.action) ? callPolicy_ActionFromJSON(object.action) : 0,
      nameRegex: isSet(object.name_regex) ? globalThis.String(object.name_regex) : "",
      argumentRegex: isSet(object.argumentRegex)
        ? globalThis.String(object.argumentRegex)
        : isSet(object.argument_regex)
        ? globalThis.String(object.argument_regex)
        : "",
      urlRegex: isSet(object.url_regex) ? globalThis.String(object.url_regex) : "",
      callIdRegex: isSet(object.call_id_regex) ? globalThis.String(object.call_id_regex) : "",
    };
  },

  toJSON(message: CallPolicyRule): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = callPolicy_ActionToJSON(message.action);
    }
    if (message.nameRegex !== "") {
      obj.name_regex = message.nameRegex;
    }
    if (message.argumentRegex !== "") {
      obj.argumentRegex = message.argumentRegex;
    }
    if (message.urlRegex !== "") {
      obj.url_regex = message.urlRegex;
    }
    if (message.callIdRegex !== "") {
      obj.call_id_regex = message.callIdRegex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallPolicyRule>, I>>(base?: I): CallPolicyRule {
    return CallPolicyRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallPolicyRule>, I>>(object: I): CallPolicyRule {
    const message = createBaseCallPolicyRule();
    message.action = object.action ?? 0;
    message.nameRegex = object.nameRegex ?? "";
    message.argumentRegex = object.argumentRegex ?? "";
    message.urlRegex = object.urlRegex ?? "";
    message.callIdRegex = object.callIdRegex ?? "";
    return message;
  },
};

function createBaseExportPolicy(): ExportPolicy {
  return { defaultAction: 0, rules: [] };
}

export const ExportPolicy: MessageFns<ExportPolicy> = {
  encode(message: ExportPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultAction !== 0) {
      writer.uint32(8).int32(message.defaultAction);
    }
    for (const v of message.rules) {
      ExportRule.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultAction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rules.push(ExportRule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportPolicy {
    return {
      defaultAction: isSet(object.defaultAction)
        ? exportPolicy_ActionFromJSON(object.defaultAction)
        : isSet(object.default_action)
        ? exportPolicy_ActionFromJSON(object.default_action)
        : 0,
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => ExportRule.fromJSON(e)) : [],
    };
  },

  toJSON(message: ExportPolicy): unknown {
    const obj: any = {};
    if (message.defaultAction !== 0) {
      obj.defaultAction = exportPolicy_ActionToJSON(message.defaultAction);
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => ExportRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportPolicy>, I>>(base?: I): ExportPolicy {
    return ExportPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportPolicy>, I>>(object: I): ExportPolicy {
    const message = createBaseExportPolicy();
    message.defaultAction = object.defaultAction ?? 0;
    message.rules = object.rules?.map((e) => ExportRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExportRule(): ExportRule {
  return { nameRegex: "", action: 0 };
}

export const ExportRule: MessageFns<ExportRule> = {
  encode(message: ExportRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nameRegex !== "") {
      writer.uint32(10).string(message.nameRegex);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nameRegex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportRule {
    return {
      nameRegex: isSet(object.name_regex) ? globalThis.String(object.name_regex) : "",
      action: isSet(object.action) ? exportPolicy_ActionFromJSON(object.action) : 0,
    };
  },

  toJSON(message: ExportRule): unknown {
    const obj: any = {};
    if (message.nameRegex !== "") {
      obj.name_regex = message.nameRegex;
    }
    if (message.action !== 0) {
      obj.action = exportPolicy_ActionToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportRule>, I>>(base?: I): ExportRule {
    return ExportRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportRule>, I>>(object: I): ExportRule {
    const message = createBaseExportRule();
    message.nameRegex = object.nameRegex ?? "";
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseCallHook(): CallHook {
  return { name: "", webhook: undefined, callPolicy: undefined };
}

export const CallHook: MessageFns<CallHook> = {
  encode(message: CallHook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.webhook !== undefined) {
      WebhookConfig.encode(message.webhook, writer.uint32(18).fork()).join();
    }
    if (message.callPolicy !== undefined) {
      CallPolicy.encode(message.callPolicy, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallHook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallHook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.webhook = WebhookConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.callPolicy = CallPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallHook {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      webhook: isSet(object.webhook) ? WebhookConfig.fromJSON(object.webhook) : undefined,
      callPolicy: isSet(object.callPolicy)
        ? CallPolicy.fromJSON(object.callPolicy)
        : isSet(object.call_policy)
        ? CallPolicy.fromJSON(object.call_policy)
        : undefined,
    };
  },

  toJSON(message: CallHook): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.webhook !== undefined) {
      obj.webhook = WebhookConfig.toJSON(message.webhook);
    }
    if (message.callPolicy !== undefined) {
      obj.callPolicy = CallPolicy.toJSON(message.callPolicy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallHook>, I>>(base?: I): CallHook {
    return CallHook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallHook>, I>>(object: I): CallHook {
    const message = createBaseCallHook();
    message.name = object.name ?? "";
    message.webhook = (object.webhook !== undefined && object.webhook !== null)
      ? WebhookConfig.fromPartial(object.webhook)
      : undefined;
    message.callPolicy = (object.callPolicy !== undefined && object.callPolicy !== null)
      ? CallPolicy.fromPartial(object.callPolicy)
      : undefined;
    return message;
  },
};

function createBaseGrpcUpstreamService(): GrpcUpstreamService {
  return {
    address: "",
    useReflection: false,
    tlsConfig: undefined,
    tools: [],
    healthCheck: undefined,
    protoDefinitions: [],
    protoCollection: [],
    resources: [],
    calls: {},
    prompts: [],
  };
}

export const GrpcUpstreamService: MessageFns<GrpcUpstreamService> = {
  encode(message: GrpcUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.useReflection !== false) {
      writer.uint32(16).bool(message.useReflection);
    }
    if (message.tlsConfig !== undefined) {
      TLSConfig.encode(message.tlsConfig, writer.uint32(26).fork()).join();
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.healthCheck !== undefined) {
      GrpcHealthCheck.encode(message.healthCheck, writer.uint32(42).fork()).join();
    }
    for (const v of message.protoDefinitions) {
      ProtoDefinition.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.protoCollection) {
      ProtoCollection.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(66).fork()).join();
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, GrpcCallDefinition]) => {
      GrpcUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.useReflection = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tlsConfig = TLSConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.healthCheck = GrpcHealthCheck.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.protoDefinitions.push(ProtoDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.protoCollection.push(ProtoCollection.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = GrpcUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.calls[entry9.key] = entry9.value;
          }
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcUpstreamService {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      useReflection: isSet(object.use_reflection) ? globalThis.Boolean(object.use_reflection) : false,
      tlsConfig: isSet(object.tls_config) ? TLSConfig.fromJSON(object.tls_config) : undefined,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      healthCheck: isSet(object.health_check) ? GrpcHealthCheck.fromJSON(object.health_check) : undefined,
      protoDefinitions: globalThis.Array.isArray(object?.proto_definitions)
        ? object.proto_definitions.map((e: any) => ProtoDefinition.fromJSON(e))
        : [],
      protoCollection: globalThis.Array.isArray(object?.proto_collection)
        ? object.proto_collection.map((e: any) => ProtoCollection.fromJSON(e))
        : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: GrpcCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = GrpcCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GrpcUpstreamService): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.useReflection !== false) {
      obj.use_reflection = message.useReflection;
    }
    if (message.tlsConfig !== undefined) {
      obj.tls_config = TLSConfig.toJSON(message.tlsConfig);
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.healthCheck !== undefined) {
      obj.health_check = GrpcHealthCheck.toJSON(message.healthCheck);
    }
    if (message.protoDefinitions?.length) {
      obj.proto_definitions = message.protoDefinitions.map((e) => ProtoDefinition.toJSON(e));
    }
    if (message.protoCollection?.length) {
      obj.proto_collection = message.protoCollection.map((e) => ProtoCollection.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, GrpcCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = GrpcCallDefinition.toJSON(v);
        });
      }
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcUpstreamService>, I>>(base?: I): GrpcUpstreamService {
    return GrpcUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcUpstreamService>, I>>(object: I): GrpcUpstreamService {
    const message = createBaseGrpcUpstreamService();
    message.address = object.address ?? "";
    message.useReflection = object.useReflection ?? false;
    message.tlsConfig = (object.tlsConfig !== undefined && object.tlsConfig !== null)
      ? TLSConfig.fromPartial(object.tlsConfig)
      : undefined;
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? GrpcHealthCheck.fromPartial(object.healthCheck)
      : undefined;
    message.protoDefinitions = object.protoDefinitions?.map((e) => ProtoDefinition.fromPartial(e)) || [];
    message.protoCollection = object.protoCollection?.map((e) => ProtoCollection.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, GrpcCallDefinition][]).reduce(
      (acc: { [key: string]: GrpcCallDefinition }, [key, value]: [string, GrpcCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = GrpcCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGrpcUpstreamService_CallsEntry(): GrpcUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const GrpcUpstreamService_CallsEntry: MessageFns<GrpcUpstreamService_CallsEntry> = {
  encode(message: GrpcUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      GrpcCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = GrpcCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? GrpcCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GrpcUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = GrpcCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcUpstreamService_CallsEntry>, I>>(base?: I): GrpcUpstreamService_CallsEntry {
    return GrpcUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcUpstreamService_CallsEntry>, I>>(
    object: I,
  ): GrpcUpstreamService_CallsEntry {
    const message = createBaseGrpcUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? GrpcCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoDefinition(): ProtoDefinition {
  return { protoFile: undefined, protoDescriptor: undefined };
}

export const ProtoDefinition: MessageFns<ProtoDefinition> = {
  encode(message: ProtoDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protoFile !== undefined) {
      ProtoFile.encode(message.protoFile, writer.uint32(10).fork()).join();
    }
    if (message.protoDescriptor !== undefined) {
      ProtoDescriptor.encode(message.protoDescriptor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.protoFile = ProtoFile.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protoDescriptor = ProtoDescriptor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDefinition {
    return {
      protoFile: isSet(object.proto_file) ? ProtoFile.fromJSON(object.proto_file) : undefined,
      protoDescriptor: isSet(object.proto_descriptor) ? ProtoDescriptor.fromJSON(object.proto_descriptor) : undefined,
    };
  },

  toJSON(message: ProtoDefinition): unknown {
    const obj: any = {};
    if (message.protoFile !== undefined) {
      obj.proto_file = ProtoFile.toJSON(message.protoFile);
    }
    if (message.protoDescriptor !== undefined) {
      obj.proto_descriptor = ProtoDescriptor.toJSON(message.protoDescriptor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDefinition>, I>>(base?: I): ProtoDefinition {
    return ProtoDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDefinition>, I>>(object: I): ProtoDefinition {
    const message = createBaseProtoDefinition();
    message.protoFile = (object.protoFile !== undefined && object.protoFile !== null)
      ? ProtoFile.fromPartial(object.protoFile)
      : undefined;
    message.protoDescriptor = (object.protoDescriptor !== undefined && object.protoDescriptor !== null)
      ? ProtoDescriptor.fromPartial(object.protoDescriptor)
      : undefined;
    return message;
  },
};

function createBaseProtoFile(): ProtoFile {
  return { fileName: "", fileContent: undefined, filePath: undefined };
}

export const ProtoFile: MessageFns<ProtoFile> = {
  encode(message: ProtoFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileName !== "") {
      writer.uint32(10).string(message.fileName);
    }
    if (message.fileContent !== undefined) {
      writer.uint32(18).string(message.fileContent);
    }
    if (message.filePath !== undefined) {
      writer.uint32(26).string(message.filePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileContent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFile {
    return {
      fileName: isSet(object.file_name) ? globalThis.String(object.file_name) : "",
      fileContent: isSet(object.file_content) ? globalThis.String(object.file_content) : undefined,
      filePath: isSet(object.file_path) ? globalThis.String(object.file_path) : undefined,
    };
  },

  toJSON(message: ProtoFile): unknown {
    const obj: any = {};
    if (message.fileName !== "") {
      obj.file_name = message.fileName;
    }
    if (message.fileContent !== undefined) {
      obj.file_content = message.fileContent;
    }
    if (message.filePath !== undefined) {
      obj.file_path = message.filePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFile>, I>>(base?: I): ProtoFile {
    return ProtoFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFile>, I>>(object: I): ProtoFile {
    const message = createBaseProtoFile();
    message.fileName = object.fileName ?? "";
    message.fileContent = object.fileContent ?? undefined;
    message.filePath = object.filePath ?? undefined;
    return message;
  },
};

function createBaseProtoDescriptor(): ProtoDescriptor {
  return { fileName: "", filePath: undefined };
}

export const ProtoDescriptor: MessageFns<ProtoDescriptor> = {
  encode(message: ProtoDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileName !== "") {
      writer.uint32(10).string(message.fileName);
    }
    if (message.filePath !== undefined) {
      writer.uint32(18).string(message.filePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoDescriptor {
    return {
      fileName: isSet(object.file_name) ? globalThis.String(object.file_name) : "",
      filePath: isSet(object.file_path) ? globalThis.String(object.file_path) : undefined,
    };
  },

  toJSON(message: ProtoDescriptor): unknown {
    const obj: any = {};
    if (message.fileName !== "") {
      obj.file_name = message.fileName;
    }
    if (message.filePath !== undefined) {
      obj.file_path = message.filePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoDescriptor>, I>>(base?: I): ProtoDescriptor {
    return ProtoDescriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoDescriptor>, I>>(object: I): ProtoDescriptor {
    const message = createBaseProtoDescriptor();
    message.fileName = object.fileName ?? "";
    message.filePath = object.filePath ?? undefined;
    return message;
  },
};

function createBaseProtoCollection(): ProtoCollection {
  return { rootPath: "", pathMatchRegex: "", isRecursive: false };
}

export const ProtoCollection: MessageFns<ProtoCollection> = {
  encode(message: ProtoCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rootPath !== "") {
      writer.uint32(10).string(message.rootPath);
    }
    if (message.pathMatchRegex !== "") {
      writer.uint32(18).string(message.pathMatchRegex);
    }
    if (message.isRecursive !== false) {
      writer.uint32(24).bool(message.isRecursive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rootPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pathMatchRegex = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isRecursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoCollection {
    return {
      rootPath: isSet(object.root_path) ? globalThis.String(object.root_path) : "",
      pathMatchRegex: isSet(object.path_match_regex) ? globalThis.String(object.path_match_regex) : "",
      isRecursive: isSet(object.is_recursive) ? globalThis.Boolean(object.is_recursive) : false,
    };
  },

  toJSON(message: ProtoCollection): unknown {
    const obj: any = {};
    if (message.rootPath !== "") {
      obj.root_path = message.rootPath;
    }
    if (message.pathMatchRegex !== "") {
      obj.path_match_regex = message.pathMatchRegex;
    }
    if (message.isRecursive !== false) {
      obj.is_recursive = message.isRecursive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoCollection>, I>>(base?: I): ProtoCollection {
    return ProtoCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoCollection>, I>>(object: I): ProtoCollection {
    const message = createBaseProtoCollection();
    message.rootPath = object.rootPath ?? "";
    message.pathMatchRegex = object.pathMatchRegex ?? "";
    message.isRecursive = object.isRecursive ?? false;
    return message;
  },
};

function createBaseHttpUpstreamService(): HttpUpstreamService {
  return {
    address: "",
    tools: [],
    calls: {},
    healthCheck: undefined,
    tlsConfig: undefined,
    resources: [],
    prompts: [],
  };
}

export const HttpUpstreamService: MessageFns<HttpUpstreamService> = {
  encode(message: HttpUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(18).fork()).join();
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, HttpCallDefinition]) => {
      HttpUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.healthCheck !== undefined) {
      HttpHealthCheck.encode(message.healthCheck, writer.uint32(26).fork()).join();
    }
    if (message.tlsConfig !== undefined) {
      TLSConfig.encode(message.tlsConfig, writer.uint32(34).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = HttpUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.calls[entry6.key] = entry6.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.healthCheck = HttpHealthCheck.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tlsConfig = TLSConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpUpstreamService {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: HttpCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = HttpCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      healthCheck: isSet(object.health_check) ? HttpHealthCheck.fromJSON(object.health_check) : undefined,
      tlsConfig: isSet(object.tls_config) ? TLSConfig.fromJSON(object.tls_config) : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HttpUpstreamService): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, HttpCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = HttpCallDefinition.toJSON(v);
        });
      }
    }
    if (message.healthCheck !== undefined) {
      obj.health_check = HttpHealthCheck.toJSON(message.healthCheck);
    }
    if (message.tlsConfig !== undefined) {
      obj.tls_config = TLSConfig.toJSON(message.tlsConfig);
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpUpstreamService>, I>>(base?: I): HttpUpstreamService {
    return HttpUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpUpstreamService>, I>>(object: I): HttpUpstreamService {
    const message = createBaseHttpUpstreamService();
    message.address = object.address ?? "";
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, HttpCallDefinition][]).reduce(
      (acc: { [key: string]: HttpCallDefinition }, [key, value]: [string, HttpCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = HttpCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? HttpHealthCheck.fromPartial(object.healthCheck)
      : undefined;
    message.tlsConfig = (object.tlsConfig !== undefined && object.tlsConfig !== null)
      ? TLSConfig.fromPartial(object.tlsConfig)
      : undefined;
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHttpUpstreamService_CallsEntry(): HttpUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const HttpUpstreamService_CallsEntry: MessageFns<HttpUpstreamService_CallsEntry> = {
  encode(message: HttpUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      HttpCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = HttpCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? HttpCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: HttpUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = HttpCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpUpstreamService_CallsEntry>, I>>(base?: I): HttpUpstreamService_CallsEntry {
    return HttpUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpUpstreamService_CallsEntry>, I>>(
    object: I,
  ): HttpUpstreamService_CallsEntry {
    const message = createBaseHttpUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? HttpCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWebsocketUpstreamService(): WebsocketUpstreamService {
  return {
    address: "",
    tools: [],
    tlsConfig: undefined,
    resources: [],
    calls: {},
    prompts: [],
    healthCheck: undefined,
  };
}

export const WebsocketUpstreamService: MessageFns<WebsocketUpstreamService> = {
  encode(message: WebsocketUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.tlsConfig !== undefined) {
      TLSConfig.encode(message.tlsConfig, writer.uint32(26).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, WebsocketCallDefinition]) => {
      WebsocketUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.healthCheck !== undefined) {
      WebsocketHealthCheck.encode(message.healthCheck, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tlsConfig = TLSConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebsocketUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.calls[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.healthCheck = WebsocketHealthCheck.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsocketUpstreamService {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      tlsConfig: isSet(object.tls_config) ? TLSConfig.fromJSON(object.tls_config) : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: WebsocketCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = WebsocketCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
      healthCheck: isSet(object.health_check) ? WebsocketHealthCheck.fromJSON(object.health_check) : undefined,
    };
  },

  toJSON(message: WebsocketUpstreamService): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.tlsConfig !== undefined) {
      obj.tls_config = TLSConfig.toJSON(message.tlsConfig);
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, WebsocketCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = WebsocketCallDefinition.toJSON(v);
        });
      }
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    if (message.healthCheck !== undefined) {
      obj.health_check = WebsocketHealthCheck.toJSON(message.healthCheck);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebsocketUpstreamService>, I>>(base?: I): WebsocketUpstreamService {
    return WebsocketUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebsocketUpstreamService>, I>>(object: I): WebsocketUpstreamService {
    const message = createBaseWebsocketUpstreamService();
    message.address = object.address ?? "";
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.tlsConfig = (object.tlsConfig !== undefined && object.tlsConfig !== null)
      ? TLSConfig.fromPartial(object.tlsConfig)
      : undefined;
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, WebsocketCallDefinition][]).reduce(
      (acc: { [key: string]: WebsocketCallDefinition }, [key, value]: [string, WebsocketCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = WebsocketCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? WebsocketHealthCheck.fromPartial(object.healthCheck)
      : undefined;
    return message;
  },
};

function createBaseWebsocketUpstreamService_CallsEntry(): WebsocketUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const WebsocketUpstreamService_CallsEntry: MessageFns<WebsocketUpstreamService_CallsEntry> = {
  encode(message: WebsocketUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WebsocketCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebsocketCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsocketUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? WebsocketCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WebsocketUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = WebsocketCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebsocketUpstreamService_CallsEntry>, I>>(
    base?: I,
  ): WebsocketUpstreamService_CallsEntry {
    return WebsocketUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebsocketUpstreamService_CallsEntry>, I>>(
    object: I,
  ): WebsocketUpstreamService_CallsEntry {
    const message = createBaseWebsocketUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? WebsocketCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWebrtcUpstreamService(): WebrtcUpstreamService {
  return {
    address: "",
    tools: [],
    tlsConfig: undefined,
    resources: [],
    calls: {},
    prompts: [],
    healthCheck: undefined,
  };
}

export const WebrtcUpstreamService: MessageFns<WebrtcUpstreamService> = {
  encode(message: WebrtcUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.tlsConfig !== undefined) {
      TLSConfig.encode(message.tlsConfig, writer.uint32(26).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, WebrtcCallDefinition]) => {
      WebrtcUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.healthCheck !== undefined) {
      WebRTCHealthCheck.encode(message.healthCheck, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebrtcUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tlsConfig = TLSConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebrtcUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.calls[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.healthCheck = WebRTCHealthCheck.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcUpstreamService {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      tlsConfig: isSet(object.tls_config) ? TLSConfig.fromJSON(object.tls_config) : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: WebrtcCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = WebrtcCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
      healthCheck: isSet(object.health_check) ? WebRTCHealthCheck.fromJSON(object.health_check) : undefined,
    };
  },

  toJSON(message: WebrtcUpstreamService): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.tlsConfig !== undefined) {
      obj.tls_config = TLSConfig.toJSON(message.tlsConfig);
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, WebrtcCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = WebrtcCallDefinition.toJSON(v);
        });
      }
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    if (message.healthCheck !== undefined) {
      obj.health_check = WebRTCHealthCheck.toJSON(message.healthCheck);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcUpstreamService>, I>>(base?: I): WebrtcUpstreamService {
    return WebrtcUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcUpstreamService>, I>>(object: I): WebrtcUpstreamService {
    const message = createBaseWebrtcUpstreamService();
    message.address = object.address ?? "";
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.tlsConfig = (object.tlsConfig !== undefined && object.tlsConfig !== null)
      ? TLSConfig.fromPartial(object.tlsConfig)
      : undefined;
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, WebrtcCallDefinition][]).reduce(
      (acc: { [key: string]: WebrtcCallDefinition }, [key, value]: [string, WebrtcCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = WebrtcCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? WebRTCHealthCheck.fromPartial(object.healthCheck)
      : undefined;
    return message;
  },
};

function createBaseWebrtcUpstreamService_CallsEntry(): WebrtcUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const WebrtcUpstreamService_CallsEntry: MessageFns<WebrtcUpstreamService_CallsEntry> = {
  encode(message: WebrtcUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WebrtcCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebrtcUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebrtcCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? WebrtcCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WebrtcUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = WebrtcCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcUpstreamService_CallsEntry>, I>>(
    base?: I,
  ): WebrtcUpstreamService_CallsEntry {
    return WebrtcUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcUpstreamService_CallsEntry>, I>>(
    object: I,
  ): WebrtcUpstreamService_CallsEntry {
    const message = createBaseWebrtcUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? WebrtcCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOpenapiUpstreamService(): OpenapiUpstreamService {
  return {
    address: "",
    specContent: undefined,
    specUrl: undefined,
    healthCheck: undefined,
    tlsConfig: undefined,
    tools: [],
    resources: [],
    calls: {},
    prompts: [],
  };
}

export const OpenapiUpstreamService: MessageFns<OpenapiUpstreamService> = {
  encode(message: OpenapiUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.specContent !== undefined) {
      writer.uint32(18).string(message.specContent);
    }
    if (message.specUrl !== undefined) {
      writer.uint32(74).string(message.specUrl);
    }
    if (message.healthCheck !== undefined) {
      HttpHealthCheck.encode(message.healthCheck, writer.uint32(26).fork()).join();
    }
    if (message.tlsConfig !== undefined) {
      TLSConfig.encode(message.tlsConfig, writer.uint32(34).fork()).join();
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(50).fork()).join();
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, OpenAPICallDefinition]) => {
      OpenapiUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenapiUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenapiUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specContent = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.specUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.healthCheck = HttpHealthCheck.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tlsConfig = TLSConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = OpenapiUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.calls[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenapiUpstreamService {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      specContent: isSet(object.spec_content) ? globalThis.String(object.spec_content) : undefined,
      specUrl: isSet(object.spec_url) ? globalThis.String(object.spec_url) : undefined,
      healthCheck: isSet(object.health_check) ? HttpHealthCheck.fromJSON(object.health_check) : undefined,
      tlsConfig: isSet(object.tls_config) ? TLSConfig.fromJSON(object.tls_config) : undefined,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: OpenAPICallDefinition }, [key, value]: [string, any]) => {
            acc[key] = OpenAPICallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OpenapiUpstreamService): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.specContent !== undefined) {
      obj.spec_content = message.specContent;
    }
    if (message.specUrl !== undefined) {
      obj.spec_url = message.specUrl;
    }
    if (message.healthCheck !== undefined) {
      obj.health_check = HttpHealthCheck.toJSON(message.healthCheck);
    }
    if (message.tlsConfig !== undefined) {
      obj.tls_config = TLSConfig.toJSON(message.tlsConfig);
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, OpenAPICallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = OpenAPICallDefinition.toJSON(v);
        });
      }
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenapiUpstreamService>, I>>(base?: I): OpenapiUpstreamService {
    return OpenapiUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenapiUpstreamService>, I>>(object: I): OpenapiUpstreamService {
    const message = createBaseOpenapiUpstreamService();
    message.address = object.address ?? "";
    message.specContent = object.specContent ?? undefined;
    message.specUrl = object.specUrl ?? undefined;
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? HttpHealthCheck.fromPartial(object.healthCheck)
      : undefined;
    message.tlsConfig = (object.tlsConfig !== undefined && object.tlsConfig !== null)
      ? TLSConfig.fromPartial(object.tlsConfig)
      : undefined;
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, OpenAPICallDefinition][]).reduce(
      (acc: { [key: string]: OpenAPICallDefinition }, [key, value]: [string, OpenAPICallDefinition]) => {
        if (value !== undefined) {
          acc[key] = OpenAPICallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOpenapiUpstreamService_CallsEntry(): OpenapiUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const OpenapiUpstreamService_CallsEntry: MessageFns<OpenapiUpstreamService_CallsEntry> = {
  encode(message: OpenapiUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      OpenAPICallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenapiUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenapiUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = OpenAPICallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenapiUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? OpenAPICallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: OpenapiUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = OpenAPICallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenapiUpstreamService_CallsEntry>, I>>(
    base?: I,
  ): OpenapiUpstreamService_CallsEntry {
    return OpenapiUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenapiUpstreamService_CallsEntry>, I>>(
    object: I,
  ): OpenapiUpstreamService_CallsEntry {
    const message = createBaseOpenapiUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? OpenAPICallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCommandLineUpstreamService(): CommandLineUpstreamService {
  return {
    command: "",
    workingDirectory: "",
    tools: [],
    healthCheck: undefined,
    cache: undefined,
    containerEnvironment: undefined,
    timeout: undefined,
    resources: [],
    calls: {},
    prompts: [],
    communicationProtocol: 0,
    local: false,
    env: {},
  };
}

export const CommandLineUpstreamService: MessageFns<CommandLineUpstreamService> = {
  encode(message: CommandLineUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(26).string(message.workingDirectory);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.healthCheck !== undefined) {
      CommandLineHealthCheck.encode(message.healthCheck, writer.uint32(42).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(50).fork()).join();
    }
    if (message.containerEnvironment !== undefined) {
      ContainerEnvironment.encode(message.containerEnvironment, writer.uint32(58).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(66).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(74).fork()).join();
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, CommandLineCallDefinition]) => {
      CommandLineUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.communicationProtocol !== 0) {
      writer.uint32(96).int32(message.communicationProtocol);
    }
    if (message.local !== false) {
      writer.uint32(104).bool(message.local);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, SecretValue]) => {
      CommandLineUpstreamService_EnvEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandLineUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandLineUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.healthCheck = CommandLineHealthCheck.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.containerEnvironment = ContainerEnvironment.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CommandLineUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.calls[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.communicationProtocol = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.local = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = CommandLineUpstreamService_EnvEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.env[entry14.key] = entry14.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandLineUpstreamService {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      workingDirectory: isSet(object.working_directory) ? globalThis.String(object.working_directory) : "",
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      healthCheck: isSet(object.health_check) ? CommandLineHealthCheck.fromJSON(object.health_check) : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      containerEnvironment: isSet(object.container_environment)
        ? ContainerEnvironment.fromJSON(object.container_environment)
        : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: CommandLineCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = CommandLineCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
      communicationProtocol: isSet(object.communication_protocol)
        ? commandLineUpstreamService_CommunicationProtocolFromJSON(object.communication_protocol)
        : 0,
      local: isSet(object.local) ? globalThis.Boolean(object.local) : false,
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: SecretValue }, [key, value]: [string, any]) => {
            acc[key] = SecretValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CommandLineUpstreamService): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.workingDirectory !== "") {
      obj.working_directory = message.workingDirectory;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.healthCheck !== undefined) {
      obj.health_check = CommandLineHealthCheck.toJSON(message.healthCheck);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.containerEnvironment !== undefined) {
      obj.container_environment = ContainerEnvironment.toJSON(message.containerEnvironment);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, CommandLineCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = CommandLineCallDefinition.toJSON(v);
        });
      }
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    if (message.communicationProtocol !== 0) {
      obj.communication_protocol = commandLineUpstreamService_CommunicationProtocolToJSON(
        message.communicationProtocol,
      );
    }
    if (message.local !== false) {
      obj.local = message.local;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, SecretValue][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = SecretValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandLineUpstreamService>, I>>(base?: I): CommandLineUpstreamService {
    return CommandLineUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandLineUpstreamService>, I>>(object: I): CommandLineUpstreamService {
    const message = createBaseCommandLineUpstreamService();
    message.command = object.command ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? CommandLineHealthCheck.fromPartial(object.healthCheck)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.containerEnvironment = (object.containerEnvironment !== undefined && object.containerEnvironment !== null)
      ? ContainerEnvironment.fromPartial(object.containerEnvironment)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, CommandLineCallDefinition][]).reduce(
      (acc: { [key: string]: CommandLineCallDefinition }, [key, value]: [string, CommandLineCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = CommandLineCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    message.communicationProtocol = object.communicationProtocol ?? 0;
    message.local = object.local ?? false;
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, SecretValue][]).reduce(
      (acc: { [key: string]: SecretValue }, [key, value]: [string, SecretValue]) => {
        if (value !== undefined) {
          acc[key] = SecretValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCommandLineUpstreamService_CallsEntry(): CommandLineUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const CommandLineUpstreamService_CallsEntry: MessageFns<CommandLineUpstreamService_CallsEntry> = {
  encode(message: CommandLineUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CommandLineCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandLineUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandLineUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CommandLineCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandLineUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CommandLineCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CommandLineUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CommandLineCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandLineUpstreamService_CallsEntry>, I>>(
    base?: I,
  ): CommandLineUpstreamService_CallsEntry {
    return CommandLineUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandLineUpstreamService_CallsEntry>, I>>(
    object: I,
  ): CommandLineUpstreamService_CallsEntry {
    const message = createBaseCommandLineUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CommandLineCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCommandLineUpstreamService_EnvEntry(): CommandLineUpstreamService_EnvEntry {
  return { key: "", value: undefined };
}

export const CommandLineUpstreamService_EnvEntry: MessageFns<CommandLineUpstreamService_EnvEntry> = {
  encode(message: CommandLineUpstreamService_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecretValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandLineUpstreamService_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandLineUpstreamService_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandLineUpstreamService_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecretValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CommandLineUpstreamService_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecretValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandLineUpstreamService_EnvEntry>, I>>(
    base?: I,
  ): CommandLineUpstreamService_EnvEntry {
    return CommandLineUpstreamService_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandLineUpstreamService_EnvEntry>, I>>(
    object: I,
  ): CommandLineUpstreamService_EnvEntry {
    const message = createBaseCommandLineUpstreamService_EnvEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGraphQLUpstreamService(): GraphQLUpstreamService {
  return { address: "", calls: {} };
}

export const GraphQLUpstreamService: MessageFns<GraphQLUpstreamService> = {
  encode(message: GraphQLUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, GraphQLCallDefinition]) => {
      GraphQLUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GraphQLUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphQLUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GraphQLUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.calls[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphQLUpstreamService {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: GraphQLCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = GraphQLCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GraphQLUpstreamService): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, GraphQLCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = GraphQLCallDefinition.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphQLUpstreamService>, I>>(base?: I): GraphQLUpstreamService {
    return GraphQLUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphQLUpstreamService>, I>>(object: I): GraphQLUpstreamService {
    const message = createBaseGraphQLUpstreamService();
    message.address = object.address ?? "";
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, GraphQLCallDefinition][]).reduce(
      (acc: { [key: string]: GraphQLCallDefinition }, [key, value]: [string, GraphQLCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = GraphQLCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGraphQLUpstreamService_CallsEntry(): GraphQLUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const GraphQLUpstreamService_CallsEntry: MessageFns<GraphQLUpstreamService_CallsEntry> = {
  encode(message: GraphQLUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      GraphQLCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GraphQLUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphQLUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = GraphQLCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphQLUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? GraphQLCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GraphQLUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = GraphQLCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphQLUpstreamService_CallsEntry>, I>>(
    base?: I,
  ): GraphQLUpstreamService_CallsEntry {
    return GraphQLUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphQLUpstreamService_CallsEntry>, I>>(
    object: I,
  ): GraphQLUpstreamService_CallsEntry {
    const message = createBaseGraphQLUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? GraphQLCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSqlUpstreamService(): SqlUpstreamService {
  return { driver: "", dsn: "", calls: {} };
}

export const SqlUpstreamService: MessageFns<SqlUpstreamService> = {
  encode(message: SqlUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driver !== "") {
      writer.uint32(10).string(message.driver);
    }
    if (message.dsn !== "") {
      writer.uint32(18).string(message.dsn);
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, SqlCallDefinition]) => {
      SqlUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.driver = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dsn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SqlUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.calls[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlUpstreamService {
    return {
      driver: isSet(object.driver) ? globalThis.String(object.driver) : "",
      dsn: isSet(object.dsn) ? globalThis.String(object.dsn) : "",
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: SqlCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = SqlCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SqlUpstreamService): unknown {
    const obj: any = {};
    if (message.driver !== "") {
      obj.driver = message.driver;
    }
    if (message.dsn !== "") {
      obj.dsn = message.dsn;
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, SqlCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = SqlCallDefinition.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqlUpstreamService>, I>>(base?: I): SqlUpstreamService {
    return SqlUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqlUpstreamService>, I>>(object: I): SqlUpstreamService {
    const message = createBaseSqlUpstreamService();
    message.driver = object.driver ?? "";
    message.dsn = object.dsn ?? "";
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, SqlCallDefinition][]).reduce(
      (acc: { [key: string]: SqlCallDefinition }, [key, value]: [string, SqlCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = SqlCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSqlUpstreamService_CallsEntry(): SqlUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const SqlUpstreamService_CallsEntry: MessageFns<SqlUpstreamService_CallsEntry> = {
  encode(message: SqlUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SqlCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SqlCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SqlCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SqlUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SqlCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqlUpstreamService_CallsEntry>, I>>(base?: I): SqlUpstreamService_CallsEntry {
    return SqlUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqlUpstreamService_CallsEntry>, I>>(
    object: I,
  ): SqlUpstreamService_CallsEntry {
    const message = createBaseSqlUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SqlCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFilesystemUpstreamService(): FilesystemUpstreamService {
  return {
    rootPaths: {},
    readOnly: false,
    tools: [],
    resources: [],
    prompts: [],
    allowedPaths: [],
    deniedPaths: [],
    symlinkMode: 0,
    os: undefined,
    tmpfs: undefined,
    http: undefined,
    zip: undefined,
    gcs: undefined,
    sftp: undefined,
    s3: undefined,
  };
}

export const FilesystemUpstreamService: MessageFns<FilesystemUpstreamService> = {
  encode(message: FilesystemUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.rootPaths).forEach(([key, value]: [string, string]) => {
      FilesystemUpstreamService_RootPathsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.readOnly !== false) {
      writer.uint32(16).bool(message.readOnly);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.allowedPaths) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.deniedPaths) {
      writer.uint32(58).string(v!);
    }
    if (message.symlinkMode !== 0) {
      writer.uint32(64).int32(message.symlinkMode);
    }
    if (message.os !== undefined) {
      OsFs.encode(message.os, writer.uint32(82).fork()).join();
    }
    if (message.tmpfs !== undefined) {
      MemMapFs.encode(message.tmpfs, writer.uint32(90).fork()).join();
    }
    if (message.http !== undefined) {
      HttpFs.encode(message.http, writer.uint32(98).fork()).join();
    }
    if (message.zip !== undefined) {
      ZipFs.encode(message.zip, writer.uint32(106).fork()).join();
    }
    if (message.gcs !== undefined) {
      GcsFs.encode(message.gcs, writer.uint32(114).fork()).join();
    }
    if (message.sftp !== undefined) {
      SftpFs.encode(message.sftp, writer.uint32(122).fork()).join();
    }
    if (message.s3 !== undefined) {
      S3Fs.encode(message.s3, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilesystemUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilesystemUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = FilesystemUpstreamService_RootPathsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.rootPaths[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.allowedPaths.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deniedPaths.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.symlinkMode = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.os = OsFs.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tmpfs = MemMapFs.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.http = HttpFs.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.zip = ZipFs.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gcs = GcsFs.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.sftp = SftpFs.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.s3 = S3Fs.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilesystemUpstreamService {
    return {
      rootPaths: isObject(object.root_paths)
        ? (globalThis.Object.entries(object.root_paths) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      readOnly: isSet(object.read_only) ? globalThis.Boolean(object.read_only) : false,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
      allowedPaths: globalThis.Array.isArray(object?.allowed_paths)
        ? object.allowed_paths.map((e: any) => globalThis.String(e))
        : [],
      deniedPaths: globalThis.Array.isArray(object?.denied_paths)
        ? object.denied_paths.map((e: any) => globalThis.String(e))
        : [],
      symlinkMode: isSet(object.symlink_mode) ? filesystemUpstreamService_SymlinkModeFromJSON(object.symlink_mode) : 0,
      os: isSet(object.os) ? OsFs.fromJSON(object.os) : undefined,
      tmpfs: isSet(object.tmpfs) ? MemMapFs.fromJSON(object.tmpfs) : undefined,
      http: isSet(object.http) ? HttpFs.fromJSON(object.http) : undefined,
      zip: isSet(object.zip) ? ZipFs.fromJSON(object.zip) : undefined,
      gcs: isSet(object.gcs) ? GcsFs.fromJSON(object.gcs) : undefined,
      sftp: isSet(object.sftp) ? SftpFs.fromJSON(object.sftp) : undefined,
      s3: isSet(object.s3) ? S3Fs.fromJSON(object.s3) : undefined,
    };
  },

  toJSON(message: FilesystemUpstreamService): unknown {
    const obj: any = {};
    if (message.rootPaths) {
      const entries = globalThis.Object.entries(message.rootPaths) as [string, string][];
      if (entries.length > 0) {
        obj.root_paths = {};
        entries.forEach(([k, v]) => {
          obj.root_paths[k] = v;
        });
      }
    }
    if (message.readOnly !== false) {
      obj.read_only = message.readOnly;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    if (message.allowedPaths?.length) {
      obj.allowed_paths = message.allowedPaths;
    }
    if (message.deniedPaths?.length) {
      obj.denied_paths = message.deniedPaths;
    }
    if (message.symlinkMode !== 0) {
      obj.symlink_mode = filesystemUpstreamService_SymlinkModeToJSON(message.symlinkMode);
    }
    if (message.os !== undefined) {
      obj.os = OsFs.toJSON(message.os);
    }
    if (message.tmpfs !== undefined) {
      obj.tmpfs = MemMapFs.toJSON(message.tmpfs);
    }
    if (message.http !== undefined) {
      obj.http = HttpFs.toJSON(message.http);
    }
    if (message.zip !== undefined) {
      obj.zip = ZipFs.toJSON(message.zip);
    }
    if (message.gcs !== undefined) {
      obj.gcs = GcsFs.toJSON(message.gcs);
    }
    if (message.sftp !== undefined) {
      obj.sftp = SftpFs.toJSON(message.sftp);
    }
    if (message.s3 !== undefined) {
      obj.s3 = S3Fs.toJSON(message.s3);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilesystemUpstreamService>, I>>(base?: I): FilesystemUpstreamService {
    return FilesystemUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilesystemUpstreamService>, I>>(object: I): FilesystemUpstreamService {
    const message = createBaseFilesystemUpstreamService();
    message.rootPaths = (globalThis.Object.entries(object.rootPaths ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.readOnly = object.readOnly ?? false;
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    message.allowedPaths = object.allowedPaths?.map((e) => e) || [];
    message.deniedPaths = object.deniedPaths?.map((e) => e) || [];
    message.symlinkMode = object.symlinkMode ?? 0;
    message.os = (object.os !== undefined && object.os !== null) ? OsFs.fromPartial(object.os) : undefined;
    message.tmpfs = (object.tmpfs !== undefined && object.tmpfs !== null)
      ? MemMapFs.fromPartial(object.tmpfs)
      : undefined;
    message.http = (object.http !== undefined && object.http !== null) ? HttpFs.fromPartial(object.http) : undefined;
    message.zip = (object.zip !== undefined && object.zip !== null) ? ZipFs.fromPartial(object.zip) : undefined;
    message.gcs = (object.gcs !== undefined && object.gcs !== null) ? GcsFs.fromPartial(object.gcs) : undefined;
    message.sftp = (object.sftp !== undefined && object.sftp !== null) ? SftpFs.fromPartial(object.sftp) : undefined;
    message.s3 = (object.s3 !== undefined && object.s3 !== null) ? S3Fs.fromPartial(object.s3) : undefined;
    return message;
  },
};

function createBaseFilesystemUpstreamService_RootPathsEntry(): FilesystemUpstreamService_RootPathsEntry {
  return { key: "", value: "" };
}

export const FilesystemUpstreamService_RootPathsEntry: MessageFns<FilesystemUpstreamService_RootPathsEntry> = {
  encode(message: FilesystemUpstreamService_RootPathsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilesystemUpstreamService_RootPathsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilesystemUpstreamService_RootPathsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilesystemUpstreamService_RootPathsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FilesystemUpstreamService_RootPathsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilesystemUpstreamService_RootPathsEntry>, I>>(
    base?: I,
  ): FilesystemUpstreamService_RootPathsEntry {
    return FilesystemUpstreamService_RootPathsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilesystemUpstreamService_RootPathsEntry>, I>>(
    object: I,
  ): FilesystemUpstreamService_RootPathsEntry {
    const message = createBaseFilesystemUpstreamService_RootPathsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOsFs(): OsFs {
  return {};
}

export const OsFs: MessageFns<OsFs> = {
  encode(_: OsFs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OsFs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOsFs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OsFs {
    return {};
  },

  toJSON(_: OsFs): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<OsFs>, I>>(base?: I): OsFs {
    return OsFs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OsFs>, I>>(_: I): OsFs {
    const message = createBaseOsFs();
    return message;
  },
};

function createBaseMemMapFs(): MemMapFs {
  return {};
}

export const MemMapFs: MessageFns<MemMapFs> = {
  encode(_: MemMapFs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemMapFs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemMapFs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MemMapFs {
    return {};
  },

  toJSON(_: MemMapFs): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MemMapFs>, I>>(base?: I): MemMapFs {
    return MemMapFs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemMapFs>, I>>(_: I): MemMapFs {
    const message = createBaseMemMapFs();
    return message;
  },
};

function createBaseHttpFs(): HttpFs {
  return { endpoint: "" };
}

export const HttpFs: MessageFns<HttpFs> = {
  encode(message: HttpFs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpFs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpFs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpFs {
    return { endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "" };
  },

  toJSON(message: HttpFs): unknown {
    const obj: any = {};
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpFs>, I>>(base?: I): HttpFs {
    return HttpFs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpFs>, I>>(object: I): HttpFs {
    const message = createBaseHttpFs();
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

function createBaseZipFs(): ZipFs {
  return { filePath: "" };
}

export const ZipFs: MessageFns<ZipFs> = {
  encode(message: ZipFs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZipFs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZipFs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZipFs {
    return {
      filePath: isSet(object.filePath)
        ? globalThis.String(object.filePath)
        : isSet(object.file_path)
        ? globalThis.String(object.file_path)
        : "",
    };
  },

  toJSON(message: ZipFs): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZipFs>, I>>(base?: I): ZipFs {
    return ZipFs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZipFs>, I>>(object: I): ZipFs {
    const message = createBaseZipFs();
    message.filePath = object.filePath ?? "";
    return message;
  },
};

function createBaseGcsFs(): GcsFs {
  return { bucket: "" };
}

export const GcsFs: MessageFns<GcsFs> = {
  encode(message: GcsFs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsFs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsFs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsFs {
    return { bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "" };
  },

  toJSON(message: GcsFs): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GcsFs>, I>>(base?: I): GcsFs {
    return GcsFs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GcsFs>, I>>(object: I): GcsFs {
    const message = createBaseGcsFs();
    message.bucket = object.bucket ?? "";
    return message;
  },
};

function createBaseS3Fs(): S3Fs {
  return { bucket: "", region: "", accessKeyId: "", secretAccessKey: "", sessionToken: "", endpoint: "" };
}

export const S3Fs: MessageFns<S3Fs> = {
  encode(message: S3Fs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    if (message.accessKeyId !== "") {
      writer.uint32(26).string(message.accessKeyId);
    }
    if (message.secretAccessKey !== "") {
      writer.uint32(34).string(message.secretAccessKey);
    }
    if (message.sessionToken !== "") {
      writer.uint32(42).string(message.sessionToken);
    }
    if (message.endpoint !== "") {
      writer.uint32(50).string(message.endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): S3Fs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseS3Fs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessKeyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secretAccessKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): S3Fs {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      accessKeyId: isSet(object.accessKeyId)
        ? globalThis.String(object.accessKeyId)
        : isSet(object.access_key_id)
        ? globalThis.String(object.access_key_id)
        : "",
      secretAccessKey: isSet(object.secretAccessKey)
        ? globalThis.String(object.secretAccessKey)
        : isSet(object.secret_access_key)
        ? globalThis.String(object.secret_access_key)
        : "",
      sessionToken: isSet(object.sessionToken)
        ? globalThis.String(object.sessionToken)
        : isSet(object.session_token)
        ? globalThis.String(object.session_token)
        : "",
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
    };
  },

  toJSON(message: S3Fs): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.accessKeyId !== "") {
      obj.accessKeyId = message.accessKeyId;
    }
    if (message.secretAccessKey !== "") {
      obj.secretAccessKey = message.secretAccessKey;
    }
    if (message.sessionToken !== "") {
      obj.sessionToken = message.sessionToken;
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<S3Fs>, I>>(base?: I): S3Fs {
    return S3Fs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<S3Fs>, I>>(object: I): S3Fs {
    const message = createBaseS3Fs();
    message.bucket = object.bucket ?? "";
    message.region = object.region ?? "";
    message.accessKeyId = object.accessKeyId ?? "";
    message.secretAccessKey = object.secretAccessKey ?? "";
    message.sessionToken = object.sessionToken ?? "";
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

function createBaseSftpFs(): SftpFs {
  return { address: "", username: "", password: "", keyPath: "" };
}

export const SftpFs: MessageFns<SftpFs> = {
  encode(message: SftpFs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.keyPath !== "") {
      writer.uint32(34).string(message.keyPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SftpFs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSftpFs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keyPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SftpFs {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      keyPath: isSet(object.keyPath)
        ? globalThis.String(object.keyPath)
        : isSet(object.key_path)
        ? globalThis.String(object.key_path)
        : "",
    };
  },

  toJSON(message: SftpFs): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.keyPath !== "") {
      obj.keyPath = message.keyPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SftpFs>, I>>(base?: I): SftpFs {
    return SftpFs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SftpFs>, I>>(object: I): SftpFs {
    const message = createBaseSftpFs();
    message.address = object.address ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.keyPath = object.keyPath ?? "";
    return message;
  },
};

function createBaseVectorUpstreamService(): VectorUpstreamService {
  return { pinecone: undefined, milvus: undefined, tools: [], resources: [], prompts: [] };
}

export const VectorUpstreamService: MessageFns<VectorUpstreamService> = {
  encode(message: VectorUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pinecone !== undefined) {
      PineconeVectorDB.encode(message.pinecone, writer.uint32(10).fork()).join();
    }
    if (message.milvus !== undefined) {
      MilvusVectorDB.encode(message.milvus, writer.uint32(42).fork()).join();
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VectorUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectorUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pinecone = PineconeVectorDB.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.milvus = MilvusVectorDB.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VectorUpstreamService {
    return {
      pinecone: isSet(object.pinecone) ? PineconeVectorDB.fromJSON(object.pinecone) : undefined,
      milvus: isSet(object.milvus) ? MilvusVectorDB.fromJSON(object.milvus) : undefined,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VectorUpstreamService): unknown {
    const obj: any = {};
    if (message.pinecone !== undefined) {
      obj.pinecone = PineconeVectorDB.toJSON(message.pinecone);
    }
    if (message.milvus !== undefined) {
      obj.milvus = MilvusVectorDB.toJSON(message.milvus);
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VectorUpstreamService>, I>>(base?: I): VectorUpstreamService {
    return VectorUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VectorUpstreamService>, I>>(object: I): VectorUpstreamService {
    const message = createBaseVectorUpstreamService();
    message.pinecone = (object.pinecone !== undefined && object.pinecone !== null)
      ? PineconeVectorDB.fromPartial(object.pinecone)
      : undefined;
    message.milvus = (object.milvus !== undefined && object.milvus !== null)
      ? MilvusVectorDB.fromPartial(object.milvus)
      : undefined;
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBasePineconeVectorDB(): PineconeVectorDB {
  return { apiKey: "", environment: "", indexName: "", projectId: "", host: "" };
}

export const PineconeVectorDB: MessageFns<PineconeVectorDB> = {
  encode(message: PineconeVectorDB, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== "") {
      writer.uint32(10).string(message.apiKey);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    if (message.indexName !== "") {
      writer.uint32(26).string(message.indexName);
    }
    if (message.projectId !== "") {
      writer.uint32(34).string(message.projectId);
    }
    if (message.host !== "") {
      writer.uint32(42).string(message.host);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PineconeVectorDB {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePineconeVectorDB();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.indexName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.host = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PineconeVectorDB {
    return {
      apiKey: isSet(object.api_key) ? globalThis.String(object.api_key) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      indexName: isSet(object.index_name) ? globalThis.String(object.index_name) : "",
      projectId: isSet(object.project_id) ? globalThis.String(object.project_id) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
    };
  },

  toJSON(message: PineconeVectorDB): unknown {
    const obj: any = {};
    if (message.apiKey !== "") {
      obj.api_key = message.apiKey;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.indexName !== "") {
      obj.index_name = message.indexName;
    }
    if (message.projectId !== "") {
      obj.project_id = message.projectId;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PineconeVectorDB>, I>>(base?: I): PineconeVectorDB {
    return PineconeVectorDB.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PineconeVectorDB>, I>>(object: I): PineconeVectorDB {
    const message = createBasePineconeVectorDB();
    message.apiKey = object.apiKey ?? "";
    message.environment = object.environment ?? "";
    message.indexName = object.indexName ?? "";
    message.projectId = object.projectId ?? "";
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseMilvusVectorDB(): MilvusVectorDB {
  return { address: "", username: "", password: "", collectionName: "", databaseName: "", useTls: false, apiKey: "" };
}

export const MilvusVectorDB: MessageFns<MilvusVectorDB> = {
  encode(message: MilvusVectorDB, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.collectionName !== "") {
      writer.uint32(34).string(message.collectionName);
    }
    if (message.databaseName !== "") {
      writer.uint32(42).string(message.databaseName);
    }
    if (message.useTls !== false) {
      writer.uint32(48).bool(message.useTls);
    }
    if (message.apiKey !== "") {
      writer.uint32(58).string(message.apiKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MilvusVectorDB {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMilvusVectorDB();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.collectionName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.databaseName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.useTls = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MilvusVectorDB {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      collectionName: isSet(object.collection_name) ? globalThis.String(object.collection_name) : "",
      databaseName: isSet(object.database_name) ? globalThis.String(object.database_name) : "",
      useTls: isSet(object.use_tls) ? globalThis.Boolean(object.use_tls) : false,
      apiKey: isSet(object.api_key) ? globalThis.String(object.api_key) : "",
    };
  },

  toJSON(message: MilvusVectorDB): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.collectionName !== "") {
      obj.collection_name = message.collectionName;
    }
    if (message.databaseName !== "") {
      obj.database_name = message.databaseName;
    }
    if (message.useTls !== false) {
      obj.use_tls = message.useTls;
    }
    if (message.apiKey !== "") {
      obj.api_key = message.apiKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MilvusVectorDB>, I>>(base?: I): MilvusVectorDB {
    return MilvusVectorDB.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MilvusVectorDB>, I>>(object: I): MilvusVectorDB {
    const message = createBaseMilvusVectorDB();
    message.address = object.address ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.collectionName = object.collectionName ?? "";
    message.databaseName = object.databaseName ?? "";
    message.useTls = object.useTls ?? false;
    message.apiKey = object.apiKey ?? "";
    return message;
  },
};

function createBaseMcpUpstreamService(): McpUpstreamService {
  return {
    httpConnection: undefined,
    stdioConnection: undefined,
    bundleConnection: undefined,
    toolAutoDiscovery: false,
    tools: [],
    resources: [],
    calls: {},
    prompts: [],
  };
}

export const McpUpstreamService: MessageFns<McpUpstreamService> = {
  encode(message: McpUpstreamService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpConnection !== undefined) {
      McpStreamableHttpConnection.encode(message.httpConnection, writer.uint32(10).fork()).join();
    }
    if (message.stdioConnection !== undefined) {
      McpStdioConnection.encode(message.stdioConnection, writer.uint32(18).fork()).join();
    }
    if (message.bundleConnection !== undefined) {
      McpBundleConnection.encode(message.bundleConnection, writer.uint32(34).fork()).join();
    }
    if (message.toolAutoDiscovery !== false) {
      writer.uint32(24).bool(message.toolAutoDiscovery);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.resources) {
      ResourceDefinition.encode(v!, writer.uint32(58).fork()).join();
    }
    globalThis.Object.entries(message.calls).forEach(([key, value]: [string, MCPCallDefinition]) => {
      McpUpstreamService_CallsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    for (const v of message.prompts) {
      PromptDefinition.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpUpstreamService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpUpstreamService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.httpConnection = McpStreamableHttpConnection.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stdioConnection = McpStdioConnection.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bundleConnection = McpBundleConnection.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toolAutoDiscovery = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.resources.push(ResourceDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = McpUpstreamService_CallsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.calls[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.prompts.push(PromptDefinition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpUpstreamService {
    return {
      httpConnection: isSet(object.http_connection)
        ? McpStreamableHttpConnection.fromJSON(object.http_connection)
        : undefined,
      stdioConnection: isSet(object.stdio_connection)
        ? McpStdioConnection.fromJSON(object.stdio_connection)
        : undefined,
      bundleConnection: isSet(object.bundle_connection)
        ? McpBundleConnection.fromJSON(object.bundle_connection)
        : undefined,
      toolAutoDiscovery: isSet(object.tool_auto_discovery) ? globalThis.Boolean(object.tool_auto_discovery) : false,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => ResourceDefinition.fromJSON(e))
        : [],
      calls: isObject(object.calls)
        ? (globalThis.Object.entries(object.calls) as [string, any][]).reduce(
          (acc: { [key: string]: MCPCallDefinition }, [key, value]: [string, any]) => {
            acc[key] = MCPCallDefinition.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PromptDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: McpUpstreamService): unknown {
    const obj: any = {};
    if (message.httpConnection !== undefined) {
      obj.http_connection = McpStreamableHttpConnection.toJSON(message.httpConnection);
    }
    if (message.stdioConnection !== undefined) {
      obj.stdio_connection = McpStdioConnection.toJSON(message.stdioConnection);
    }
    if (message.bundleConnection !== undefined) {
      obj.bundle_connection = McpBundleConnection.toJSON(message.bundleConnection);
    }
    if (message.toolAutoDiscovery !== false) {
      obj.tool_auto_discovery = message.toolAutoDiscovery;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => ResourceDefinition.toJSON(e));
    }
    if (message.calls) {
      const entries = globalThis.Object.entries(message.calls) as [string, MCPCallDefinition][];
      if (entries.length > 0) {
        obj.calls = {};
        entries.forEach(([k, v]) => {
          obj.calls[k] = MCPCallDefinition.toJSON(v);
        });
      }
    }
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PromptDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpUpstreamService>, I>>(base?: I): McpUpstreamService {
    return McpUpstreamService.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpUpstreamService>, I>>(object: I): McpUpstreamService {
    const message = createBaseMcpUpstreamService();
    message.httpConnection = (object.httpConnection !== undefined && object.httpConnection !== null)
      ? McpStreamableHttpConnection.fromPartial(object.httpConnection)
      : undefined;
    message.stdioConnection = (object.stdioConnection !== undefined && object.stdioConnection !== null)
      ? McpStdioConnection.fromPartial(object.stdioConnection)
      : undefined;
    message.bundleConnection = (object.bundleConnection !== undefined && object.bundleConnection !== null)
      ? McpBundleConnection.fromPartial(object.bundleConnection)
      : undefined;
    message.toolAutoDiscovery = object.toolAutoDiscovery ?? false;
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => ResourceDefinition.fromPartial(e)) || [];
    message.calls = (globalThis.Object.entries(object.calls ?? {}) as [string, MCPCallDefinition][]).reduce(
      (acc: { [key: string]: MCPCallDefinition }, [key, value]: [string, MCPCallDefinition]) => {
        if (value !== undefined) {
          acc[key] = MCPCallDefinition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.prompts = object.prompts?.map((e) => PromptDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMcpUpstreamService_CallsEntry(): McpUpstreamService_CallsEntry {
  return { key: "", value: undefined };
}

export const McpUpstreamService_CallsEntry: MessageFns<McpUpstreamService_CallsEntry> = {
  encode(message: McpUpstreamService_CallsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MCPCallDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpUpstreamService_CallsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpUpstreamService_CallsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MCPCallDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpUpstreamService_CallsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? MCPCallDefinition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: McpUpstreamService_CallsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = MCPCallDefinition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpUpstreamService_CallsEntry>, I>>(base?: I): McpUpstreamService_CallsEntry {
    return McpUpstreamService_CallsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpUpstreamService_CallsEntry>, I>>(
    object: I,
  ): McpUpstreamService_CallsEntry {
    const message = createBaseMcpUpstreamService_CallsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MCPCallDefinition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMcpStdioConnection(): McpStdioConnection {
  return {
    command: "",
    workingDirectory: "",
    containerImage: "",
    args: [],
    setupCommands: [],
    env: {},
    validation: undefined,
  };
}

export const McpStdioConnection: MessageFns<McpStdioConnection> = {
  encode(message: McpStdioConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(18).string(message.workingDirectory);
    }
    if (message.containerImage !== "") {
      writer.uint32(26).string(message.containerImage);
    }
    for (const v of message.args) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.setupCommands) {
      writer.uint32(42).string(v!);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, SecretValue]) => {
      McpStdioConnection_EnvEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.validation !== undefined) {
      EnvValidation.encode(message.validation, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpStdioConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpStdioConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.setupCommands.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = McpStdioConnection_EnvEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.env[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.validation = EnvValidation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpStdioConnection {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      workingDirectory: isSet(object.working_directory) ? globalThis.String(object.working_directory) : "",
      containerImage: isSet(object.container_image) ? globalThis.String(object.container_image) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      setupCommands: globalThis.Array.isArray(object?.setup_commands)
        ? object.setup_commands.map((e: any) => globalThis.String(e))
        : [],
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: SecretValue }, [key, value]: [string, any]) => {
            acc[key] = SecretValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      validation: isSet(object.validation) ? EnvValidation.fromJSON(object.validation) : undefined,
    };
  },

  toJSON(message: McpStdioConnection): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.workingDirectory !== "") {
      obj.working_directory = message.workingDirectory;
    }
    if (message.containerImage !== "") {
      obj.container_image = message.containerImage;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.setupCommands?.length) {
      obj.setup_commands = message.setupCommands;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, SecretValue][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = SecretValue.toJSON(v);
        });
      }
    }
    if (message.validation !== undefined) {
      obj.validation = EnvValidation.toJSON(message.validation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpStdioConnection>, I>>(base?: I): McpStdioConnection {
    return McpStdioConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpStdioConnection>, I>>(object: I): McpStdioConnection {
    const message = createBaseMcpStdioConnection();
    message.command = object.command ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    message.containerImage = object.containerImage ?? "";
    message.args = object.args?.map((e) => e) || [];
    message.setupCommands = object.setupCommands?.map((e) => e) || [];
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, SecretValue][]).reduce(
      (acc: { [key: string]: SecretValue }, [key, value]: [string, SecretValue]) => {
        if (value !== undefined) {
          acc[key] = SecretValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.validation = (object.validation !== undefined && object.validation !== null)
      ? EnvValidation.fromPartial(object.validation)
      : undefined;
    return message;
  },
};

function createBaseMcpStdioConnection_EnvEntry(): McpStdioConnection_EnvEntry {
  return { key: "", value: undefined };
}

export const McpStdioConnection_EnvEntry: MessageFns<McpStdioConnection_EnvEntry> = {
  encode(message: McpStdioConnection_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecretValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpStdioConnection_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpStdioConnection_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpStdioConnection_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecretValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: McpStdioConnection_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecretValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpStdioConnection_EnvEntry>, I>>(base?: I): McpStdioConnection_EnvEntry {
    return McpStdioConnection_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpStdioConnection_EnvEntry>, I>>(object: I): McpStdioConnection_EnvEntry {
    const message = createBaseMcpStdioConnection_EnvEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEnvValidation(): EnvValidation {
  return { requiredEnv: [] };
}

export const EnvValidation: MessageFns<EnvValidation> = {
  encode(message: EnvValidation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requiredEnv) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvValidation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requiredEnv.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvValidation {
    return {
      requiredEnv: globalThis.Array.isArray(object?.required_env)
        ? object.required_env.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EnvValidation): unknown {
    const obj: any = {};
    if (message.requiredEnv?.length) {
      obj.required_env = message.requiredEnv;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvValidation>, I>>(base?: I): EnvValidation {
    return EnvValidation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvValidation>, I>>(object: I): EnvValidation {
    const message = createBaseEnvValidation();
    message.requiredEnv = object.requiredEnv?.map((e) => e) || [];
    return message;
  },
};

function createBaseMcpStreamableHttpConnection(): McpStreamableHttpConnection {
  return { httpAddress: "", tlsConfig: undefined, allowHttpRedirect: false };
}

export const McpStreamableHttpConnection: MessageFns<McpStreamableHttpConnection> = {
  encode(message: McpStreamableHttpConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpAddress !== "") {
      writer.uint32(10).string(message.httpAddress);
    }
    if (message.tlsConfig !== undefined) {
      TLSConfig.encode(message.tlsConfig, writer.uint32(42).fork()).join();
    }
    if (message.allowHttpRedirect !== false) {
      writer.uint32(48).bool(message.allowHttpRedirect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpStreamableHttpConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpStreamableHttpConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.httpAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tlsConfig = TLSConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.allowHttpRedirect = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpStreamableHttpConnection {
    return {
      httpAddress: isSet(object.http_address) ? globalThis.String(object.http_address) : "",
      tlsConfig: isSet(object.tls_config) ? TLSConfig.fromJSON(object.tls_config) : undefined,
      allowHttpRedirect: isSet(object.allow_http_redirect) ? globalThis.Boolean(object.allow_http_redirect) : false,
    };
  },

  toJSON(message: McpStreamableHttpConnection): unknown {
    const obj: any = {};
    if (message.httpAddress !== "") {
      obj.http_address = message.httpAddress;
    }
    if (message.tlsConfig !== undefined) {
      obj.tls_config = TLSConfig.toJSON(message.tlsConfig);
    }
    if (message.allowHttpRedirect !== false) {
      obj.allow_http_redirect = message.allowHttpRedirect;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpStreamableHttpConnection>, I>>(base?: I): McpStreamableHttpConnection {
    return McpStreamableHttpConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpStreamableHttpConnection>, I>>(object: I): McpStreamableHttpConnection {
    const message = createBaseMcpStreamableHttpConnection();
    message.httpAddress = object.httpAddress ?? "";
    message.tlsConfig = (object.tlsConfig !== undefined && object.tlsConfig !== null)
      ? TLSConfig.fromPartial(object.tlsConfig)
      : undefined;
    message.allowHttpRedirect = object.allowHttpRedirect ?? false;
    return message;
  },
};

function createBaseMcpBundleConnection(): McpBundleConnection {
  return { bundlePath: "", containerImage: "", env: {} };
}

export const McpBundleConnection: MessageFns<McpBundleConnection> = {
  encode(message: McpBundleConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bundlePath !== "") {
      writer.uint32(10).string(message.bundlePath);
    }
    if (message.containerImage !== "") {
      writer.uint32(18).string(message.containerImage);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, SecretValue]) => {
      McpBundleConnection_EnvEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpBundleConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpBundleConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bundlePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = McpBundleConnection_EnvEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.env[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpBundleConnection {
    return {
      bundlePath: isSet(object.bundle_path) ? globalThis.String(object.bundle_path) : "",
      containerImage: isSet(object.container_image) ? globalThis.String(object.container_image) : "",
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: SecretValue }, [key, value]: [string, any]) => {
            acc[key] = SecretValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: McpBundleConnection): unknown {
    const obj: any = {};
    if (message.bundlePath !== "") {
      obj.bundle_path = message.bundlePath;
    }
    if (message.containerImage !== "") {
      obj.container_image = message.containerImage;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, SecretValue][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = SecretValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpBundleConnection>, I>>(base?: I): McpBundleConnection {
    return McpBundleConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpBundleConnection>, I>>(object: I): McpBundleConnection {
    const message = createBaseMcpBundleConnection();
    message.bundlePath = object.bundlePath ?? "";
    message.containerImage = object.containerImage ?? "";
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, SecretValue][]).reduce(
      (acc: { [key: string]: SecretValue }, [key, value]: [string, SecretValue]) => {
        if (value !== undefined) {
          acc[key] = SecretValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMcpBundleConnection_EnvEntry(): McpBundleConnection_EnvEntry {
  return { key: "", value: undefined };
}

export const McpBundleConnection_EnvEntry: MessageFns<McpBundleConnection_EnvEntry> = {
  encode(message: McpBundleConnection_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecretValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpBundleConnection_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpBundleConnection_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpBundleConnection_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecretValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: McpBundleConnection_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecretValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<McpBundleConnection_EnvEntry>, I>>(base?: I): McpBundleConnection_EnvEntry {
    return McpBundleConnection_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<McpBundleConnection_EnvEntry>, I>>(object: I): McpBundleConnection_EnvEntry {
    const message = createBaseMcpBundleConnection_EnvEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseConnectionPoolConfig(): ConnectionPoolConfig {
  return { maxConnections: 0, maxIdleConnections: 0, idleTimeout: undefined };
}

export const ConnectionPoolConfig: MessageFns<ConnectionPoolConfig> = {
  encode(message: ConnectionPoolConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxConnections !== 0) {
      writer.uint32(8).int32(message.maxConnections);
    }
    if (message.maxIdleConnections !== 0) {
      writer.uint32(16).int32(message.maxIdleConnections);
    }
    if (message.idleTimeout !== undefined) {
      Duration.encode(message.idleTimeout, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionPoolConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionPoolConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxConnections = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxIdleConnections = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.idleTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionPoolConfig {
    return {
      maxConnections: isSet(object.max_connections) ? globalThis.Number(object.max_connections) : 0,
      maxIdleConnections: isSet(object.max_idle_connections) ? globalThis.Number(object.max_idle_connections) : 0,
      idleTimeout: isSet(object.idle_timeout) ? Duration.fromJSON(object.idle_timeout) : undefined,
    };
  },

  toJSON(message: ConnectionPoolConfig): unknown {
    const obj: any = {};
    if (message.maxConnections !== 0) {
      obj.max_connections = Math.round(message.maxConnections);
    }
    if (message.maxIdleConnections !== 0) {
      obj.max_idle_connections = Math.round(message.maxIdleConnections);
    }
    if (message.idleTimeout !== undefined) {
      obj.idle_timeout = Duration.toJSON(message.idleTimeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionPoolConfig>, I>>(base?: I): ConnectionPoolConfig {
    return ConnectionPoolConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionPoolConfig>, I>>(object: I): ConnectionPoolConfig {
    const message = createBaseConnectionPoolConfig();
    message.maxConnections = object.maxConnections ?? 0;
    message.maxIdleConnections = object.maxIdleConnections ?? 0;
    message.idleTimeout = (object.idleTimeout !== undefined && object.idleTimeout !== null)
      ? Duration.fromPartial(object.idleTimeout)
      : undefined;
    return message;
  },
};

function createBaseContainerEnvironment(): ContainerEnvironment {
  return { name: "", image: "", volumes: {}, env: {} };
}

export const ContainerEnvironment: MessageFns<ContainerEnvironment> = {
  encode(message: ContainerEnvironment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.image !== "") {
      writer.uint32(18).string(message.image);
    }
    globalThis.Object.entries(message.volumes).forEach(([key, value]: [string, string]) => {
      ContainerEnvironment_VolumesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, SecretValue]) => {
      ContainerEnvironment_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerEnvironment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ContainerEnvironment_VolumesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.volumes[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ContainerEnvironment_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerEnvironment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      volumes: isObject(object.volumes)
        ? (globalThis.Object.entries(object.volumes) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: SecretValue }, [key, value]: [string, any]) => {
            acc[key] = SecretValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ContainerEnvironment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.volumes) {
      const entries = globalThis.Object.entries(message.volumes) as [string, string][];
      if (entries.length > 0) {
        obj.volumes = {};
        entries.forEach(([k, v]) => {
          obj.volumes[k] = v;
        });
      }
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, SecretValue][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = SecretValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerEnvironment>, I>>(base?: I): ContainerEnvironment {
    return ContainerEnvironment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerEnvironment>, I>>(object: I): ContainerEnvironment {
    const message = createBaseContainerEnvironment();
    message.name = object.name ?? "";
    message.image = object.image ?? "";
    message.volumes = (globalThis.Object.entries(object.volumes ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, SecretValue][]).reduce(
      (acc: { [key: string]: SecretValue }, [key, value]: [string, SecretValue]) => {
        if (value !== undefined) {
          acc[key] = SecretValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseContainerEnvironment_VolumesEntry(): ContainerEnvironment_VolumesEntry {
  return { key: "", value: "" };
}

export const ContainerEnvironment_VolumesEntry: MessageFns<ContainerEnvironment_VolumesEntry> = {
  encode(message: ContainerEnvironment_VolumesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerEnvironment_VolumesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerEnvironment_VolumesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerEnvironment_VolumesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ContainerEnvironment_VolumesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerEnvironment_VolumesEntry>, I>>(
    base?: I,
  ): ContainerEnvironment_VolumesEntry {
    return ContainerEnvironment_VolumesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerEnvironment_VolumesEntry>, I>>(
    object: I,
  ): ContainerEnvironment_VolumesEntry {
    const message = createBaseContainerEnvironment_VolumesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseContainerEnvironment_EnvEntry(): ContainerEnvironment_EnvEntry {
  return { key: "", value: undefined };
}

export const ContainerEnvironment_EnvEntry: MessageFns<ContainerEnvironment_EnvEntry> = {
  encode(message: ContainerEnvironment_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecretValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerEnvironment_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerEnvironment_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerEnvironment_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecretValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ContainerEnvironment_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecretValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerEnvironment_EnvEntry>, I>>(base?: I): ContainerEnvironment_EnvEntry {
    return ContainerEnvironment_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerEnvironment_EnvEntry>, I>>(
    object: I,
  ): ContainerEnvironment_EnvEntry {
    const message = createBaseContainerEnvironment_EnvEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseResilienceConfig(): ResilienceConfig {
  return { circuitBreaker: undefined, retryPolicy: undefined, timeout: undefined };
}

export const ResilienceConfig: MessageFns<ResilienceConfig> = {
  encode(message: ResilienceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.circuitBreaker !== undefined) {
      CircuitBreakerConfig.encode(message.circuitBreaker, writer.uint32(10).fork()).join();
    }
    if (message.retryPolicy !== undefined) {
      RetryConfig.encode(message.retryPolicy, writer.uint32(18).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResilienceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResilienceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.circuitBreaker = CircuitBreakerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryPolicy = RetryConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResilienceConfig {
    return {
      circuitBreaker: isSet(object.circuit_breaker) ? CircuitBreakerConfig.fromJSON(object.circuit_breaker) : undefined,
      retryPolicy: isSet(object.retry_policy) ? RetryConfig.fromJSON(object.retry_policy) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
    };
  },

  toJSON(message: ResilienceConfig): unknown {
    const obj: any = {};
    if (message.circuitBreaker !== undefined) {
      obj.circuit_breaker = CircuitBreakerConfig.toJSON(message.circuitBreaker);
    }
    if (message.retryPolicy !== undefined) {
      obj.retry_policy = RetryConfig.toJSON(message.retryPolicy);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResilienceConfig>, I>>(base?: I): ResilienceConfig {
    return ResilienceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResilienceConfig>, I>>(object: I): ResilienceConfig {
    const message = createBaseResilienceConfig();
    message.circuitBreaker = (object.circuitBreaker !== undefined && object.circuitBreaker !== null)
      ? CircuitBreakerConfig.fromPartial(object.circuitBreaker)
      : undefined;
    message.retryPolicy = (object.retryPolicy !== undefined && object.retryPolicy !== null)
      ? RetryConfig.fromPartial(object.retryPolicy)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    return message;
  },
};

function createBaseCircuitBreakerConfig(): CircuitBreakerConfig {
  return { failureRateThreshold: 0, consecutiveFailures: 0, openDuration: undefined, halfOpenRequests: 0 };
}

export const CircuitBreakerConfig: MessageFns<CircuitBreakerConfig> = {
  encode(message: CircuitBreakerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.failureRateThreshold !== 0) {
      writer.uint32(9).double(message.failureRateThreshold);
    }
    if (message.consecutiveFailures !== 0) {
      writer.uint32(16).int32(message.consecutiveFailures);
    }
    if (message.openDuration !== undefined) {
      Duration.encode(message.openDuration, writer.uint32(26).fork()).join();
    }
    if (message.halfOpenRequests !== 0) {
      writer.uint32(32).int32(message.halfOpenRequests);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CircuitBreakerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCircuitBreakerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.failureRateThreshold = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.consecutiveFailures = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.openDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.halfOpenRequests = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CircuitBreakerConfig {
    return {
      failureRateThreshold: isSet(object.failure_rate_threshold) ? globalThis.Number(object.failure_rate_threshold) : 0,
      consecutiveFailures: isSet(object.consecutive_failures) ? globalThis.Number(object.consecutive_failures) : 0,
      openDuration: isSet(object.open_duration) ? Duration.fromJSON(object.open_duration) : undefined,
      halfOpenRequests: isSet(object.half_open_requests) ? globalThis.Number(object.half_open_requests) : 0,
    };
  },

  toJSON(message: CircuitBreakerConfig): unknown {
    const obj: any = {};
    if (message.failureRateThreshold !== 0) {
      obj.failure_rate_threshold = message.failureRateThreshold;
    }
    if (message.consecutiveFailures !== 0) {
      obj.consecutive_failures = Math.round(message.consecutiveFailures);
    }
    if (message.openDuration !== undefined) {
      obj.open_duration = Duration.toJSON(message.openDuration);
    }
    if (message.halfOpenRequests !== 0) {
      obj.half_open_requests = Math.round(message.halfOpenRequests);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CircuitBreakerConfig>, I>>(base?: I): CircuitBreakerConfig {
    return CircuitBreakerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CircuitBreakerConfig>, I>>(object: I): CircuitBreakerConfig {
    const message = createBaseCircuitBreakerConfig();
    message.failureRateThreshold = object.failureRateThreshold ?? 0;
    message.consecutiveFailures = object.consecutiveFailures ?? 0;
    message.openDuration = (object.openDuration !== undefined && object.openDuration !== null)
      ? Duration.fromPartial(object.openDuration)
      : undefined;
    message.halfOpenRequests = object.halfOpenRequests ?? 0;
    return message;
  },
};

function createBaseRetryConfig(): RetryConfig {
  return { numberOfRetries: 0, baseBackoff: undefined, maxBackoff: undefined, maxElapsedTime: undefined };
}

export const RetryConfig: MessageFns<RetryConfig> = {
  encode(message: RetryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numberOfRetries !== 0) {
      writer.uint32(8).int32(message.numberOfRetries);
    }
    if (message.baseBackoff !== undefined) {
      Duration.encode(message.baseBackoff, writer.uint32(18).fork()).join();
    }
    if (message.maxBackoff !== undefined) {
      Duration.encode(message.maxBackoff, writer.uint32(26).fork()).join();
    }
    if (message.maxElapsedTime !== undefined) {
      Duration.encode(message.maxElapsedTime, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numberOfRetries = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseBackoff = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxBackoff = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxElapsedTime = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryConfig {
    return {
      numberOfRetries: isSet(object.number_of_retries) ? globalThis.Number(object.number_of_retries) : 0,
      baseBackoff: isSet(object.base_backoff) ? Duration.fromJSON(object.base_backoff) : undefined,
      maxBackoff: isSet(object.max_backoff) ? Duration.fromJSON(object.max_backoff) : undefined,
      maxElapsedTime: isSet(object.max_elapsed_time) ? Duration.fromJSON(object.max_elapsed_time) : undefined,
    };
  },

  toJSON(message: RetryConfig): unknown {
    const obj: any = {};
    if (message.numberOfRetries !== 0) {
      obj.number_of_retries = Math.round(message.numberOfRetries);
    }
    if (message.baseBackoff !== undefined) {
      obj.base_backoff = Duration.toJSON(message.baseBackoff);
    }
    if (message.maxBackoff !== undefined) {
      obj.max_backoff = Duration.toJSON(message.maxBackoff);
    }
    if (message.maxElapsedTime !== undefined) {
      obj.max_elapsed_time = Duration.toJSON(message.maxElapsedTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryConfig>, I>>(base?: I): RetryConfig {
    return RetryConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryConfig>, I>>(object: I): RetryConfig {
    const message = createBaseRetryConfig();
    message.numberOfRetries = object.numberOfRetries ?? 0;
    message.baseBackoff = (object.baseBackoff !== undefined && object.baseBackoff !== null)
      ? Duration.fromPartial(object.baseBackoff)
      : undefined;
    message.maxBackoff = (object.maxBackoff !== undefined && object.maxBackoff !== null)
      ? Duration.fromPartial(object.maxBackoff)
      : undefined;
    message.maxElapsedTime = (object.maxElapsedTime !== undefined && object.maxElapsedTime !== null)
      ? Duration.fromPartial(object.maxElapsedTime)
      : undefined;
    return message;
  },
};

function createBaseTLSConfig(): TLSConfig {
  return { serverName: "", caCertPath: "", clientCertPath: "", clientKeyPath: "", insecureSkipVerify: false };
}

export const TLSConfig: MessageFns<TLSConfig> = {
  encode(message: TLSConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverName !== "") {
      writer.uint32(10).string(message.serverName);
    }
    if (message.caCertPath !== "") {
      writer.uint32(18).string(message.caCertPath);
    }
    if (message.clientCertPath !== "") {
      writer.uint32(26).string(message.clientCertPath);
    }
    if (message.clientKeyPath !== "") {
      writer.uint32(34).string(message.clientKeyPath);
    }
    if (message.insecureSkipVerify !== false) {
      writer.uint32(40).bool(message.insecureSkipVerify);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TLSConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTLSConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.caCertPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientCertPath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientKeyPath = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.insecureSkipVerify = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TLSConfig {
    return {
      serverName: isSet(object.server_name) ? globalThis.String(object.server_name) : "",
      caCertPath: isSet(object.ca_cert_path) ? globalThis.String(object.ca_cert_path) : "",
      clientCertPath: isSet(object.client_cert_path) ? globalThis.String(object.client_cert_path) : "",
      clientKeyPath: isSet(object.client_key_path) ? globalThis.String(object.client_key_path) : "",
      insecureSkipVerify: isSet(object.insecure_skip_verify) ? globalThis.Boolean(object.insecure_skip_verify) : false,
    };
  },

  toJSON(message: TLSConfig): unknown {
    const obj: any = {};
    if (message.serverName !== "") {
      obj.server_name = message.serverName;
    }
    if (message.caCertPath !== "") {
      obj.ca_cert_path = message.caCertPath;
    }
    if (message.clientCertPath !== "") {
      obj.client_cert_path = message.clientCertPath;
    }
    if (message.clientKeyPath !== "") {
      obj.client_key_path = message.clientKeyPath;
    }
    if (message.insecureSkipVerify !== false) {
      obj.insecure_skip_verify = message.insecureSkipVerify;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TLSConfig>, I>>(base?: I): TLSConfig {
    return TLSConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TLSConfig>, I>>(object: I): TLSConfig {
    const message = createBaseTLSConfig();
    message.serverName = object.serverName ?? "";
    message.caCertPath = object.caCertPath ?? "";
    message.clientCertPath = object.clientCertPath ?? "";
    message.clientKeyPath = object.clientKeyPath ?? "";
    message.insecureSkipVerify = object.insecureSkipVerify ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
