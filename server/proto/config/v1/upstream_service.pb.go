// Copyright 2025 Author(s) of MCP Any
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.1
// source: proto/config/v1/upstream_service.proto

//go:build !protoopaque

package v1

import (
	bus "github.com/mcpany/core/proto/bus"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Defines strategies for load balancing across multiple service endpoints.
type LoadBalancingStrategy int32

const (
	// Distributes requests sequentially among the available servers.
	LoadBalancingStrategy_ROUND_ROBIN LoadBalancingStrategy = 0
	// Sends the next request to the server that has the fewest active connections.
	LoadBalancingStrategy_LEAST_CONNECTIONS LoadBalancingStrategy = 1
	// Selects a server at random.
	LoadBalancingStrategy_RANDOM LoadBalancingStrategy = 2
)

// Enum value maps for LoadBalancingStrategy.
var (
	LoadBalancingStrategy_name = map[int32]string{
		0: "ROUND_ROBIN",
		1: "LEAST_CONNECTIONS",
		2: "RANDOM",
	}
	LoadBalancingStrategy_value = map[string]int32{
		"ROUND_ROBIN":       0,
		"LEAST_CONNECTIONS": 1,
		"RANDOM":            2,
	}
)

func (x LoadBalancingStrategy) Enum() *LoadBalancingStrategy {
	p := new(LoadBalancingStrategy)
	*p = x
	return p
}

func (x LoadBalancingStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LoadBalancingStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_upstream_service_proto_enumTypes[0].Descriptor()
}

func (LoadBalancingStrategy) Type() protoreflect.EnumType {
	return &file_proto_config_v1_upstream_service_proto_enumTypes[0]
}

func (x LoadBalancingStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type CallPolicy_Action int32

const (
	CallPolicy_ALLOW        CallPolicy_Action = 0
	CallPolicy_DENY         CallPolicy_Action = 1
	CallPolicy_SAVE_CACHE   CallPolicy_Action = 2
	CallPolicy_DELETE_CACHE CallPolicy_Action = 3
)

// Enum value maps for CallPolicy_Action.
var (
	CallPolicy_Action_name = map[int32]string{
		0: "ALLOW",
		1: "DENY",
		2: "SAVE_CACHE",
		3: "DELETE_CACHE",
	}
	CallPolicy_Action_value = map[string]int32{
		"ALLOW":        0,
		"DENY":         1,
		"SAVE_CACHE":   2,
		"DELETE_CACHE": 3,
	}
)

func (x CallPolicy_Action) Enum() *CallPolicy_Action {
	p := new(CallPolicy_Action)
	*p = x
	return p
}

func (x CallPolicy_Action) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CallPolicy_Action) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_upstream_service_proto_enumTypes[1].Descriptor()
}

func (CallPolicy_Action) Type() protoreflect.EnumType {
	return &file_proto_config_v1_upstream_service_proto_enumTypes[1]
}

func (x CallPolicy_Action) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type ExportPolicy_Action int32

const (
	ExportPolicy_EXPORT_ACTION_UNSPECIFIED ExportPolicy_Action = 0
	ExportPolicy_EXPORT                    ExportPolicy_Action = 1
	ExportPolicy_UNEXPORT                  ExportPolicy_Action = 2
)

// Enum value maps for ExportPolicy_Action.
var (
	ExportPolicy_Action_name = map[int32]string{
		0: "EXPORT_ACTION_UNSPECIFIED",
		1: "EXPORT",
		2: "UNEXPORT",
	}
	ExportPolicy_Action_value = map[string]int32{
		"EXPORT_ACTION_UNSPECIFIED": 0,
		"EXPORT":                    1,
		"UNEXPORT":                  2,
	}
)

func (x ExportPolicy_Action) Enum() *ExportPolicy_Action {
	p := new(ExportPolicy_Action)
	*p = x
	return p
}

func (x ExportPolicy_Action) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExportPolicy_Action) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_upstream_service_proto_enumTypes[2].Descriptor()
}

func (ExportPolicy_Action) Type() protoreflect.EnumType {
	return &file_proto_config_v1_upstream_service_proto_enumTypes[2]
}

func (x ExportPolicy_Action) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type CommandLineUpstreamService_CommunicationProtocol int32

const (
	CommandLineUpstreamService_COMMUNICATION_PROTOCOL_UNSPECIFIED CommandLineUpstreamService_CommunicationProtocol = 0
	CommandLineUpstreamService_COMMUNICATION_PROTOCOL_JSON        CommandLineUpstreamService_CommunicationProtocol = 1
)

// Enum value maps for CommandLineUpstreamService_CommunicationProtocol.
var (
	CommandLineUpstreamService_CommunicationProtocol_name = map[int32]string{
		0: "COMMUNICATION_PROTOCOL_UNSPECIFIED",
		1: "COMMUNICATION_PROTOCOL_JSON",
	}
	CommandLineUpstreamService_CommunicationProtocol_value = map[string]int32{
		"COMMUNICATION_PROTOCOL_UNSPECIFIED": 0,
		"COMMUNICATION_PROTOCOL_JSON":        1,
	}
)

func (x CommandLineUpstreamService_CommunicationProtocol) Enum() *CommandLineUpstreamService_CommunicationProtocol {
	p := new(CommandLineUpstreamService_CommunicationProtocol)
	*p = x
	return p
}

func (x CommandLineUpstreamService_CommunicationProtocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommandLineUpstreamService_CommunicationProtocol) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_upstream_service_proto_enumTypes[3].Descriptor()
}

func (CommandLineUpstreamService_CommunicationProtocol) Type() protoreflect.EnumType {
	return &file_proto_config_v1_upstream_service_proto_enumTypes[3]
}

func (x CommandLineUpstreamService_CommunicationProtocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type RateLimitConfig_Storage int32

const (
	RateLimitConfig_STORAGE_UNSPECIFIED RateLimitConfig_Storage = 0
	RateLimitConfig_STORAGE_MEMORY      RateLimitConfig_Storage = 1
	RateLimitConfig_STORAGE_REDIS       RateLimitConfig_Storage = 2
)

// Enum value maps for RateLimitConfig_Storage.
var (
	RateLimitConfig_Storage_name = map[int32]string{
		0: "STORAGE_UNSPECIFIED",
		1: "STORAGE_MEMORY",
		2: "STORAGE_REDIS",
	}
	RateLimitConfig_Storage_value = map[string]int32{
		"STORAGE_UNSPECIFIED": 0,
		"STORAGE_MEMORY":      1,
		"STORAGE_REDIS":       2,
	}
)

func (x RateLimitConfig_Storage) Enum() *RateLimitConfig_Storage {
	p := new(RateLimitConfig_Storage)
	*p = x
	return p
}

func (x RateLimitConfig_Storage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RateLimitConfig_Storage) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_upstream_service_proto_enumTypes[4].Descriptor()
}

func (RateLimitConfig_Storage) Type() protoreflect.EnumType {
	return &file_proto_config_v1_upstream_service_proto_enumTypes[4]
}

func (x RateLimitConfig_Storage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type RateLimitConfig_KeyBy int32

const (
	RateLimitConfig_KEY_BY_UNSPECIFIED RateLimitConfig_KeyBy = 0
	RateLimitConfig_KEY_BY_GLOBAL      RateLimitConfig_KeyBy = 1
	RateLimitConfig_KEY_BY_IP          RateLimitConfig_KeyBy = 2
	RateLimitConfig_KEY_BY_USER_ID     RateLimitConfig_KeyBy = 3
	RateLimitConfig_KEY_BY_API_KEY     RateLimitConfig_KeyBy = 4
)

// Enum value maps for RateLimitConfig_KeyBy.
var (
	RateLimitConfig_KeyBy_name = map[int32]string{
		0: "KEY_BY_UNSPECIFIED",
		1: "KEY_BY_GLOBAL",
		2: "KEY_BY_IP",
		3: "KEY_BY_USER_ID",
		4: "KEY_BY_API_KEY",
	}
	RateLimitConfig_KeyBy_value = map[string]int32{
		"KEY_BY_UNSPECIFIED": 0,
		"KEY_BY_GLOBAL":      1,
		"KEY_BY_IP":          2,
		"KEY_BY_USER_ID":     3,
		"KEY_BY_API_KEY":     4,
	}
)

func (x RateLimitConfig_KeyBy) Enum() *RateLimitConfig_KeyBy {
	p := new(RateLimitConfig_KeyBy)
	*p = x
	return p
}

func (x RateLimitConfig_KeyBy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RateLimitConfig_KeyBy) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_upstream_service_proto_enumTypes[5].Descriptor()
}

func (RateLimitConfig_KeyBy) Type() protoreflect.EnumType {
	return &file_proto_config_v1_upstream_service_proto_enumTypes[5]
}

func (x RateLimitConfig_KeyBy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

type RateLimitConfig_CostMetric int32

const (
	RateLimitConfig_COST_METRIC_REQUESTS RateLimitConfig_CostMetric = 0
	RateLimitConfig_COST_METRIC_TOKENS   RateLimitConfig_CostMetric = 1
)

// Enum value maps for RateLimitConfig_CostMetric.
var (
	RateLimitConfig_CostMetric_name = map[int32]string{
		0: "COST_METRIC_REQUESTS",
		1: "COST_METRIC_TOKENS",
	}
	RateLimitConfig_CostMetric_value = map[string]int32{
		"COST_METRIC_REQUESTS": 0,
		"COST_METRIC_TOKENS":   1,
	}
)

func (x RateLimitConfig_CostMetric) Enum() *RateLimitConfig_CostMetric {
	p := new(RateLimitConfig_CostMetric)
	*p = x
	return p
}

func (x RateLimitConfig_CostMetric) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RateLimitConfig_CostMetric) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_config_v1_upstream_service_proto_enumTypes[6].Descriptor()
}

func (RateLimitConfig_CostMetric) Type() protoreflect.EnumType {
	return &file_proto_config_v1_upstream_service_proto_enumTypes[6]
}

func (x RateLimitConfig_CostMetric) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// UpstreamServiceCollection defines a collection of upstream services that can be loaded from a remote source.
type UpstreamServiceCollection struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The name of the collection.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The HTTP URL to load the collection from.
	HttpUrl *string `protobuf:"bytes,2,opt,name=http_url" json:"http_url,omitempty"`
	// The priority of the collection. Lower numbers have higher priority.
	Priority *int32 `protobuf:"varint,3,opt,name=priority" json:"priority,omitempty"`
	// The authentication to use when fetching the collection.
	Authentication *UpstreamAuthentication `protobuf:"bytes,4,opt,name=authentication" json:"authentication,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *UpstreamServiceCollection) Reset() {
	*x = UpstreamServiceCollection{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamServiceCollection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamServiceCollection) ProtoMessage() {}

func (x *UpstreamServiceCollection) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamServiceCollection) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *UpstreamServiceCollection) GetHttpUrl() string {
	if x != nil && x.HttpUrl != nil {
		return *x.HttpUrl
	}
	return ""
}

func (x *UpstreamServiceCollection) GetPriority() int32 {
	if x != nil && x.Priority != nil {
		return *x.Priority
	}
	return 0
}

func (x *UpstreamServiceCollection) GetAuthentication() *UpstreamAuthentication {
	if x != nil {
		return x.Authentication
	}
	return nil
}

func (x *UpstreamServiceCollection) SetName(v string) {
	x.Name = &v
}

func (x *UpstreamServiceCollection) SetHttpUrl(v string) {
	x.HttpUrl = &v
}

func (x *UpstreamServiceCollection) SetPriority(v int32) {
	x.Priority = &v
}

func (x *UpstreamServiceCollection) SetAuthentication(v *UpstreamAuthentication) {
	x.Authentication = v
}

func (x *UpstreamServiceCollection) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *UpstreamServiceCollection) HasHttpUrl() bool {
	if x == nil {
		return false
	}
	return x.HttpUrl != nil
}

func (x *UpstreamServiceCollection) HasPriority() bool {
	if x == nil {
		return false
	}
	return x.Priority != nil
}

func (x *UpstreamServiceCollection) HasAuthentication() bool {
	if x == nil {
		return false
	}
	return x.Authentication != nil
}

func (x *UpstreamServiceCollection) ClearName() {
	x.Name = nil
}

func (x *UpstreamServiceCollection) ClearHttpUrl() {
	x.HttpUrl = nil
}

func (x *UpstreamServiceCollection) ClearPriority() {
	x.Priority = nil
}

func (x *UpstreamServiceCollection) ClearAuthentication() {
	x.Authentication = nil
}

type UpstreamServiceCollection_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The name of the collection.
	Name *string
	// The HTTP URL to load the collection from.
	HttpUrl *string
	// The priority of the collection. Lower numbers have higher priority.
	Priority *int32
	// The authentication to use when fetching the collection.
	Authentication *UpstreamAuthentication
}

func (b0 UpstreamServiceCollection_builder) Build() *UpstreamServiceCollection {
	m0 := &UpstreamServiceCollection{}
	b, x := &b0, m0
	_, _ = b, x
	x.Name = b.Name
	x.HttpUrl = b.HttpUrl
	x.Priority = b.Priority
	x.Authentication = b.Authentication
	return m0
}

// UpstreamServiceConfig is the top-level configuration for a single upstream service
// that mcpany will proxy. It defines the service's identity, how to connect to it,
// and policies like authentication, caching, rate limiting, and load balancing.
type UpstreamServiceConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The full SHA256 hash of the service name, used as a unique identifier.
	// This ensures that for the same service name, the ID is always the same.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The original user-provided name for the upstream service.
	// This name is used for identification, logging, and metrics.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// A sanitized version of the service name, conforming to identifier rules.
	// @inject_tag: yaml:"-"
	//
	// This field is managed internally and should not be set by the user.
	SanitizedName *string `protobuf:"bytes,18,opt,name=sanitized_name" json:"sanitized_name,omitempty"`
	// Configuration for the pool of connections to the upstream service.
	ConnectionPool *ConnectionPoolConfig `protobuf:"bytes,3,opt,name=connection_pool" json:"connection_pool,omitempty"`
	// Authentication configuration for mcpany to use when connecting to the upstream service.
	UpstreamAuthentication *UpstreamAuthentication `protobuf:"bytes,4,opt,name=upstream_authentication" json:"upstream_authentication,omitempty"`
	// Caching configuration to improve performance and reduce load on the upstream.
	Cache *CacheConfig `protobuf:"bytes,5,opt,name=cache" json:"cache,omitempty"`
	// Rate limiting to protect the upstream service from being overwhelmed.
	RateLimit *RateLimitConfig `protobuf:"bytes,6,opt,name=rate_limit" json:"rate_limit,omitempty"`
	// Strategy for distributing requests among multiple instances of the service.
	LoadBalancingStrategy *LoadBalancingStrategy `protobuf:"varint,7,opt,name=load_balancing_strategy,enum=mcpany.config.v1.LoadBalancingStrategy" json:"load_balancing_strategy,omitempty"`
	// Advanced resiliency features to handle failures gracefully.
	Resilience *ResilienceConfig `protobuf:"bytes,8,opt,name=resilience" json:"resilience,omitempty"`
	// The specific configuration for the type of upstream service.
	//
	// Types that are valid to be assigned to ServiceConfig:
	//
	//	*UpstreamServiceConfig_McpService
	//	*UpstreamServiceConfig_HttpService
	//	*UpstreamServiceConfig_GrpcService
	//	*UpstreamServiceConfig_OpenapiService
	//	*UpstreamServiceConfig_CommandLineService
	//	*UpstreamServiceConfig_WebsocketService
	//	*UpstreamServiceConfig_WebrtcService
	//	*UpstreamServiceConfig_GraphqlService
	//	*UpstreamServiceConfig_SqlService
	//	*UpstreamServiceConfig_FilesystemService
	ServiceConfig isUpstreamServiceConfig_ServiceConfig `protobuf_oneof:"service_config"`
	// The version of the upstream service, if known (e.g., "v1.2.3").
	Version *string `protobuf:"bytes,14,opt,name=version" json:"version,omitempty"`
	// Authentication configuration for securing access to the MCP Any service (incoming requests).
	Authentication *AuthenticationConfig `protobuf:"bytes,15,opt,name=authentication" json:"authentication,omitempty"`
	// If true, this upstream service is disabled.
	Disable *bool `protobuf:"varint,19,opt,name=disable" json:"disable,omitempty"`
	// The priority of the service. Lower numbers have higher priority.
	Priority *int32 `protobuf:"varint,20,opt,name=priority" json:"priority,omitempty"`
	// Policy to control which calls can be made.
	CallPolicies []*CallPolicy `protobuf:"bytes,22,rep,name=call_policies" json:"call_policies,omitempty"`
	// List of hooks to execute before the call.
	PreCallHooks []*CallHook `protobuf:"bytes,23,rep,name=pre_call_hooks" json:"pre_call_hooks,omitempty"`
	// List of hooks to execute after the call.
	PostCallHooks []*CallHook `protobuf:"bytes,24,rep,name=post_call_hooks" json:"post_call_hooks,omitempty"`
	// A list of profiles this service belongs to.
	Profiles []*Profile `protobuf:"bytes,25,rep,name=profiles" json:"profiles,omitempty"`
	// The prompts provided by this upstream service.
	Prompts []*PromptDefinition `protobuf:"bytes,26,rep,name=prompts" json:"prompts,omitempty"`
	// Policies to control what is exported to the client.
	ToolExportPolicy     *ExportPolicy `protobuf:"bytes,27,opt,name=tool_export_policy" json:"tool_export_policy,omitempty"`
	PromptExportPolicy   *ExportPolicy `protobuf:"bytes,28,opt,name=prompt_export_policy" json:"prompt_export_policy,omitempty"`
	ResourceExportPolicy *ExportPolicy `protobuf:"bytes,29,opt,name=resource_export_policy" json:"resource_export_policy,omitempty"`
	// If true, automatically convert all API calls to tools.
	AutoDiscoverTool *bool `protobuf:"varint,30,opt,name=auto_discover_tool" json:"auto_discover_tool,omitempty"`
	// Rate limits per profile. Key is the profile ID.
	// These limits override the service-level rate_limit if the user belongs to the profile.
	ProfileLimits map[string]*RateLimitConfig `protobuf:"bytes,33,rep,name=profile_limits" json:"profile_limits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpstreamServiceConfig) Reset() {
	*x = UpstreamServiceConfig{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpstreamServiceConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpstreamServiceConfig) ProtoMessage() {}

func (x *UpstreamServiceConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UpstreamServiceConfig) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *UpstreamServiceConfig) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *UpstreamServiceConfig) GetSanitizedName() string {
	if x != nil && x.SanitizedName != nil {
		return *x.SanitizedName
	}
	return ""
}

func (x *UpstreamServiceConfig) GetConnectionPool() *ConnectionPoolConfig {
	if x != nil {
		return x.ConnectionPool
	}
	return nil
}

func (x *UpstreamServiceConfig) GetUpstreamAuthentication() *UpstreamAuthentication {
	if x != nil {
		return x.UpstreamAuthentication
	}
	return nil
}

func (x *UpstreamServiceConfig) GetCache() *CacheConfig {
	if x != nil {
		return x.Cache
	}
	return nil
}

func (x *UpstreamServiceConfig) GetRateLimit() *RateLimitConfig {
	if x != nil {
		return x.RateLimit
	}
	return nil
}

func (x *UpstreamServiceConfig) GetLoadBalancingStrategy() LoadBalancingStrategy {
	if x != nil && x.LoadBalancingStrategy != nil {
		return *x.LoadBalancingStrategy
	}
	return LoadBalancingStrategy_ROUND_ROBIN
}

func (x *UpstreamServiceConfig) GetResilience() *ResilienceConfig {
	if x != nil {
		return x.Resilience
	}
	return nil
}

func (x *UpstreamServiceConfig) GetServiceConfig() isUpstreamServiceConfig_ServiceConfig {
	if x != nil {
		return x.ServiceConfig
	}
	return nil
}

func (x *UpstreamServiceConfig) GetMcpService() *McpUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_McpService); ok {
			return x.McpService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetHttpService() *HttpUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_HttpService); ok {
			return x.HttpService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetGrpcService() *GrpcUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_GrpcService); ok {
			return x.GrpcService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetOpenapiService() *OpenapiUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_OpenapiService); ok {
			return x.OpenapiService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetCommandLineService() *CommandLineUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_CommandLineService); ok {
			return x.CommandLineService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetWebsocketService() *WebsocketUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_WebsocketService); ok {
			return x.WebsocketService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetWebrtcService() *WebrtcUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_WebrtcService); ok {
			return x.WebrtcService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetGraphqlService() *GraphQLUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_GraphqlService); ok {
			return x.GraphqlService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetSqlService() *SqlUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_SqlService); ok {
			return x.SqlService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetFilesystemService() *FilesystemUpstreamService {
	if x != nil {
		if x, ok := x.ServiceConfig.(*UpstreamServiceConfig_FilesystemService); ok {
			return x.FilesystemService
		}
	}
	return nil
}

func (x *UpstreamServiceConfig) GetVersion() string {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return ""
}

func (x *UpstreamServiceConfig) GetAuthentication() *AuthenticationConfig {
	if x != nil {
		return x.Authentication
	}
	return nil
}

func (x *UpstreamServiceConfig) GetDisable() bool {
	if x != nil && x.Disable != nil {
		return *x.Disable
	}
	return false
}

func (x *UpstreamServiceConfig) GetPriority() int32 {
	if x != nil && x.Priority != nil {
		return *x.Priority
	}
	return 0
}

func (x *UpstreamServiceConfig) GetCallPolicies() []*CallPolicy {
	if x != nil {
		return x.CallPolicies
	}
	return nil
}

func (x *UpstreamServiceConfig) GetPreCallHooks() []*CallHook {
	if x != nil {
		return x.PreCallHooks
	}
	return nil
}

func (x *UpstreamServiceConfig) GetPostCallHooks() []*CallHook {
	if x != nil {
		return x.PostCallHooks
	}
	return nil
}

func (x *UpstreamServiceConfig) GetProfiles() []*Profile {
	if x != nil {
		return x.Profiles
	}
	return nil
}

func (x *UpstreamServiceConfig) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *UpstreamServiceConfig) GetToolExportPolicy() *ExportPolicy {
	if x != nil {
		return x.ToolExportPolicy
	}
	return nil
}

func (x *UpstreamServiceConfig) GetPromptExportPolicy() *ExportPolicy {
	if x != nil {
		return x.PromptExportPolicy
	}
	return nil
}

func (x *UpstreamServiceConfig) GetResourceExportPolicy() *ExportPolicy {
	if x != nil {
		return x.ResourceExportPolicy
	}
	return nil
}

func (x *UpstreamServiceConfig) GetAutoDiscoverTool() bool {
	if x != nil && x.AutoDiscoverTool != nil {
		return *x.AutoDiscoverTool
	}
	return false
}

func (x *UpstreamServiceConfig) GetProfileLimits() map[string]*RateLimitConfig {
	if x != nil {
		return x.ProfileLimits
	}
	return nil
}

func (x *UpstreamServiceConfig) SetId(v string) {
	x.Id = &v
}

func (x *UpstreamServiceConfig) SetName(v string) {
	x.Name = &v
}

func (x *UpstreamServiceConfig) SetSanitizedName(v string) {
	x.SanitizedName = &v
}

func (x *UpstreamServiceConfig) SetConnectionPool(v *ConnectionPoolConfig) {
	x.ConnectionPool = v
}

func (x *UpstreamServiceConfig) SetUpstreamAuthentication(v *UpstreamAuthentication) {
	x.UpstreamAuthentication = v
}

func (x *UpstreamServiceConfig) SetCache(v *CacheConfig) {
	x.Cache = v
}

func (x *UpstreamServiceConfig) SetRateLimit(v *RateLimitConfig) {
	x.RateLimit = v
}

func (x *UpstreamServiceConfig) SetLoadBalancingStrategy(v LoadBalancingStrategy) {
	x.LoadBalancingStrategy = &v
}

func (x *UpstreamServiceConfig) SetResilience(v *ResilienceConfig) {
	x.Resilience = v
}

func (x *UpstreamServiceConfig) SetMcpService(v *McpUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_McpService{v}
}

func (x *UpstreamServiceConfig) SetHttpService(v *HttpUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_HttpService{v}
}

func (x *UpstreamServiceConfig) SetGrpcService(v *GrpcUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_GrpcService{v}
}

func (x *UpstreamServiceConfig) SetOpenapiService(v *OpenapiUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_OpenapiService{v}
}

func (x *UpstreamServiceConfig) SetCommandLineService(v *CommandLineUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_CommandLineService{v}
}

func (x *UpstreamServiceConfig) SetWebsocketService(v *WebsocketUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_WebsocketService{v}
}

func (x *UpstreamServiceConfig) SetWebrtcService(v *WebrtcUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_WebrtcService{v}
}

func (x *UpstreamServiceConfig) SetGraphqlService(v *GraphQLUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_GraphqlService{v}
}

func (x *UpstreamServiceConfig) SetSqlService(v *SqlUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_SqlService{v}
}

func (x *UpstreamServiceConfig) SetFilesystemService(v *FilesystemUpstreamService) {
	if v == nil {
		x.ServiceConfig = nil
		return
	}
	x.ServiceConfig = &UpstreamServiceConfig_FilesystemService{v}
}

func (x *UpstreamServiceConfig) SetVersion(v string) {
	x.Version = &v
}

func (x *UpstreamServiceConfig) SetAuthentication(v *AuthenticationConfig) {
	x.Authentication = v
}

func (x *UpstreamServiceConfig) SetDisable(v bool) {
	x.Disable = &v
}

func (x *UpstreamServiceConfig) SetPriority(v int32) {
	x.Priority = &v
}

func (x *UpstreamServiceConfig) SetCallPolicies(v []*CallPolicy) {
	x.CallPolicies = v
}

func (x *UpstreamServiceConfig) SetPreCallHooks(v []*CallHook) {
	x.PreCallHooks = v
}

func (x *UpstreamServiceConfig) SetPostCallHooks(v []*CallHook) {
	x.PostCallHooks = v
}

func (x *UpstreamServiceConfig) SetProfiles(v []*Profile) {
	x.Profiles = v
}

func (x *UpstreamServiceConfig) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *UpstreamServiceConfig) SetToolExportPolicy(v *ExportPolicy) {
	x.ToolExportPolicy = v
}

func (x *UpstreamServiceConfig) SetPromptExportPolicy(v *ExportPolicy) {
	x.PromptExportPolicy = v
}

func (x *UpstreamServiceConfig) SetResourceExportPolicy(v *ExportPolicy) {
	x.ResourceExportPolicy = v
}

func (x *UpstreamServiceConfig) SetAutoDiscoverTool(v bool) {
	x.AutoDiscoverTool = &v
}

func (x *UpstreamServiceConfig) SetProfileLimits(v map[string]*RateLimitConfig) {
	x.ProfileLimits = v
}

func (x *UpstreamServiceConfig) HasId() bool {
	if x == nil {
		return false
	}
	return x.Id != nil
}

func (x *UpstreamServiceConfig) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *UpstreamServiceConfig) HasSanitizedName() bool {
	if x == nil {
		return false
	}
	return x.SanitizedName != nil
}

func (x *UpstreamServiceConfig) HasConnectionPool() bool {
	if x == nil {
		return false
	}
	return x.ConnectionPool != nil
}

func (x *UpstreamServiceConfig) HasUpstreamAuthentication() bool {
	if x == nil {
		return false
	}
	return x.UpstreamAuthentication != nil
}

func (x *UpstreamServiceConfig) HasCache() bool {
	if x == nil {
		return false
	}
	return x.Cache != nil
}

func (x *UpstreamServiceConfig) HasRateLimit() bool {
	if x == nil {
		return false
	}
	return x.RateLimit != nil
}

func (x *UpstreamServiceConfig) HasLoadBalancingStrategy() bool {
	if x == nil {
		return false
	}
	return x.LoadBalancingStrategy != nil
}

func (x *UpstreamServiceConfig) HasResilience() bool {
	if x == nil {
		return false
	}
	return x.Resilience != nil
}

func (x *UpstreamServiceConfig) HasServiceConfig() bool {
	if x == nil {
		return false
	}
	return x.ServiceConfig != nil
}

func (x *UpstreamServiceConfig) HasMcpService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_McpService)
	return ok
}

func (x *UpstreamServiceConfig) HasHttpService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_HttpService)
	return ok
}

func (x *UpstreamServiceConfig) HasGrpcService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_GrpcService)
	return ok
}

func (x *UpstreamServiceConfig) HasOpenapiService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_OpenapiService)
	return ok
}

func (x *UpstreamServiceConfig) HasCommandLineService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_CommandLineService)
	return ok
}

func (x *UpstreamServiceConfig) HasWebsocketService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_WebsocketService)
	return ok
}

func (x *UpstreamServiceConfig) HasWebrtcService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_WebrtcService)
	return ok
}

func (x *UpstreamServiceConfig) HasGraphqlService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_GraphqlService)
	return ok
}

func (x *UpstreamServiceConfig) HasSqlService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_SqlService)
	return ok
}

func (x *UpstreamServiceConfig) HasFilesystemService() bool {
	if x == nil {
		return false
	}
	_, ok := x.ServiceConfig.(*UpstreamServiceConfig_FilesystemService)
	return ok
}

func (x *UpstreamServiceConfig) HasVersion() bool {
	if x == nil {
		return false
	}
	return x.Version != nil
}

func (x *UpstreamServiceConfig) HasAuthentication() bool {
	if x == nil {
		return false
	}
	return x.Authentication != nil
}

func (x *UpstreamServiceConfig) HasDisable() bool {
	if x == nil {
		return false
	}
	return x.Disable != nil
}

func (x *UpstreamServiceConfig) HasPriority() bool {
	if x == nil {
		return false
	}
	return x.Priority != nil
}

func (x *UpstreamServiceConfig) HasToolExportPolicy() bool {
	if x == nil {
		return false
	}
	return x.ToolExportPolicy != nil
}

func (x *UpstreamServiceConfig) HasPromptExportPolicy() bool {
	if x == nil {
		return false
	}
	return x.PromptExportPolicy != nil
}

func (x *UpstreamServiceConfig) HasResourceExportPolicy() bool {
	if x == nil {
		return false
	}
	return x.ResourceExportPolicy != nil
}

func (x *UpstreamServiceConfig) HasAutoDiscoverTool() bool {
	if x == nil {
		return false
	}
	return x.AutoDiscoverTool != nil
}

func (x *UpstreamServiceConfig) ClearId() {
	x.Id = nil
}

func (x *UpstreamServiceConfig) ClearName() {
	x.Name = nil
}

func (x *UpstreamServiceConfig) ClearSanitizedName() {
	x.SanitizedName = nil
}

func (x *UpstreamServiceConfig) ClearConnectionPool() {
	x.ConnectionPool = nil
}

func (x *UpstreamServiceConfig) ClearUpstreamAuthentication() {
	x.UpstreamAuthentication = nil
}

func (x *UpstreamServiceConfig) ClearCache() {
	x.Cache = nil
}

func (x *UpstreamServiceConfig) ClearRateLimit() {
	x.RateLimit = nil
}

func (x *UpstreamServiceConfig) ClearLoadBalancingStrategy() {
	x.LoadBalancingStrategy = nil
}

func (x *UpstreamServiceConfig) ClearResilience() {
	x.Resilience = nil
}

func (x *UpstreamServiceConfig) ClearServiceConfig() {
	x.ServiceConfig = nil
}

func (x *UpstreamServiceConfig) ClearMcpService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_McpService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearHttpService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_HttpService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearGrpcService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_GrpcService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearOpenapiService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_OpenapiService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearCommandLineService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_CommandLineService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearWebsocketService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_WebsocketService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearWebrtcService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_WebrtcService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearGraphqlService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_GraphqlService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearSqlService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_SqlService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearFilesystemService() {
	if _, ok := x.ServiceConfig.(*UpstreamServiceConfig_FilesystemService); ok {
		x.ServiceConfig = nil
	}
}

func (x *UpstreamServiceConfig) ClearVersion() {
	x.Version = nil
}

func (x *UpstreamServiceConfig) ClearAuthentication() {
	x.Authentication = nil
}

func (x *UpstreamServiceConfig) ClearDisable() {
	x.Disable = nil
}

func (x *UpstreamServiceConfig) ClearPriority() {
	x.Priority = nil
}

func (x *UpstreamServiceConfig) ClearToolExportPolicy() {
	x.ToolExportPolicy = nil
}

func (x *UpstreamServiceConfig) ClearPromptExportPolicy() {
	x.PromptExportPolicy = nil
}

func (x *UpstreamServiceConfig) ClearResourceExportPolicy() {
	x.ResourceExportPolicy = nil
}

func (x *UpstreamServiceConfig) ClearAutoDiscoverTool() {
	x.AutoDiscoverTool = nil
}

const UpstreamServiceConfig_ServiceConfig_not_set_case case_UpstreamServiceConfig_ServiceConfig = 0
const UpstreamServiceConfig_McpService_case case_UpstreamServiceConfig_ServiceConfig = 9
const UpstreamServiceConfig_HttpService_case case_UpstreamServiceConfig_ServiceConfig = 10
const UpstreamServiceConfig_GrpcService_case case_UpstreamServiceConfig_ServiceConfig = 11
const UpstreamServiceConfig_OpenapiService_case case_UpstreamServiceConfig_ServiceConfig = 12
const UpstreamServiceConfig_CommandLineService_case case_UpstreamServiceConfig_ServiceConfig = 13
const UpstreamServiceConfig_WebsocketService_case case_UpstreamServiceConfig_ServiceConfig = 16
const UpstreamServiceConfig_WebrtcService_case case_UpstreamServiceConfig_ServiceConfig = 17
const UpstreamServiceConfig_GraphqlService_case case_UpstreamServiceConfig_ServiceConfig = 21
const UpstreamServiceConfig_SqlService_case case_UpstreamServiceConfig_ServiceConfig = 31
const UpstreamServiceConfig_FilesystemService_case case_UpstreamServiceConfig_ServiceConfig = 32

func (x *UpstreamServiceConfig) WhichServiceConfig() case_UpstreamServiceConfig_ServiceConfig {
	if x == nil {
		return UpstreamServiceConfig_ServiceConfig_not_set_case
	}
	switch x.ServiceConfig.(type) {
	case *UpstreamServiceConfig_McpService:
		return UpstreamServiceConfig_McpService_case
	case *UpstreamServiceConfig_HttpService:
		return UpstreamServiceConfig_HttpService_case
	case *UpstreamServiceConfig_GrpcService:
		return UpstreamServiceConfig_GrpcService_case
	case *UpstreamServiceConfig_OpenapiService:
		return UpstreamServiceConfig_OpenapiService_case
	case *UpstreamServiceConfig_CommandLineService:
		return UpstreamServiceConfig_CommandLineService_case
	case *UpstreamServiceConfig_WebsocketService:
		return UpstreamServiceConfig_WebsocketService_case
	case *UpstreamServiceConfig_WebrtcService:
		return UpstreamServiceConfig_WebrtcService_case
	case *UpstreamServiceConfig_GraphqlService:
		return UpstreamServiceConfig_GraphqlService_case
	case *UpstreamServiceConfig_SqlService:
		return UpstreamServiceConfig_SqlService_case
	case *UpstreamServiceConfig_FilesystemService:
		return UpstreamServiceConfig_FilesystemService_case
	default:
		return UpstreamServiceConfig_ServiceConfig_not_set_case
	}
}

type UpstreamServiceConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The full SHA256 hash of the service name, used as a unique identifier.
	// This ensures that for the same service name, the ID is always the same.
	Id *string
	// The original user-provided name for the upstream service.
	// This name is used for identification, logging, and metrics.
	Name *string
	// A sanitized version of the service name, conforming to identifier rules.
	// @inject_tag: yaml:"-"
	//
	// This field is managed internally and should not be set by the user.
	SanitizedName *string
	// Configuration for the pool of connections to the upstream service.
	ConnectionPool *ConnectionPoolConfig
	// Authentication configuration for mcpany to use when connecting to the upstream service.
	UpstreamAuthentication *UpstreamAuthentication
	// Caching configuration to improve performance and reduce load on the upstream.
	Cache *CacheConfig
	// Rate limiting to protect the upstream service from being overwhelmed.
	RateLimit *RateLimitConfig
	// Strategy for distributing requests among multiple instances of the service.
	LoadBalancingStrategy *LoadBalancingStrategy
	// Advanced resiliency features to handle failures gracefully.
	Resilience *ResilienceConfig
	// The specific configuration for the type of upstream service.

	// Fields of oneof ServiceConfig:
	McpService         *McpUpstreamService
	HttpService        *HttpUpstreamService
	GrpcService        *GrpcUpstreamService
	OpenapiService     *OpenapiUpstreamService
	CommandLineService *CommandLineUpstreamService
	WebsocketService   *WebsocketUpstreamService
	WebrtcService      *WebrtcUpstreamService
	GraphqlService     *GraphQLUpstreamService
	SqlService         *SqlUpstreamService
	FilesystemService  *FilesystemUpstreamService
	// -- end of ServiceConfig
	// The version of the upstream service, if known (e.g., "v1.2.3").
	Version *string
	// Authentication configuration for securing access to the MCP Any service (incoming requests).
	Authentication *AuthenticationConfig
	// If true, this upstream service is disabled.
	Disable *bool
	// The priority of the service. Lower numbers have higher priority.
	Priority *int32
	// Policy to control which calls can be made.
	CallPolicies []*CallPolicy
	// List of hooks to execute before the call.
	PreCallHooks []*CallHook
	// List of hooks to execute after the call.
	PostCallHooks []*CallHook
	// A list of profiles this service belongs to.
	Profiles []*Profile
	// The prompts provided by this upstream service.
	Prompts []*PromptDefinition
	// Policies to control what is exported to the client.
	ToolExportPolicy     *ExportPolicy
	PromptExportPolicy   *ExportPolicy
	ResourceExportPolicy *ExportPolicy
	// If true, automatically convert all API calls to tools.
	AutoDiscoverTool *bool
	// Rate limits per profile. Key is the profile ID.
	// These limits override the service-level rate_limit if the user belongs to the profile.
	ProfileLimits map[string]*RateLimitConfig
}

func (b0 UpstreamServiceConfig_builder) Build() *UpstreamServiceConfig {
	m0 := &UpstreamServiceConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.Id = b.Id
	x.Name = b.Name
	x.SanitizedName = b.SanitizedName
	x.ConnectionPool = b.ConnectionPool
	x.UpstreamAuthentication = b.UpstreamAuthentication
	x.Cache = b.Cache
	x.RateLimit = b.RateLimit
	x.LoadBalancingStrategy = b.LoadBalancingStrategy
	x.Resilience = b.Resilience
	if b.McpService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_McpService{b.McpService}
	}
	if b.HttpService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_HttpService{b.HttpService}
	}
	if b.GrpcService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_GrpcService{b.GrpcService}
	}
	if b.OpenapiService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_OpenapiService{b.OpenapiService}
	}
	if b.CommandLineService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_CommandLineService{b.CommandLineService}
	}
	if b.WebsocketService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_WebsocketService{b.WebsocketService}
	}
	if b.WebrtcService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_WebrtcService{b.WebrtcService}
	}
	if b.GraphqlService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_GraphqlService{b.GraphqlService}
	}
	if b.SqlService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_SqlService{b.SqlService}
	}
	if b.FilesystemService != nil {
		x.ServiceConfig = &UpstreamServiceConfig_FilesystemService{b.FilesystemService}
	}
	x.Version = b.Version
	x.Authentication = b.Authentication
	x.Disable = b.Disable
	x.Priority = b.Priority
	x.CallPolicies = b.CallPolicies
	x.PreCallHooks = b.PreCallHooks
	x.PostCallHooks = b.PostCallHooks
	x.Profiles = b.Profiles
	x.Prompts = b.Prompts
	x.ToolExportPolicy = b.ToolExportPolicy
	x.PromptExportPolicy = b.PromptExportPolicy
	x.ResourceExportPolicy = b.ResourceExportPolicy
	x.AutoDiscoverTool = b.AutoDiscoverTool
	x.ProfileLimits = b.ProfileLimits
	return m0
}

type case_UpstreamServiceConfig_ServiceConfig protoreflect.FieldNumber

func (x case_UpstreamServiceConfig_ServiceConfig) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[1].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isUpstreamServiceConfig_ServiceConfig interface {
	isUpstreamServiceConfig_ServiceConfig()
}

type UpstreamServiceConfig_McpService struct {
	McpService *McpUpstreamService `protobuf:"bytes,9,opt,name=mcp_service,oneof"`
}

type UpstreamServiceConfig_HttpService struct {
	HttpService *HttpUpstreamService `protobuf:"bytes,10,opt,name=http_service,oneof"`
}

type UpstreamServiceConfig_GrpcService struct {
	GrpcService *GrpcUpstreamService `protobuf:"bytes,11,opt,name=grpc_service,oneof"`
}

type UpstreamServiceConfig_OpenapiService struct {
	OpenapiService *OpenapiUpstreamService `protobuf:"bytes,12,opt,name=openapi_service,oneof"`
}

type UpstreamServiceConfig_CommandLineService struct {
	CommandLineService *CommandLineUpstreamService `protobuf:"bytes,13,opt,name=command_line_service,oneof"`
}

type UpstreamServiceConfig_WebsocketService struct {
	WebsocketService *WebsocketUpstreamService `protobuf:"bytes,16,opt,name=websocket_service,oneof"`
}

type UpstreamServiceConfig_WebrtcService struct {
	WebrtcService *WebrtcUpstreamService `protobuf:"bytes,17,opt,name=webrtc_service,oneof"`
}

type UpstreamServiceConfig_GraphqlService struct {
	GraphqlService *GraphQLUpstreamService `protobuf:"bytes,21,opt,name=graphql_service,oneof"`
}

type UpstreamServiceConfig_SqlService struct {
	SqlService *SqlUpstreamService `protobuf:"bytes,31,opt,name=sql_service,oneof"`
}

type UpstreamServiceConfig_FilesystemService struct {
	FilesystemService *FilesystemUpstreamService `protobuf:"bytes,32,opt,name=filesystem_service,oneof"`
}

func (*UpstreamServiceConfig_McpService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_HttpService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_GrpcService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_OpenapiService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_CommandLineService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_WebsocketService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_WebrtcService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_GraphqlService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_SqlService) isUpstreamServiceConfig_ServiceConfig() {}

func (*UpstreamServiceConfig_FilesystemService) isUpstreamServiceConfig_ServiceConfig() {}

type CallPolicy struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Default action if no rules match.
	DefaultAction *CallPolicy_Action `protobuf:"varint,1,opt,name=default_action,json=defaultAction,enum=mcpany.config.v1.CallPolicy_Action" json:"default_action,omitempty"`
	// List of rules to apply. First match wins.
	Rules         []*CallPolicyRule `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallPolicy) Reset() {
	*x = CallPolicy{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallPolicy) ProtoMessage() {}

func (x *CallPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CallPolicy) GetDefaultAction() CallPolicy_Action {
	if x != nil && x.DefaultAction != nil {
		return *x.DefaultAction
	}
	return CallPolicy_ALLOW
}

func (x *CallPolicy) GetRules() []*CallPolicyRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *CallPolicy) SetDefaultAction(v CallPolicy_Action) {
	x.DefaultAction = &v
}

func (x *CallPolicy) SetRules(v []*CallPolicyRule) {
	x.Rules = v
}

func (x *CallPolicy) HasDefaultAction() bool {
	if x == nil {
		return false
	}
	return x.DefaultAction != nil
}

func (x *CallPolicy) ClearDefaultAction() {
	x.DefaultAction = nil
}

type CallPolicy_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Default action if no rules match.
	DefaultAction *CallPolicy_Action
	// List of rules to apply. First match wins.
	Rules []*CallPolicyRule
}

func (b0 CallPolicy_builder) Build() *CallPolicy {
	m0 := &CallPolicy{}
	b, x := &b0, m0
	_, _ = b, x
	x.DefaultAction = b.DefaultAction
	x.Rules = b.Rules
	return m0
}

type CallPolicyRule struct {
	state  protoimpl.MessageState `protogen:"hybrid.v1"`
	Action *CallPolicy_Action     `protobuf:"varint,1,opt,name=action,enum=mcpany.config.v1.CallPolicy_Action" json:"action,omitempty"`
	// Regex to match the call name. Empty means match all.
	NameRegex *string `protobuf:"bytes,2,opt,name=name_regex" json:"name_regex,omitempty"`
	// Regex to match request arguments (JSON stringified). Empty means match all.
	// This is a simple regex match on the JSON representation of arguments.
	ArgumentRegex *string `protobuf:"bytes,3,opt,name=argument_regex,json=argumentRegex" json:"argument_regex,omitempty"`
	// Regex to match endpoint path or URL.
	UrlRegex *string `protobuf:"bytes,4,opt,name=url_regex" json:"url_regex,omitempty"`
	// Regex to match call ID. Empty means match all.
	CallIdRegex   *string `protobuf:"bytes,5,opt,name=call_id_regex" json:"call_id_regex,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallPolicyRule) Reset() {
	*x = CallPolicyRule{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallPolicyRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallPolicyRule) ProtoMessage() {}

func (x *CallPolicyRule) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CallPolicyRule) GetAction() CallPolicy_Action {
	if x != nil && x.Action != nil {
		return *x.Action
	}
	return CallPolicy_ALLOW
}

func (x *CallPolicyRule) GetNameRegex() string {
	if x != nil && x.NameRegex != nil {
		return *x.NameRegex
	}
	return ""
}

func (x *CallPolicyRule) GetArgumentRegex() string {
	if x != nil && x.ArgumentRegex != nil {
		return *x.ArgumentRegex
	}
	return ""
}

func (x *CallPolicyRule) GetUrlRegex() string {
	if x != nil && x.UrlRegex != nil {
		return *x.UrlRegex
	}
	return ""
}

func (x *CallPolicyRule) GetCallIdRegex() string {
	if x != nil && x.CallIdRegex != nil {
		return *x.CallIdRegex
	}
	return ""
}

func (x *CallPolicyRule) SetAction(v CallPolicy_Action) {
	x.Action = &v
}

func (x *CallPolicyRule) SetNameRegex(v string) {
	x.NameRegex = &v
}

func (x *CallPolicyRule) SetArgumentRegex(v string) {
	x.ArgumentRegex = &v
}

func (x *CallPolicyRule) SetUrlRegex(v string) {
	x.UrlRegex = &v
}

func (x *CallPolicyRule) SetCallIdRegex(v string) {
	x.CallIdRegex = &v
}

func (x *CallPolicyRule) HasAction() bool {
	if x == nil {
		return false
	}
	return x.Action != nil
}

func (x *CallPolicyRule) HasNameRegex() bool {
	if x == nil {
		return false
	}
	return x.NameRegex != nil
}

func (x *CallPolicyRule) HasArgumentRegex() bool {
	if x == nil {
		return false
	}
	return x.ArgumentRegex != nil
}

func (x *CallPolicyRule) HasUrlRegex() bool {
	if x == nil {
		return false
	}
	return x.UrlRegex != nil
}

func (x *CallPolicyRule) HasCallIdRegex() bool {
	if x == nil {
		return false
	}
	return x.CallIdRegex != nil
}

func (x *CallPolicyRule) ClearAction() {
	x.Action = nil
}

func (x *CallPolicyRule) ClearNameRegex() {
	x.NameRegex = nil
}

func (x *CallPolicyRule) ClearArgumentRegex() {
	x.ArgumentRegex = nil
}

func (x *CallPolicyRule) ClearUrlRegex() {
	x.UrlRegex = nil
}

func (x *CallPolicyRule) ClearCallIdRegex() {
	x.CallIdRegex = nil
}

type CallPolicyRule_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Action *CallPolicy_Action
	// Regex to match the call name. Empty means match all.
	NameRegex *string
	// Regex to match request arguments (JSON stringified). Empty means match all.
	// This is a simple regex match on the JSON representation of arguments.
	ArgumentRegex *string
	// Regex to match endpoint path or URL.
	UrlRegex *string
	// Regex to match call ID. Empty means match all.
	CallIdRegex *string
}

func (b0 CallPolicyRule_builder) Build() *CallPolicyRule {
	m0 := &CallPolicyRule{}
	b, x := &b0, m0
	_, _ = b, x
	x.Action = b.Action
	x.NameRegex = b.NameRegex
	x.ArgumentRegex = b.ArgumentRegex
	x.UrlRegex = b.UrlRegex
	x.CallIdRegex = b.CallIdRegex
	return m0
}

type ExportPolicy struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	DefaultAction *ExportPolicy_Action   `protobuf:"varint,1,opt,name=default_action,json=defaultAction,enum=mcpany.config.v1.ExportPolicy_Action" json:"default_action,omitempty"`
	Rules         []*ExportRule          `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExportPolicy) Reset() {
	*x = ExportPolicy{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportPolicy) ProtoMessage() {}

func (x *ExportPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ExportPolicy) GetDefaultAction() ExportPolicy_Action {
	if x != nil && x.DefaultAction != nil {
		return *x.DefaultAction
	}
	return ExportPolicy_EXPORT_ACTION_UNSPECIFIED
}

func (x *ExportPolicy) GetRules() []*ExportRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *ExportPolicy) SetDefaultAction(v ExportPolicy_Action) {
	x.DefaultAction = &v
}

func (x *ExportPolicy) SetRules(v []*ExportRule) {
	x.Rules = v
}

func (x *ExportPolicy) HasDefaultAction() bool {
	if x == nil {
		return false
	}
	return x.DefaultAction != nil
}

func (x *ExportPolicy) ClearDefaultAction() {
	x.DefaultAction = nil
}

type ExportPolicy_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	DefaultAction *ExportPolicy_Action
	Rules         []*ExportRule
}

func (b0 ExportPolicy_builder) Build() *ExportPolicy {
	m0 := &ExportPolicy{}
	b, x := &b0, m0
	_, _ = b, x
	x.DefaultAction = b.DefaultAction
	x.Rules = b.Rules
	return m0
}

type ExportRule struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Regex to match the name (tool, prompt, or resource).
	NameRegex     *string              `protobuf:"bytes,1,opt,name=name_regex" json:"name_regex,omitempty"`
	Action        *ExportPolicy_Action `protobuf:"varint,2,opt,name=action,enum=mcpany.config.v1.ExportPolicy_Action" json:"action,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExportRule) Reset() {
	*x = ExportRule{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportRule) ProtoMessage() {}

func (x *ExportRule) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ExportRule) GetNameRegex() string {
	if x != nil && x.NameRegex != nil {
		return *x.NameRegex
	}
	return ""
}

func (x *ExportRule) GetAction() ExportPolicy_Action {
	if x != nil && x.Action != nil {
		return *x.Action
	}
	return ExportPolicy_EXPORT_ACTION_UNSPECIFIED
}

func (x *ExportRule) SetNameRegex(v string) {
	x.NameRegex = &v
}

func (x *ExportRule) SetAction(v ExportPolicy_Action) {
	x.Action = &v
}

func (x *ExportRule) HasNameRegex() bool {
	if x == nil {
		return false
	}
	return x.NameRegex != nil
}

func (x *ExportRule) HasAction() bool {
	if x == nil {
		return false
	}
	return x.Action != nil
}

func (x *ExportRule) ClearNameRegex() {
	x.NameRegex = nil
}

func (x *ExportRule) ClearAction() {
	x.Action = nil
}

type ExportRule_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Regex to match the name (tool, prompt, or resource).
	NameRegex *string
	Action    *ExportPolicy_Action
}

func (b0 ExportRule_builder) Build() *ExportRule {
	m0 := &ExportRule{}
	b, x := &b0, m0
	_, _ = b, x
	x.NameRegex = b.NameRegex
	x.Action = b.Action
	return m0
}

type CallHook struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	Name  *string                `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Types that are valid to be assigned to HookConfig:
	//
	//	*CallHook_Webhook
	//	*CallHook_CallPolicy
	HookConfig    isCallHook_HookConfig `protobuf_oneof:"hook_config"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallHook) Reset() {
	*x = CallHook{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallHook) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallHook) ProtoMessage() {}

func (x *CallHook) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CallHook) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *CallHook) GetHookConfig() isCallHook_HookConfig {
	if x != nil {
		return x.HookConfig
	}
	return nil
}

func (x *CallHook) GetWebhook() *WebhookConfig {
	if x != nil {
		if x, ok := x.HookConfig.(*CallHook_Webhook); ok {
			return x.Webhook
		}
	}
	return nil
}

func (x *CallHook) GetCallPolicy() *CallPolicy {
	if x != nil {
		if x, ok := x.HookConfig.(*CallHook_CallPolicy); ok {
			return x.CallPolicy
		}
	}
	return nil
}

func (x *CallHook) SetName(v string) {
	x.Name = &v
}

func (x *CallHook) SetWebhook(v *WebhookConfig) {
	if v == nil {
		x.HookConfig = nil
		return
	}
	x.HookConfig = &CallHook_Webhook{v}
}

func (x *CallHook) SetCallPolicy(v *CallPolicy) {
	if v == nil {
		x.HookConfig = nil
		return
	}
	x.HookConfig = &CallHook_CallPolicy{v}
}

func (x *CallHook) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *CallHook) HasHookConfig() bool {
	if x == nil {
		return false
	}
	return x.HookConfig != nil
}

func (x *CallHook) HasWebhook() bool {
	if x == nil {
		return false
	}
	_, ok := x.HookConfig.(*CallHook_Webhook)
	return ok
}

func (x *CallHook) HasCallPolicy() bool {
	if x == nil {
		return false
	}
	_, ok := x.HookConfig.(*CallHook_CallPolicy)
	return ok
}

func (x *CallHook) ClearName() {
	x.Name = nil
}

func (x *CallHook) ClearHookConfig() {
	x.HookConfig = nil
}

func (x *CallHook) ClearWebhook() {
	if _, ok := x.HookConfig.(*CallHook_Webhook); ok {
		x.HookConfig = nil
	}
}

func (x *CallHook) ClearCallPolicy() {
	if _, ok := x.HookConfig.(*CallHook_CallPolicy); ok {
		x.HookConfig = nil
	}
}

const CallHook_HookConfig_not_set_case case_CallHook_HookConfig = 0
const CallHook_Webhook_case case_CallHook_HookConfig = 2
const CallHook_CallPolicy_case case_CallHook_HookConfig = 4

func (x *CallHook) WhichHookConfig() case_CallHook_HookConfig {
	if x == nil {
		return CallHook_HookConfig_not_set_case
	}
	switch x.HookConfig.(type) {
	case *CallHook_Webhook:
		return CallHook_Webhook_case
	case *CallHook_CallPolicy:
		return CallHook_CallPolicy_case
	default:
		return CallHook_HookConfig_not_set_case
	}
}

type CallHook_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Name *string
	// Fields of oneof HookConfig:
	Webhook    *WebhookConfig
	CallPolicy *CallPolicy
	// -- end of HookConfig
}

func (b0 CallHook_builder) Build() *CallHook {
	m0 := &CallHook{}
	b, x := &b0, m0
	_, _ = b, x
	x.Name = b.Name
	if b.Webhook != nil {
		x.HookConfig = &CallHook_Webhook{b.Webhook}
	}
	if b.CallPolicy != nil {
		x.HookConfig = &CallHook_CallPolicy{b.CallPolicy}
	}
	return m0
}

type case_CallHook_HookConfig protoreflect.FieldNumber

func (x case_CallHook_HookConfig) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[6].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isCallHook_HookConfig interface {
	isCallHook_HookConfig()
}

type CallHook_Webhook struct {
	Webhook *WebhookConfig `protobuf:"bytes,2,opt,name=webhook,oneof"`
}

type CallHook_CallPolicy struct {
	CallPolicy *CallPolicy `protobuf:"bytes,4,opt,name=call_policy,json=callPolicy,oneof"`
}

func (*CallHook_Webhook) isCallHook_HookConfig() {}

func (*CallHook_CallPolicy) isCallHook_HookConfig() {}

// GrpcUpstreamService defines an upstream service that speaks gRPC.
type GrpcUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The address of the gRPC server (e.g., "localhost:50051").
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// If true, mcpany will use gRPC reflection to discover services and methods.
	UseReflection *bool `protobuf:"varint,2,opt,name=use_reflection" json:"use_reflection,omitempty"`
	// TLS configuration for the gRPC connection.
	TlsConfig *TLSConfig `protobuf:"bytes,3,opt,name=tls_config" json:"tls_config,omitempty"`
	// Manually defined mappings from MCP tools to gRPC calls.
	Tools []*ToolDefinition `protobuf:"bytes,4,rep,name=tools" json:"tools,omitempty"`
	// Health check configuration.
	HealthCheck *GrpcHealthCheck `protobuf:"bytes,5,opt,name=health_check" json:"health_check,omitempty"`
	// A list of protobuf definitions for the gRPC service.
	ProtoDefinitions []*ProtoDefinition `protobuf:"bytes,6,rep,name=proto_definitions" json:"proto_definitions,omitempty"`
	// A collection of protobuf files to be discovered.
	ProtoCollection []*ProtoCollection `protobuf:"bytes,7,rep,name=proto_collection" json:"proto_collection,omitempty"`
	// A list of resources served by this service.
	Resources []*ResourceDefinition `protobuf:"bytes,8,rep,name=resources" json:"resources,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*GrpcCallDefinition `protobuf:"bytes,9,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The prompts provided by this upstream service.
	Prompts       []*PromptDefinition `protobuf:"bytes,19,rep,name=prompts" json:"prompts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrpcUpstreamService) Reset() {
	*x = GrpcUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrpcUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrpcUpstreamService) ProtoMessage() {}

func (x *GrpcUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *GrpcUpstreamService) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *GrpcUpstreamService) GetUseReflection() bool {
	if x != nil && x.UseReflection != nil {
		return *x.UseReflection
	}
	return false
}

func (x *GrpcUpstreamService) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

func (x *GrpcUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *GrpcUpstreamService) GetHealthCheck() *GrpcHealthCheck {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *GrpcUpstreamService) GetProtoDefinitions() []*ProtoDefinition {
	if x != nil {
		return x.ProtoDefinitions
	}
	return nil
}

func (x *GrpcUpstreamService) GetProtoCollection() []*ProtoCollection {
	if x != nil {
		return x.ProtoCollection
	}
	return nil
}

func (x *GrpcUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *GrpcUpstreamService) GetCalls() map[string]*GrpcCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *GrpcUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *GrpcUpstreamService) SetAddress(v string) {
	x.Address = &v
}

func (x *GrpcUpstreamService) SetUseReflection(v bool) {
	x.UseReflection = &v
}

func (x *GrpcUpstreamService) SetTlsConfig(v *TLSConfig) {
	x.TlsConfig = v
}

func (x *GrpcUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *GrpcUpstreamService) SetHealthCheck(v *GrpcHealthCheck) {
	x.HealthCheck = v
}

func (x *GrpcUpstreamService) SetProtoDefinitions(v []*ProtoDefinition) {
	x.ProtoDefinitions = v
}

func (x *GrpcUpstreamService) SetProtoCollection(v []*ProtoCollection) {
	x.ProtoCollection = v
}

func (x *GrpcUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *GrpcUpstreamService) SetCalls(v map[string]*GrpcCallDefinition) {
	x.Calls = v
}

func (x *GrpcUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *GrpcUpstreamService) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *GrpcUpstreamService) HasUseReflection() bool {
	if x == nil {
		return false
	}
	return x.UseReflection != nil
}

func (x *GrpcUpstreamService) HasTlsConfig() bool {
	if x == nil {
		return false
	}
	return x.TlsConfig != nil
}

func (x *GrpcUpstreamService) HasHealthCheck() bool {
	if x == nil {
		return false
	}
	return x.HealthCheck != nil
}

func (x *GrpcUpstreamService) ClearAddress() {
	x.Address = nil
}

func (x *GrpcUpstreamService) ClearUseReflection() {
	x.UseReflection = nil
}

func (x *GrpcUpstreamService) ClearTlsConfig() {
	x.TlsConfig = nil
}

func (x *GrpcUpstreamService) ClearHealthCheck() {
	x.HealthCheck = nil
}

type GrpcUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The address of the gRPC server (e.g., "localhost:50051").
	Address *string
	// If true, mcpany will use gRPC reflection to discover services and methods.
	UseReflection *bool
	// TLS configuration for the gRPC connection.
	TlsConfig *TLSConfig
	// Manually defined mappings from MCP tools to gRPC calls.
	Tools []*ToolDefinition
	// Health check configuration.
	HealthCheck *GrpcHealthCheck
	// A list of protobuf definitions for the gRPC service.
	ProtoDefinitions []*ProtoDefinition
	// A collection of protobuf files to be discovered.
	ProtoCollection []*ProtoCollection
	// A list of resources served by this service.
	Resources []*ResourceDefinition
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*GrpcCallDefinition
	// The prompts provided by this upstream service.
	Prompts []*PromptDefinition
}

func (b0 GrpcUpstreamService_builder) Build() *GrpcUpstreamService {
	m0 := &GrpcUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.UseReflection = b.UseReflection
	x.TlsConfig = b.TlsConfig
	x.Tools = b.Tools
	x.HealthCheck = b.HealthCheck
	x.ProtoDefinitions = b.ProtoDefinitions
	x.ProtoCollection = b.ProtoCollection
	x.Resources = b.Resources
	x.Calls = b.Calls
	x.Prompts = b.Prompts
	return m0
}

type ProtoDefinition struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Types that are valid to be assigned to ProtoRef:
	//
	//	*ProtoDefinition_ProtoFile
	//	*ProtoDefinition_ProtoDescriptor
	ProtoRef      isProtoDefinition_ProtoRef `protobuf_oneof:"proto_ref"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProtoDefinition) Reset() {
	*x = ProtoDefinition{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoDefinition) ProtoMessage() {}

func (x *ProtoDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ProtoDefinition) GetProtoRef() isProtoDefinition_ProtoRef {
	if x != nil {
		return x.ProtoRef
	}
	return nil
}

func (x *ProtoDefinition) GetProtoFile() *ProtoFile {
	if x != nil {
		if x, ok := x.ProtoRef.(*ProtoDefinition_ProtoFile); ok {
			return x.ProtoFile
		}
	}
	return nil
}

func (x *ProtoDefinition) GetProtoDescriptor() *ProtoDescriptor {
	if x != nil {
		if x, ok := x.ProtoRef.(*ProtoDefinition_ProtoDescriptor); ok {
			return x.ProtoDescriptor
		}
	}
	return nil
}

func (x *ProtoDefinition) SetProtoFile(v *ProtoFile) {
	if v == nil {
		x.ProtoRef = nil
		return
	}
	x.ProtoRef = &ProtoDefinition_ProtoFile{v}
}

func (x *ProtoDefinition) SetProtoDescriptor(v *ProtoDescriptor) {
	if v == nil {
		x.ProtoRef = nil
		return
	}
	x.ProtoRef = &ProtoDefinition_ProtoDescriptor{v}
}

func (x *ProtoDefinition) HasProtoRef() bool {
	if x == nil {
		return false
	}
	return x.ProtoRef != nil
}

func (x *ProtoDefinition) HasProtoFile() bool {
	if x == nil {
		return false
	}
	_, ok := x.ProtoRef.(*ProtoDefinition_ProtoFile)
	return ok
}

func (x *ProtoDefinition) HasProtoDescriptor() bool {
	if x == nil {
		return false
	}
	_, ok := x.ProtoRef.(*ProtoDefinition_ProtoDescriptor)
	return ok
}

func (x *ProtoDefinition) ClearProtoRef() {
	x.ProtoRef = nil
}

func (x *ProtoDefinition) ClearProtoFile() {
	if _, ok := x.ProtoRef.(*ProtoDefinition_ProtoFile); ok {
		x.ProtoRef = nil
	}
}

func (x *ProtoDefinition) ClearProtoDescriptor() {
	if _, ok := x.ProtoRef.(*ProtoDefinition_ProtoDescriptor); ok {
		x.ProtoRef = nil
	}
}

const ProtoDefinition_ProtoRef_not_set_case case_ProtoDefinition_ProtoRef = 0
const ProtoDefinition_ProtoFile_case case_ProtoDefinition_ProtoRef = 1
const ProtoDefinition_ProtoDescriptor_case case_ProtoDefinition_ProtoRef = 2

func (x *ProtoDefinition) WhichProtoRef() case_ProtoDefinition_ProtoRef {
	if x == nil {
		return ProtoDefinition_ProtoRef_not_set_case
	}
	switch x.ProtoRef.(type) {
	case *ProtoDefinition_ProtoFile:
		return ProtoDefinition_ProtoFile_case
	case *ProtoDefinition_ProtoDescriptor:
		return ProtoDefinition_ProtoDescriptor_case
	default:
		return ProtoDefinition_ProtoRef_not_set_case
	}
}

type ProtoDefinition_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof ProtoRef:
	ProtoFile       *ProtoFile
	ProtoDescriptor *ProtoDescriptor
	// -- end of ProtoRef
}

func (b0 ProtoDefinition_builder) Build() *ProtoDefinition {
	m0 := &ProtoDefinition{}
	b, x := &b0, m0
	_, _ = b, x
	if b.ProtoFile != nil {
		x.ProtoRef = &ProtoDefinition_ProtoFile{b.ProtoFile}
	}
	if b.ProtoDescriptor != nil {
		x.ProtoRef = &ProtoDefinition_ProtoDescriptor{b.ProtoDescriptor}
	}
	return m0
}

type case_ProtoDefinition_ProtoRef protoreflect.FieldNumber

func (x case_ProtoDefinition_ProtoRef) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[8].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isProtoDefinition_ProtoRef interface {
	isProtoDefinition_ProtoRef()
}

type ProtoDefinition_ProtoFile struct {
	ProtoFile *ProtoFile `protobuf:"bytes,1,opt,name=proto_file,oneof"`
}

type ProtoDefinition_ProtoDescriptor struct {
	ProtoDescriptor *ProtoDescriptor `protobuf:"bytes,2,opt,name=proto_descriptor,oneof"`
}

func (*ProtoDefinition_ProtoFile) isProtoDefinition_ProtoRef() {}

func (*ProtoDefinition_ProtoDescriptor) isProtoDefinition_ProtoRef() {}

type ProtoFile struct {
	state    protoimpl.MessageState `protogen:"hybrid.v1"`
	FileName *string                `protobuf:"bytes,1,opt,name=file_name" json:"file_name,omitempty"`
	// Types that are valid to be assigned to FileRef:
	//
	//	*ProtoFile_FileContent
	//	*ProtoFile_FilePath
	FileRef       isProtoFile_FileRef `protobuf_oneof:"file_ref"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProtoFile) Reset() {
	*x = ProtoFile{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoFile) ProtoMessage() {}

func (x *ProtoFile) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ProtoFile) GetFileName() string {
	if x != nil && x.FileName != nil {
		return *x.FileName
	}
	return ""
}

func (x *ProtoFile) GetFileRef() isProtoFile_FileRef {
	if x != nil {
		return x.FileRef
	}
	return nil
}

func (x *ProtoFile) GetFileContent() string {
	if x != nil {
		if x, ok := x.FileRef.(*ProtoFile_FileContent); ok {
			return x.FileContent
		}
	}
	return ""
}

func (x *ProtoFile) GetFilePath() string {
	if x != nil {
		if x, ok := x.FileRef.(*ProtoFile_FilePath); ok {
			return x.FilePath
		}
	}
	return ""
}

func (x *ProtoFile) SetFileName(v string) {
	x.FileName = &v
}

func (x *ProtoFile) SetFileContent(v string) {
	x.FileRef = &ProtoFile_FileContent{v}
}

func (x *ProtoFile) SetFilePath(v string) {
	x.FileRef = &ProtoFile_FilePath{v}
}

func (x *ProtoFile) HasFileName() bool {
	if x == nil {
		return false
	}
	return x.FileName != nil
}

func (x *ProtoFile) HasFileRef() bool {
	if x == nil {
		return false
	}
	return x.FileRef != nil
}

func (x *ProtoFile) HasFileContent() bool {
	if x == nil {
		return false
	}
	_, ok := x.FileRef.(*ProtoFile_FileContent)
	return ok
}

func (x *ProtoFile) HasFilePath() bool {
	if x == nil {
		return false
	}
	_, ok := x.FileRef.(*ProtoFile_FilePath)
	return ok
}

func (x *ProtoFile) ClearFileName() {
	x.FileName = nil
}

func (x *ProtoFile) ClearFileRef() {
	x.FileRef = nil
}

func (x *ProtoFile) ClearFileContent() {
	if _, ok := x.FileRef.(*ProtoFile_FileContent); ok {
		x.FileRef = nil
	}
}

func (x *ProtoFile) ClearFilePath() {
	if _, ok := x.FileRef.(*ProtoFile_FilePath); ok {
		x.FileRef = nil
	}
}

const ProtoFile_FileRef_not_set_case case_ProtoFile_FileRef = 0
const ProtoFile_FileContent_case case_ProtoFile_FileRef = 2
const ProtoFile_FilePath_case case_ProtoFile_FileRef = 3

func (x *ProtoFile) WhichFileRef() case_ProtoFile_FileRef {
	if x == nil {
		return ProtoFile_FileRef_not_set_case
	}
	switch x.FileRef.(type) {
	case *ProtoFile_FileContent:
		return ProtoFile_FileContent_case
	case *ProtoFile_FilePath:
		return ProtoFile_FilePath_case
	default:
		return ProtoFile_FileRef_not_set_case
	}
}

type ProtoFile_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	FileName *string
	// Fields of oneof FileRef:
	FileContent *string
	FilePath    *string
	// -- end of FileRef
}

func (b0 ProtoFile_builder) Build() *ProtoFile {
	m0 := &ProtoFile{}
	b, x := &b0, m0
	_, _ = b, x
	x.FileName = b.FileName
	if b.FileContent != nil {
		x.FileRef = &ProtoFile_FileContent{*b.FileContent}
	}
	if b.FilePath != nil {
		x.FileRef = &ProtoFile_FilePath{*b.FilePath}
	}
	return m0
}

type case_ProtoFile_FileRef protoreflect.FieldNumber

func (x case_ProtoFile_FileRef) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[9].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isProtoFile_FileRef interface {
	isProtoFile_FileRef()
}

type ProtoFile_FileContent struct {
	FileContent string `protobuf:"bytes,2,opt,name=file_content,oneof"`
}

type ProtoFile_FilePath struct {
	FilePath string `protobuf:"bytes,3,opt,name=file_path,oneof"`
}

func (*ProtoFile_FileContent) isProtoFile_FileRef() {}

func (*ProtoFile_FilePath) isProtoFile_FileRef() {}

type ProtoDescriptor struct {
	state    protoimpl.MessageState `protogen:"hybrid.v1"`
	FileName *string                `protobuf:"bytes,1,opt,name=file_name" json:"file_name,omitempty"`
	// Types that are valid to be assigned to FileRef:
	//
	//	*ProtoDescriptor_FilePath
	FileRef       isProtoDescriptor_FileRef `protobuf_oneof:"file_ref"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProtoDescriptor) Reset() {
	*x = ProtoDescriptor{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoDescriptor) ProtoMessage() {}

func (x *ProtoDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ProtoDescriptor) GetFileName() string {
	if x != nil && x.FileName != nil {
		return *x.FileName
	}
	return ""
}

func (x *ProtoDescriptor) GetFileRef() isProtoDescriptor_FileRef {
	if x != nil {
		return x.FileRef
	}
	return nil
}

func (x *ProtoDescriptor) GetFilePath() string {
	if x != nil {
		if x, ok := x.FileRef.(*ProtoDescriptor_FilePath); ok {
			return x.FilePath
		}
	}
	return ""
}

func (x *ProtoDescriptor) SetFileName(v string) {
	x.FileName = &v
}

func (x *ProtoDescriptor) SetFilePath(v string) {
	x.FileRef = &ProtoDescriptor_FilePath{v}
}

func (x *ProtoDescriptor) HasFileName() bool {
	if x == nil {
		return false
	}
	return x.FileName != nil
}

func (x *ProtoDescriptor) HasFileRef() bool {
	if x == nil {
		return false
	}
	return x.FileRef != nil
}

func (x *ProtoDescriptor) HasFilePath() bool {
	if x == nil {
		return false
	}
	_, ok := x.FileRef.(*ProtoDescriptor_FilePath)
	return ok
}

func (x *ProtoDescriptor) ClearFileName() {
	x.FileName = nil
}

func (x *ProtoDescriptor) ClearFileRef() {
	x.FileRef = nil
}

func (x *ProtoDescriptor) ClearFilePath() {
	if _, ok := x.FileRef.(*ProtoDescriptor_FilePath); ok {
		x.FileRef = nil
	}
}

const ProtoDescriptor_FileRef_not_set_case case_ProtoDescriptor_FileRef = 0
const ProtoDescriptor_FilePath_case case_ProtoDescriptor_FileRef = 2

func (x *ProtoDescriptor) WhichFileRef() case_ProtoDescriptor_FileRef {
	if x == nil {
		return ProtoDescriptor_FileRef_not_set_case
	}
	switch x.FileRef.(type) {
	case *ProtoDescriptor_FilePath:
		return ProtoDescriptor_FilePath_case
	default:
		return ProtoDescriptor_FileRef_not_set_case
	}
}

type ProtoDescriptor_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	FileName *string
	// Fields of oneof FileRef:
	FilePath *string
	// -- end of FileRef
}

func (b0 ProtoDescriptor_builder) Build() *ProtoDescriptor {
	m0 := &ProtoDescriptor{}
	b, x := &b0, m0
	_, _ = b, x
	x.FileName = b.FileName
	if b.FilePath != nil {
		x.FileRef = &ProtoDescriptor_FilePath{*b.FilePath}
	}
	return m0
}

type case_ProtoDescriptor_FileRef protoreflect.FieldNumber

func (x case_ProtoDescriptor_FileRef) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[10].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isProtoDescriptor_FileRef interface {
	isProtoDescriptor_FileRef()
}

type ProtoDescriptor_FilePath struct {
	FilePath string `protobuf:"bytes,2,opt,name=file_path,oneof"`
}

func (*ProtoDescriptor_FilePath) isProtoDescriptor_FileRef() {}

type ProtoCollection struct {
	state          protoimpl.MessageState `protogen:"hybrid.v1"`
	RootPath       *string                `protobuf:"bytes,1,opt,name=root_path" json:"root_path,omitempty"`
	PathMatchRegex *string                `protobuf:"bytes,2,opt,name=path_match_regex" json:"path_match_regex,omitempty"`
	IsRecursive    *bool                  `protobuf:"varint,3,opt,name=is_recursive" json:"is_recursive,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ProtoCollection) Reset() {
	*x = ProtoCollection{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtoCollection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtoCollection) ProtoMessage() {}

func (x *ProtoCollection) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ProtoCollection) GetRootPath() string {
	if x != nil && x.RootPath != nil {
		return *x.RootPath
	}
	return ""
}

func (x *ProtoCollection) GetPathMatchRegex() string {
	if x != nil && x.PathMatchRegex != nil {
		return *x.PathMatchRegex
	}
	return ""
}

func (x *ProtoCollection) GetIsRecursive() bool {
	if x != nil && x.IsRecursive != nil {
		return *x.IsRecursive
	}
	return false
}

func (x *ProtoCollection) SetRootPath(v string) {
	x.RootPath = &v
}

func (x *ProtoCollection) SetPathMatchRegex(v string) {
	x.PathMatchRegex = &v
}

func (x *ProtoCollection) SetIsRecursive(v bool) {
	x.IsRecursive = &v
}

func (x *ProtoCollection) HasRootPath() bool {
	if x == nil {
		return false
	}
	return x.RootPath != nil
}

func (x *ProtoCollection) HasPathMatchRegex() bool {
	if x == nil {
		return false
	}
	return x.PathMatchRegex != nil
}

func (x *ProtoCollection) HasIsRecursive() bool {
	if x == nil {
		return false
	}
	return x.IsRecursive != nil
}

func (x *ProtoCollection) ClearRootPath() {
	x.RootPath = nil
}

func (x *ProtoCollection) ClearPathMatchRegex() {
	x.PathMatchRegex = nil
}

func (x *ProtoCollection) ClearIsRecursive() {
	x.IsRecursive = nil
}

type ProtoCollection_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	RootPath       *string
	PathMatchRegex *string
	IsRecursive    *bool
}

func (b0 ProtoCollection_builder) Build() *ProtoCollection {
	m0 := &ProtoCollection{}
	b, x := &b0, m0
	_, _ = b, x
	x.RootPath = b.RootPath
	x.PathMatchRegex = b.PathMatchRegex
	x.IsRecursive = b.IsRecursive
	return m0
}

// HttpUpstreamService defines an upstream service that speaks HTTP.
type HttpUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The base URL of the HTTP service (e.g., "https://api.example.com").
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Manually defined mappings from MCP tools to HTTP calls.
	Tools []*ToolDefinition `protobuf:"bytes,2,rep,name=tools" json:"tools,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*HttpCallDefinition `protobuf:"bytes,6,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Configuration for checking the health of the HTTP service.
	HealthCheck *HttpHealthCheck `protobuf:"bytes,3,opt,name=health_check" json:"health_check,omitempty"`
	// TLS configuration for the HTTP connection.
	TlsConfig *TLSConfig `protobuf:"bytes,4,opt,name=tls_config" json:"tls_config,omitempty"`
	// A list of resources served by this service.
	Resources []*ResourceDefinition `protobuf:"bytes,5,rep,name=resources" json:"resources,omitempty"`
	// A list of prompts served by this service.
	Prompts       []*PromptDefinition `protobuf:"bytes,7,rep,name=prompts" json:"prompts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpUpstreamService) Reset() {
	*x = HttpUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpUpstreamService) ProtoMessage() {}

func (x *HttpUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *HttpUpstreamService) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *HttpUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *HttpUpstreamService) GetCalls() map[string]*HttpCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *HttpUpstreamService) GetHealthCheck() *HttpHealthCheck {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *HttpUpstreamService) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

func (x *HttpUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *HttpUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *HttpUpstreamService) SetAddress(v string) {
	x.Address = &v
}

func (x *HttpUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *HttpUpstreamService) SetCalls(v map[string]*HttpCallDefinition) {
	x.Calls = v
}

func (x *HttpUpstreamService) SetHealthCheck(v *HttpHealthCheck) {
	x.HealthCheck = v
}

func (x *HttpUpstreamService) SetTlsConfig(v *TLSConfig) {
	x.TlsConfig = v
}

func (x *HttpUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *HttpUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *HttpUpstreamService) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *HttpUpstreamService) HasHealthCheck() bool {
	if x == nil {
		return false
	}
	return x.HealthCheck != nil
}

func (x *HttpUpstreamService) HasTlsConfig() bool {
	if x == nil {
		return false
	}
	return x.TlsConfig != nil
}

func (x *HttpUpstreamService) ClearAddress() {
	x.Address = nil
}

func (x *HttpUpstreamService) ClearHealthCheck() {
	x.HealthCheck = nil
}

func (x *HttpUpstreamService) ClearTlsConfig() {
	x.TlsConfig = nil
}

type HttpUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The base URL of the HTTP service (e.g., "https://api.example.com").
	Address *string
	// Manually defined mappings from MCP tools to HTTP calls.
	Tools []*ToolDefinition
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*HttpCallDefinition
	// Configuration for checking the health of the HTTP service.
	HealthCheck *HttpHealthCheck
	// TLS configuration for the HTTP connection.
	TlsConfig *TLSConfig
	// A list of resources served by this service.
	Resources []*ResourceDefinition
	// A list of prompts served by this service.
	Prompts []*PromptDefinition
}

func (b0 HttpUpstreamService_builder) Build() *HttpUpstreamService {
	m0 := &HttpUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.Tools = b.Tools
	x.Calls = b.Calls
	x.HealthCheck = b.HealthCheck
	x.TlsConfig = b.TlsConfig
	x.Resources = b.Resources
	x.Prompts = b.Prompts
	return m0
}

// WebsocketUpstreamService defines an upstream service that communicates over Websocket.
type WebsocketUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The URL of the Websocket service (e.g., "ws://api.example.com/ws").
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Manually defined mappings from MCP tools to websocket calls.
	Tools []*ToolDefinition `protobuf:"bytes,2,rep,name=tools" json:"tools,omitempty"`
	// TLS configuration for the Websocket connection.
	TlsConfig *TLSConfig `protobuf:"bytes,3,opt,name=tls_config" json:"tls_config,omitempty"`
	// A list of resources served by this service.
	Resources []*ResourceDefinition `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*WebsocketCallDefinition `protobuf:"bytes,5,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A list of prompts served by this service.
	Prompts []*PromptDefinition `protobuf:"bytes,6,rep,name=prompts" json:"prompts,omitempty"`
	// Health check configuration.
	HealthCheck   *WebsocketHealthCheck `protobuf:"bytes,7,opt,name=health_check" json:"health_check,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WebsocketUpstreamService) Reset() {
	*x = WebsocketUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebsocketUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebsocketUpstreamService) ProtoMessage() {}

func (x *WebsocketUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *WebsocketUpstreamService) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *WebsocketUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *WebsocketUpstreamService) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

func (x *WebsocketUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *WebsocketUpstreamService) GetCalls() map[string]*WebsocketCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *WebsocketUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *WebsocketUpstreamService) GetHealthCheck() *WebsocketHealthCheck {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *WebsocketUpstreamService) SetAddress(v string) {
	x.Address = &v
}

func (x *WebsocketUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *WebsocketUpstreamService) SetTlsConfig(v *TLSConfig) {
	x.TlsConfig = v
}

func (x *WebsocketUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *WebsocketUpstreamService) SetCalls(v map[string]*WebsocketCallDefinition) {
	x.Calls = v
}

func (x *WebsocketUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *WebsocketUpstreamService) SetHealthCheck(v *WebsocketHealthCheck) {
	x.HealthCheck = v
}

func (x *WebsocketUpstreamService) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *WebsocketUpstreamService) HasTlsConfig() bool {
	if x == nil {
		return false
	}
	return x.TlsConfig != nil
}

func (x *WebsocketUpstreamService) HasHealthCheck() bool {
	if x == nil {
		return false
	}
	return x.HealthCheck != nil
}

func (x *WebsocketUpstreamService) ClearAddress() {
	x.Address = nil
}

func (x *WebsocketUpstreamService) ClearTlsConfig() {
	x.TlsConfig = nil
}

func (x *WebsocketUpstreamService) ClearHealthCheck() {
	x.HealthCheck = nil
}

type WebsocketUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The URL of the Websocket service (e.g., "ws://api.example.com/ws").
	Address *string
	// Manually defined mappings from MCP tools to websocket calls.
	Tools []*ToolDefinition
	// TLS configuration for the Websocket connection.
	TlsConfig *TLSConfig
	// A list of resources served by this service.
	Resources []*ResourceDefinition
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*WebsocketCallDefinition
	// A list of prompts served by this service.
	Prompts []*PromptDefinition
	// Health check configuration.
	HealthCheck *WebsocketHealthCheck
}

func (b0 WebsocketUpstreamService_builder) Build() *WebsocketUpstreamService {
	m0 := &WebsocketUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.Tools = b.Tools
	x.TlsConfig = b.TlsConfig
	x.Resources = b.Resources
	x.Calls = b.Calls
	x.Prompts = b.Prompts
	x.HealthCheck = b.HealthCheck
	return m0
}

// WebrtcUpstreamService defines an upstream service that communicates over WebRTC data channels.
type WebrtcUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The URL of the WebRTC signaling service (e.g., "http://api.example.com/signal").
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Manually defined mappings from MCP tools to webrtc calls.
	Tools []*ToolDefinition `protobuf:"bytes,2,rep,name=tools" json:"tools,omitempty"`
	// TLS configuration for the signaling connection.
	TlsConfig *TLSConfig `protobuf:"bytes,3,opt,name=tls_config" json:"tls_config,omitempty"`
	// A list of resources served by this service.
	Resources []*ResourceDefinition `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*WebrtcCallDefinition `protobuf:"bytes,5,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A list of prompts served by this service.
	Prompts []*PromptDefinition `protobuf:"bytes,6,rep,name=prompts" json:"prompts,omitempty"`
	// Health check configuration.
	HealthCheck   *WebRTCHealthCheck `protobuf:"bytes,7,opt,name=health_check" json:"health_check,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WebrtcUpstreamService) Reset() {
	*x = WebrtcUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebrtcUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebrtcUpstreamService) ProtoMessage() {}

func (x *WebrtcUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *WebrtcUpstreamService) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *WebrtcUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *WebrtcUpstreamService) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

func (x *WebrtcUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *WebrtcUpstreamService) GetCalls() map[string]*WebrtcCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *WebrtcUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *WebrtcUpstreamService) GetHealthCheck() *WebRTCHealthCheck {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *WebrtcUpstreamService) SetAddress(v string) {
	x.Address = &v
}

func (x *WebrtcUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *WebrtcUpstreamService) SetTlsConfig(v *TLSConfig) {
	x.TlsConfig = v
}

func (x *WebrtcUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *WebrtcUpstreamService) SetCalls(v map[string]*WebrtcCallDefinition) {
	x.Calls = v
}

func (x *WebrtcUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *WebrtcUpstreamService) SetHealthCheck(v *WebRTCHealthCheck) {
	x.HealthCheck = v
}

func (x *WebrtcUpstreamService) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *WebrtcUpstreamService) HasTlsConfig() bool {
	if x == nil {
		return false
	}
	return x.TlsConfig != nil
}

func (x *WebrtcUpstreamService) HasHealthCheck() bool {
	if x == nil {
		return false
	}
	return x.HealthCheck != nil
}

func (x *WebrtcUpstreamService) ClearAddress() {
	x.Address = nil
}

func (x *WebrtcUpstreamService) ClearTlsConfig() {
	x.TlsConfig = nil
}

func (x *WebrtcUpstreamService) ClearHealthCheck() {
	x.HealthCheck = nil
}

type WebrtcUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The URL of the WebRTC signaling service (e.g., "http://api.example.com/signal").
	Address *string
	// Manually defined mappings from MCP tools to webrtc calls.
	Tools []*ToolDefinition
	// TLS configuration for the signaling connection.
	TlsConfig *TLSConfig
	// A list of resources served by this service.
	Resources []*ResourceDefinition
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*WebrtcCallDefinition
	// A list of prompts served by this service.
	Prompts []*PromptDefinition
	// Health check configuration.
	HealthCheck *WebRTCHealthCheck
}

func (b0 WebrtcUpstreamService_builder) Build() *WebrtcUpstreamService {
	m0 := &WebrtcUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.Tools = b.Tools
	x.TlsConfig = b.TlsConfig
	x.Resources = b.Resources
	x.Calls = b.Calls
	x.Prompts = b.Prompts
	x.HealthCheck = b.HealthCheck
	return m0
}

// OpenapiUpstreamService defines a service based on an OpenAPI/Swagger specification.
type OpenapiUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The base URL of the API.
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Types that are valid to be assigned to SpecSource:
	//
	//	*OpenapiUpstreamService_SpecContent
	//	*OpenapiUpstreamService_SpecUrl
	SpecSource isOpenapiUpstreamService_SpecSource `protobuf_oneof:"spec_source"`
	// Health check configuration.
	HealthCheck *HttpHealthCheck `protobuf:"bytes,3,opt,name=health_check" json:"health_check,omitempty"`
	// TLS configuration for the connection.
	TlsConfig *TLSConfig `protobuf:"bytes,4,opt,name=tls_config" json:"tls_config,omitempty"`
	// Optional: Overrides or specific configurations for calls discovered from the spec.
	Tools []*ToolDefinition `protobuf:"bytes,5,rep,name=tools" json:"tools,omitempty"`
	// A list of resources served by this service.
	Resources []*ResourceDefinition `protobuf:"bytes,6,rep,name=resources" json:"resources,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*OpenAPICallDefinition `protobuf:"bytes,7,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A list of prompts served by this service.
	Prompts       []*PromptDefinition `protobuf:"bytes,8,rep,name=prompts" json:"prompts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpenapiUpstreamService) Reset() {
	*x = OpenapiUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenapiUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenapiUpstreamService) ProtoMessage() {}

func (x *OpenapiUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *OpenapiUpstreamService) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *OpenapiUpstreamService) GetSpecSource() isOpenapiUpstreamService_SpecSource {
	if x != nil {
		return x.SpecSource
	}
	return nil
}

func (x *OpenapiUpstreamService) GetSpecContent() string {
	if x != nil {
		if x, ok := x.SpecSource.(*OpenapiUpstreamService_SpecContent); ok {
			return x.SpecContent
		}
	}
	return ""
}

func (x *OpenapiUpstreamService) GetSpecUrl() string {
	if x != nil {
		if x, ok := x.SpecSource.(*OpenapiUpstreamService_SpecUrl); ok {
			return x.SpecUrl
		}
	}
	return ""
}

func (x *OpenapiUpstreamService) GetHealthCheck() *HttpHealthCheck {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *OpenapiUpstreamService) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

func (x *OpenapiUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *OpenapiUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *OpenapiUpstreamService) GetCalls() map[string]*OpenAPICallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *OpenapiUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *OpenapiUpstreamService) SetAddress(v string) {
	x.Address = &v
}

func (x *OpenapiUpstreamService) SetSpecContent(v string) {
	x.SpecSource = &OpenapiUpstreamService_SpecContent{v}
}

func (x *OpenapiUpstreamService) SetSpecUrl(v string) {
	x.SpecSource = &OpenapiUpstreamService_SpecUrl{v}
}

func (x *OpenapiUpstreamService) SetHealthCheck(v *HttpHealthCheck) {
	x.HealthCheck = v
}

func (x *OpenapiUpstreamService) SetTlsConfig(v *TLSConfig) {
	x.TlsConfig = v
}

func (x *OpenapiUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *OpenapiUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *OpenapiUpstreamService) SetCalls(v map[string]*OpenAPICallDefinition) {
	x.Calls = v
}

func (x *OpenapiUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *OpenapiUpstreamService) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *OpenapiUpstreamService) HasSpecSource() bool {
	if x == nil {
		return false
	}
	return x.SpecSource != nil
}

func (x *OpenapiUpstreamService) HasSpecContent() bool {
	if x == nil {
		return false
	}
	_, ok := x.SpecSource.(*OpenapiUpstreamService_SpecContent)
	return ok
}

func (x *OpenapiUpstreamService) HasSpecUrl() bool {
	if x == nil {
		return false
	}
	_, ok := x.SpecSource.(*OpenapiUpstreamService_SpecUrl)
	return ok
}

func (x *OpenapiUpstreamService) HasHealthCheck() bool {
	if x == nil {
		return false
	}
	return x.HealthCheck != nil
}

func (x *OpenapiUpstreamService) HasTlsConfig() bool {
	if x == nil {
		return false
	}
	return x.TlsConfig != nil
}

func (x *OpenapiUpstreamService) ClearAddress() {
	x.Address = nil
}

func (x *OpenapiUpstreamService) ClearSpecSource() {
	x.SpecSource = nil
}

func (x *OpenapiUpstreamService) ClearSpecContent() {
	if _, ok := x.SpecSource.(*OpenapiUpstreamService_SpecContent); ok {
		x.SpecSource = nil
	}
}

func (x *OpenapiUpstreamService) ClearSpecUrl() {
	if _, ok := x.SpecSource.(*OpenapiUpstreamService_SpecUrl); ok {
		x.SpecSource = nil
	}
}

func (x *OpenapiUpstreamService) ClearHealthCheck() {
	x.HealthCheck = nil
}

func (x *OpenapiUpstreamService) ClearTlsConfig() {
	x.TlsConfig = nil
}

const OpenapiUpstreamService_SpecSource_not_set_case case_OpenapiUpstreamService_SpecSource = 0
const OpenapiUpstreamService_SpecContent_case case_OpenapiUpstreamService_SpecSource = 2
const OpenapiUpstreamService_SpecUrl_case case_OpenapiUpstreamService_SpecSource = 9

func (x *OpenapiUpstreamService) WhichSpecSource() case_OpenapiUpstreamService_SpecSource {
	if x == nil {
		return OpenapiUpstreamService_SpecSource_not_set_case
	}
	switch x.SpecSource.(type) {
	case *OpenapiUpstreamService_SpecContent:
		return OpenapiUpstreamService_SpecContent_case
	case *OpenapiUpstreamService_SpecUrl:
		return OpenapiUpstreamService_SpecUrl_case
	default:
		return OpenapiUpstreamService_SpecSource_not_set_case
	}
}

type OpenapiUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The base URL of the API.
	Address *string
	// Fields of oneof SpecSource:
	// The OpenAPI specification content (JSON or YAML).
	SpecContent *string
	// The URL to fetch the OpenAPI specification from.
	SpecUrl *string
	// -- end of SpecSource
	// Health check configuration.
	HealthCheck *HttpHealthCheck
	// TLS configuration for the connection.
	TlsConfig *TLSConfig
	// Optional: Overrides or specific configurations for calls discovered from the spec.
	Tools []*ToolDefinition
	// A list of resources served by this service.
	Resources []*ResourceDefinition
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*OpenAPICallDefinition
	// A list of prompts served by this service.
	Prompts []*PromptDefinition
}

func (b0 OpenapiUpstreamService_builder) Build() *OpenapiUpstreamService {
	m0 := &OpenapiUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	if b.SpecContent != nil {
		x.SpecSource = &OpenapiUpstreamService_SpecContent{*b.SpecContent}
	}
	if b.SpecUrl != nil {
		x.SpecSource = &OpenapiUpstreamService_SpecUrl{*b.SpecUrl}
	}
	x.HealthCheck = b.HealthCheck
	x.TlsConfig = b.TlsConfig
	x.Tools = b.Tools
	x.Resources = b.Resources
	x.Calls = b.Calls
	x.Prompts = b.Prompts
	return m0
}

type case_OpenapiUpstreamService_SpecSource protoreflect.FieldNumber

func (x case_OpenapiUpstreamService_SpecSource) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[15].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isOpenapiUpstreamService_SpecSource interface {
	isOpenapiUpstreamService_SpecSource()
}

type OpenapiUpstreamService_SpecContent struct {
	// The OpenAPI specification content (JSON or YAML).
	SpecContent string `protobuf:"bytes,2,opt,name=spec_content,oneof"`
}

type OpenapiUpstreamService_SpecUrl struct {
	// The URL to fetch the OpenAPI specification from.
	SpecUrl string `protobuf:"bytes,9,opt,name=spec_url,oneof"`
}

func (*OpenapiUpstreamService_SpecContent) isOpenapiUpstreamService_SpecSource() {}

func (*OpenapiUpstreamService_SpecUrl) isOpenapiUpstreamService_SpecSource() {}

// CommandLineUpstreamService defines a service that communicates over standard I/O.
type CommandLineUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The command to execute the service.
	Command *string `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	// The working directory for the command.
	WorkingDirectory *string `protobuf:"bytes,3,opt,name=working_directory" json:"working_directory,omitempty"`
	// Manually defined mappings from MCP tools to command line commands.
	Tools []*ToolDefinition `protobuf:"bytes,4,rep,name=tools" json:"tools,omitempty"`
	// Health check configuration.
	HealthCheck *CommandLineHealthCheck `protobuf:"bytes,5,opt,name=health_check" json:"health_check,omitempty"`
	// Caching configuration to improve performance and reduce load on the upstream.
	Cache *CacheConfig `protobuf:"bytes,6,opt,name=cache" json:"cache,omitempty"`
	// Container environment to run the command in.
	ContainerEnvironment *ContainerEnvironment `protobuf:"bytes,7,opt,name=container_environment" json:"container_environment,omitempty"`
	// Timeout for the command execution.
	Timeout *durationpb.Duration `protobuf:"bytes,8,opt,name=timeout" json:"timeout,omitempty"`
	// A list of resources served by this service.
	Resources []*ResourceDefinition `protobuf:"bytes,9,rep,name=resources" json:"resources,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*CommandLineCallDefinition `protobuf:"bytes,10,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A list of prompts served by this service.
	Prompts               []*PromptDefinition                               `protobuf:"bytes,11,rep,name=prompts" json:"prompts,omitempty"`
	CommunicationProtocol *CommandLineUpstreamService_CommunicationProtocol `protobuf:"varint,12,opt,name=communication_protocol,enum=mcpany.config.v1.CommandLineUpstreamService_CommunicationProtocol" json:"communication_protocol,omitempty"`
	// If true, the command will be executed on the local filesystem.
	Local *bool `protobuf:"varint,13,opt,name=local" json:"local,omitempty"`
	// Environment variables to set for the command (supports secrets).
	Env           map[string]*SecretValue `protobuf:"bytes,14,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommandLineUpstreamService) Reset() {
	*x = CommandLineUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommandLineUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommandLineUpstreamService) ProtoMessage() {}

func (x *CommandLineUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CommandLineUpstreamService) GetCommand() string {
	if x != nil && x.Command != nil {
		return *x.Command
	}
	return ""
}

func (x *CommandLineUpstreamService) GetWorkingDirectory() string {
	if x != nil && x.WorkingDirectory != nil {
		return *x.WorkingDirectory
	}
	return ""
}

func (x *CommandLineUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *CommandLineUpstreamService) GetHealthCheck() *CommandLineHealthCheck {
	if x != nil {
		return x.HealthCheck
	}
	return nil
}

func (x *CommandLineUpstreamService) GetCache() *CacheConfig {
	if x != nil {
		return x.Cache
	}
	return nil
}

func (x *CommandLineUpstreamService) GetContainerEnvironment() *ContainerEnvironment {
	if x != nil {
		return x.ContainerEnvironment
	}
	return nil
}

func (x *CommandLineUpstreamService) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *CommandLineUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *CommandLineUpstreamService) GetCalls() map[string]*CommandLineCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *CommandLineUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *CommandLineUpstreamService) GetCommunicationProtocol() CommandLineUpstreamService_CommunicationProtocol {
	if x != nil && x.CommunicationProtocol != nil {
		return *x.CommunicationProtocol
	}
	return CommandLineUpstreamService_COMMUNICATION_PROTOCOL_UNSPECIFIED
}

func (x *CommandLineUpstreamService) GetLocal() bool {
	if x != nil && x.Local != nil {
		return *x.Local
	}
	return false
}

func (x *CommandLineUpstreamService) GetEnv() map[string]*SecretValue {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *CommandLineUpstreamService) SetCommand(v string) {
	x.Command = &v
}

func (x *CommandLineUpstreamService) SetWorkingDirectory(v string) {
	x.WorkingDirectory = &v
}

func (x *CommandLineUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *CommandLineUpstreamService) SetHealthCheck(v *CommandLineHealthCheck) {
	x.HealthCheck = v
}

func (x *CommandLineUpstreamService) SetCache(v *CacheConfig) {
	x.Cache = v
}

func (x *CommandLineUpstreamService) SetContainerEnvironment(v *ContainerEnvironment) {
	x.ContainerEnvironment = v
}

func (x *CommandLineUpstreamService) SetTimeout(v *durationpb.Duration) {
	x.Timeout = v
}

func (x *CommandLineUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *CommandLineUpstreamService) SetCalls(v map[string]*CommandLineCallDefinition) {
	x.Calls = v
}

func (x *CommandLineUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *CommandLineUpstreamService) SetCommunicationProtocol(v CommandLineUpstreamService_CommunicationProtocol) {
	x.CommunicationProtocol = &v
}

func (x *CommandLineUpstreamService) SetLocal(v bool) {
	x.Local = &v
}

func (x *CommandLineUpstreamService) SetEnv(v map[string]*SecretValue) {
	x.Env = v
}

func (x *CommandLineUpstreamService) HasCommand() bool {
	if x == nil {
		return false
	}
	return x.Command != nil
}

func (x *CommandLineUpstreamService) HasWorkingDirectory() bool {
	if x == nil {
		return false
	}
	return x.WorkingDirectory != nil
}

func (x *CommandLineUpstreamService) HasHealthCheck() bool {
	if x == nil {
		return false
	}
	return x.HealthCheck != nil
}

func (x *CommandLineUpstreamService) HasCache() bool {
	if x == nil {
		return false
	}
	return x.Cache != nil
}

func (x *CommandLineUpstreamService) HasContainerEnvironment() bool {
	if x == nil {
		return false
	}
	return x.ContainerEnvironment != nil
}

func (x *CommandLineUpstreamService) HasTimeout() bool {
	if x == nil {
		return false
	}
	return x.Timeout != nil
}

func (x *CommandLineUpstreamService) HasCommunicationProtocol() bool {
	if x == nil {
		return false
	}
	return x.CommunicationProtocol != nil
}

func (x *CommandLineUpstreamService) HasLocal() bool {
	if x == nil {
		return false
	}
	return x.Local != nil
}

func (x *CommandLineUpstreamService) ClearCommand() {
	x.Command = nil
}

func (x *CommandLineUpstreamService) ClearWorkingDirectory() {
	x.WorkingDirectory = nil
}

func (x *CommandLineUpstreamService) ClearHealthCheck() {
	x.HealthCheck = nil
}

func (x *CommandLineUpstreamService) ClearCache() {
	x.Cache = nil
}

func (x *CommandLineUpstreamService) ClearContainerEnvironment() {
	x.ContainerEnvironment = nil
}

func (x *CommandLineUpstreamService) ClearTimeout() {
	x.Timeout = nil
}

func (x *CommandLineUpstreamService) ClearCommunicationProtocol() {
	x.CommunicationProtocol = nil
}

func (x *CommandLineUpstreamService) ClearLocal() {
	x.Local = nil
}

type CommandLineUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The command to execute the service.
	Command *string
	// The working directory for the command.
	WorkingDirectory *string
	// Manually defined mappings from MCP tools to command line commands.
	Tools []*ToolDefinition
	// Health check configuration.
	HealthCheck *CommandLineHealthCheck
	// Caching configuration to improve performance and reduce load on the upstream.
	Cache *CacheConfig
	// Container environment to run the command in.
	ContainerEnvironment *ContainerEnvironment
	// Timeout for the command execution.
	Timeout *durationpb.Duration
	// A list of resources served by this service.
	Resources []*ResourceDefinition
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*CommandLineCallDefinition
	// A list of prompts served by this service.
	Prompts               []*PromptDefinition
	CommunicationProtocol *CommandLineUpstreamService_CommunicationProtocol
	// If true, the command will be executed on the local filesystem.
	Local *bool
	// Environment variables to set for the command (supports secrets).
	Env map[string]*SecretValue
}

func (b0 CommandLineUpstreamService_builder) Build() *CommandLineUpstreamService {
	m0 := &CommandLineUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Command = b.Command
	x.WorkingDirectory = b.WorkingDirectory
	x.Tools = b.Tools
	x.HealthCheck = b.HealthCheck
	x.Cache = b.Cache
	x.ContainerEnvironment = b.ContainerEnvironment
	x.Timeout = b.Timeout
	x.Resources = b.Resources
	x.Calls = b.Calls
	x.Prompts = b.Prompts
	x.CommunicationProtocol = b.CommunicationProtocol
	x.Local = b.Local
	x.Env = b.Env
	return m0
}

// GraphQLUpstreamService defines an upstream service that speaks GraphQL.
type GraphQLUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The URL of the GraphQL endpoint (e.g., "http://api.example.com/graphql").
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls         map[string]*GraphQLCallDefinition `protobuf:"bytes,2,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GraphQLUpstreamService) Reset() {
	*x = GraphQLUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GraphQLUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphQLUpstreamService) ProtoMessage() {}

func (x *GraphQLUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *GraphQLUpstreamService) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *GraphQLUpstreamService) GetCalls() map[string]*GraphQLCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *GraphQLUpstreamService) SetAddress(v string) {
	x.Address = &v
}

func (x *GraphQLUpstreamService) SetCalls(v map[string]*GraphQLCallDefinition) {
	x.Calls = v
}

func (x *GraphQLUpstreamService) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *GraphQLUpstreamService) ClearAddress() {
	x.Address = nil
}

type GraphQLUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The URL of the GraphQL endpoint (e.g., "http://api.example.com/graphql").
	Address *string
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*GraphQLCallDefinition
}

func (b0 GraphQLUpstreamService_builder) Build() *GraphQLUpstreamService {
	m0 := &GraphQLUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.Calls = b.Calls
	return m0
}

// SqlUpstreamService defines an upstream service that speaks SQL.
type SqlUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The driver name (e.g., "postgres", "mysql", "sqlite").
	Driver *string `protobuf:"bytes,1,opt,name=driver" json:"driver,omitempty"`
	// The data source name (DSN) for connecting to the database.
	Dsn *string `protobuf:"bytes,2,opt,name=dsn" json:"dsn,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls         map[string]*SqlCallDefinition `protobuf:"bytes,3,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SqlUpstreamService) Reset() {
	*x = SqlUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SqlUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SqlUpstreamService) ProtoMessage() {}

func (x *SqlUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SqlUpstreamService) GetDriver() string {
	if x != nil && x.Driver != nil {
		return *x.Driver
	}
	return ""
}

func (x *SqlUpstreamService) GetDsn() string {
	if x != nil && x.Dsn != nil {
		return *x.Dsn
	}
	return ""
}

func (x *SqlUpstreamService) GetCalls() map[string]*SqlCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *SqlUpstreamService) SetDriver(v string) {
	x.Driver = &v
}

func (x *SqlUpstreamService) SetDsn(v string) {
	x.Dsn = &v
}

func (x *SqlUpstreamService) SetCalls(v map[string]*SqlCallDefinition) {
	x.Calls = v
}

func (x *SqlUpstreamService) HasDriver() bool {
	if x == nil {
		return false
	}
	return x.Driver != nil
}

func (x *SqlUpstreamService) HasDsn() bool {
	if x == nil {
		return false
	}
	return x.Dsn != nil
}

func (x *SqlUpstreamService) ClearDriver() {
	x.Driver = nil
}

func (x *SqlUpstreamService) ClearDsn() {
	x.Dsn = nil
}

type SqlUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The driver name (e.g., "postgres", "mysql", "sqlite").
	Driver *string
	// The data source name (DSN) for connecting to the database.
	Dsn *string
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*SqlCallDefinition
}

func (b0 SqlUpstreamService_builder) Build() *SqlUpstreamService {
	m0 := &SqlUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.Driver = b.Driver
	x.Dsn = b.Dsn
	x.Calls = b.Calls
	return m0
}

// FilesystemUpstreamService defines a service that exposes a local filesystem safely.
type FilesystemUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The root directories that are allowed to be accessed.
	// The key is the virtual path (how it appears to the LLM) and the value is the actual local path.
	// Example: {"/workspace": "/home/user/projects/myproject"}
	RootPaths map[string]string `protobuf:"bytes,1,rep,name=root_paths" json:"root_paths,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If true, file operations are read-only.
	ReadOnly *bool `protobuf:"varint,2,opt,name=read_only" json:"read_only,omitempty"`
	// Manually defined mappings (usually not needed as we auto-register FS tools).
	Tools []*ToolDefinition `protobuf:"bytes,3,rep,name=tools" json:"tools,omitempty"`
	// Resources (files) that are statically or dynamically exposed.
	Resources []*ResourceDefinition `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	// Prompts that are exposed.
	Prompts []*PromptDefinition `protobuf:"bytes,5,rep,name=prompts" json:"prompts,omitempty"`
	// The specific configuration for the filesystem type.
	//
	// Types that are valid to be assigned to FilesystemType:
	//
	//	*FilesystemUpstreamService_Os
	//	*FilesystemUpstreamService_Tmpfs
	//	*FilesystemUpstreamService_Http
	//	*FilesystemUpstreamService_Zip
	//	*FilesystemUpstreamService_Gcs
	//	*FilesystemUpstreamService_Sftp
	FilesystemType isFilesystemUpstreamService_FilesystemType `protobuf_oneof:"filesystem_type"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FilesystemUpstreamService) Reset() {
	*x = FilesystemUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FilesystemUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilesystemUpstreamService) ProtoMessage() {}

func (x *FilesystemUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *FilesystemUpstreamService) GetRootPaths() map[string]string {
	if x != nil {
		return x.RootPaths
	}
	return nil
}

func (x *FilesystemUpstreamService) GetReadOnly() bool {
	if x != nil && x.ReadOnly != nil {
		return *x.ReadOnly
	}
	return false
}

func (x *FilesystemUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *FilesystemUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *FilesystemUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *FilesystemUpstreamService) GetFilesystemType() isFilesystemUpstreamService_FilesystemType {
	if x != nil {
		return x.FilesystemType
	}
	return nil
}

func (x *FilesystemUpstreamService) GetOs() *OsFs {
	if x != nil {
		if x, ok := x.FilesystemType.(*FilesystemUpstreamService_Os); ok {
			return x.Os
		}
	}
	return nil
}

func (x *FilesystemUpstreamService) GetTmpfs() *MemMapFs {
	if x != nil {
		if x, ok := x.FilesystemType.(*FilesystemUpstreamService_Tmpfs); ok {
			return x.Tmpfs
		}
	}
	return nil
}

func (x *FilesystemUpstreamService) GetHttp() *HttpFs {
	if x != nil {
		if x, ok := x.FilesystemType.(*FilesystemUpstreamService_Http); ok {
			return x.Http
		}
	}
	return nil
}

func (x *FilesystemUpstreamService) GetZip() *ZipFs {
	if x != nil {
		if x, ok := x.FilesystemType.(*FilesystemUpstreamService_Zip); ok {
			return x.Zip
		}
	}
	return nil
}

func (x *FilesystemUpstreamService) GetGcs() *GcsFs {
	if x != nil {
		if x, ok := x.FilesystemType.(*FilesystemUpstreamService_Gcs); ok {
			return x.Gcs
		}
	}
	return nil
}

func (x *FilesystemUpstreamService) GetSftp() *SftpFs {
	if x != nil {
		if x, ok := x.FilesystemType.(*FilesystemUpstreamService_Sftp); ok {
			return x.Sftp
		}
	}
	return nil
}

func (x *FilesystemUpstreamService) SetRootPaths(v map[string]string) {
	x.RootPaths = v
}

func (x *FilesystemUpstreamService) SetReadOnly(v bool) {
	x.ReadOnly = &v
}

func (x *FilesystemUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *FilesystemUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *FilesystemUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *FilesystemUpstreamService) SetOs(v *OsFs) {
	if v == nil {
		x.FilesystemType = nil
		return
	}
	x.FilesystemType = &FilesystemUpstreamService_Os{v}
}

func (x *FilesystemUpstreamService) SetTmpfs(v *MemMapFs) {
	if v == nil {
		x.FilesystemType = nil
		return
	}
	x.FilesystemType = &FilesystemUpstreamService_Tmpfs{v}
}

func (x *FilesystemUpstreamService) SetHttp(v *HttpFs) {
	if v == nil {
		x.FilesystemType = nil
		return
	}
	x.FilesystemType = &FilesystemUpstreamService_Http{v}
}

func (x *FilesystemUpstreamService) SetZip(v *ZipFs) {
	if v == nil {
		x.FilesystemType = nil
		return
	}
	x.FilesystemType = &FilesystemUpstreamService_Zip{v}
}

func (x *FilesystemUpstreamService) SetGcs(v *GcsFs) {
	if v == nil {
		x.FilesystemType = nil
		return
	}
	x.FilesystemType = &FilesystemUpstreamService_Gcs{v}
}

func (x *FilesystemUpstreamService) SetSftp(v *SftpFs) {
	if v == nil {
		x.FilesystemType = nil
		return
	}
	x.FilesystemType = &FilesystemUpstreamService_Sftp{v}
}

func (x *FilesystemUpstreamService) HasReadOnly() bool {
	if x == nil {
		return false
	}
	return x.ReadOnly != nil
}

func (x *FilesystemUpstreamService) HasFilesystemType() bool {
	if x == nil {
		return false
	}
	return x.FilesystemType != nil
}

func (x *FilesystemUpstreamService) HasOs() bool {
	if x == nil {
		return false
	}
	_, ok := x.FilesystemType.(*FilesystemUpstreamService_Os)
	return ok
}

func (x *FilesystemUpstreamService) HasTmpfs() bool {
	if x == nil {
		return false
	}
	_, ok := x.FilesystemType.(*FilesystemUpstreamService_Tmpfs)
	return ok
}

func (x *FilesystemUpstreamService) HasHttp() bool {
	if x == nil {
		return false
	}
	_, ok := x.FilesystemType.(*FilesystemUpstreamService_Http)
	return ok
}

func (x *FilesystemUpstreamService) HasZip() bool {
	if x == nil {
		return false
	}
	_, ok := x.FilesystemType.(*FilesystemUpstreamService_Zip)
	return ok
}

func (x *FilesystemUpstreamService) HasGcs() bool {
	if x == nil {
		return false
	}
	_, ok := x.FilesystemType.(*FilesystemUpstreamService_Gcs)
	return ok
}

func (x *FilesystemUpstreamService) HasSftp() bool {
	if x == nil {
		return false
	}
	_, ok := x.FilesystemType.(*FilesystemUpstreamService_Sftp)
	return ok
}

func (x *FilesystemUpstreamService) ClearReadOnly() {
	x.ReadOnly = nil
}

func (x *FilesystemUpstreamService) ClearFilesystemType() {
	x.FilesystemType = nil
}

func (x *FilesystemUpstreamService) ClearOs() {
	if _, ok := x.FilesystemType.(*FilesystemUpstreamService_Os); ok {
		x.FilesystemType = nil
	}
}

func (x *FilesystemUpstreamService) ClearTmpfs() {
	if _, ok := x.FilesystemType.(*FilesystemUpstreamService_Tmpfs); ok {
		x.FilesystemType = nil
	}
}

func (x *FilesystemUpstreamService) ClearHttp() {
	if _, ok := x.FilesystemType.(*FilesystemUpstreamService_Http); ok {
		x.FilesystemType = nil
	}
}

func (x *FilesystemUpstreamService) ClearZip() {
	if _, ok := x.FilesystemType.(*FilesystemUpstreamService_Zip); ok {
		x.FilesystemType = nil
	}
}

func (x *FilesystemUpstreamService) ClearGcs() {
	if _, ok := x.FilesystemType.(*FilesystemUpstreamService_Gcs); ok {
		x.FilesystemType = nil
	}
}

func (x *FilesystemUpstreamService) ClearSftp() {
	if _, ok := x.FilesystemType.(*FilesystemUpstreamService_Sftp); ok {
		x.FilesystemType = nil
	}
}

const FilesystemUpstreamService_FilesystemType_not_set_case case_FilesystemUpstreamService_FilesystemType = 0
const FilesystemUpstreamService_Os_case case_FilesystemUpstreamService_FilesystemType = 10
const FilesystemUpstreamService_Tmpfs_case case_FilesystemUpstreamService_FilesystemType = 11
const FilesystemUpstreamService_Http_case case_FilesystemUpstreamService_FilesystemType = 12
const FilesystemUpstreamService_Zip_case case_FilesystemUpstreamService_FilesystemType = 13
const FilesystemUpstreamService_Gcs_case case_FilesystemUpstreamService_FilesystemType = 14
const FilesystemUpstreamService_Sftp_case case_FilesystemUpstreamService_FilesystemType = 15

func (x *FilesystemUpstreamService) WhichFilesystemType() case_FilesystemUpstreamService_FilesystemType {
	if x == nil {
		return FilesystemUpstreamService_FilesystemType_not_set_case
	}
	switch x.FilesystemType.(type) {
	case *FilesystemUpstreamService_Os:
		return FilesystemUpstreamService_Os_case
	case *FilesystemUpstreamService_Tmpfs:
		return FilesystemUpstreamService_Tmpfs_case
	case *FilesystemUpstreamService_Http:
		return FilesystemUpstreamService_Http_case
	case *FilesystemUpstreamService_Zip:
		return FilesystemUpstreamService_Zip_case
	case *FilesystemUpstreamService_Gcs:
		return FilesystemUpstreamService_Gcs_case
	case *FilesystemUpstreamService_Sftp:
		return FilesystemUpstreamService_Sftp_case
	default:
		return FilesystemUpstreamService_FilesystemType_not_set_case
	}
}

type FilesystemUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The root directories that are allowed to be accessed.
	// The key is the virtual path (how it appears to the LLM) and the value is the actual local path.
	// Example: {"/workspace": "/home/user/projects/myproject"}
	RootPaths map[string]string
	// If true, file operations are read-only.
	ReadOnly *bool
	// Manually defined mappings (usually not needed as we auto-register FS tools).
	Tools []*ToolDefinition
	// Resources (files) that are statically or dynamically exposed.
	Resources []*ResourceDefinition
	// Prompts that are exposed.
	Prompts []*PromptDefinition
	// The specific configuration for the filesystem type.

	// Fields of oneof FilesystemType:
	Os    *OsFs
	Tmpfs *MemMapFs
	Http  *HttpFs
	Zip   *ZipFs
	Gcs   *GcsFs
	Sftp  *SftpFs
	// -- end of FilesystemType
}

func (b0 FilesystemUpstreamService_builder) Build() *FilesystemUpstreamService {
	m0 := &FilesystemUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	x.RootPaths = b.RootPaths
	x.ReadOnly = b.ReadOnly
	x.Tools = b.Tools
	x.Resources = b.Resources
	x.Prompts = b.Prompts
	if b.Os != nil {
		x.FilesystemType = &FilesystemUpstreamService_Os{b.Os}
	}
	if b.Tmpfs != nil {
		x.FilesystemType = &FilesystemUpstreamService_Tmpfs{b.Tmpfs}
	}
	if b.Http != nil {
		x.FilesystemType = &FilesystemUpstreamService_Http{b.Http}
	}
	if b.Zip != nil {
		x.FilesystemType = &FilesystemUpstreamService_Zip{b.Zip}
	}
	if b.Gcs != nil {
		x.FilesystemType = &FilesystemUpstreamService_Gcs{b.Gcs}
	}
	if b.Sftp != nil {
		x.FilesystemType = &FilesystemUpstreamService_Sftp{b.Sftp}
	}
	return m0
}

type case_FilesystemUpstreamService_FilesystemType protoreflect.FieldNumber

func (x case_FilesystemUpstreamService_FilesystemType) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[19].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isFilesystemUpstreamService_FilesystemType interface {
	isFilesystemUpstreamService_FilesystemType()
}

type FilesystemUpstreamService_Os struct {
	Os *OsFs `protobuf:"bytes,10,opt,name=os,oneof"`
}

type FilesystemUpstreamService_Tmpfs struct {
	Tmpfs *MemMapFs `protobuf:"bytes,11,opt,name=tmpfs,oneof"`
}

type FilesystemUpstreamService_Http struct {
	Http *HttpFs `protobuf:"bytes,12,opt,name=http,oneof"`
}

type FilesystemUpstreamService_Zip struct {
	Zip *ZipFs `protobuf:"bytes,13,opt,name=zip,oneof"`
}

type FilesystemUpstreamService_Gcs struct {
	Gcs *GcsFs `protobuf:"bytes,14,opt,name=gcs,oneof"`
}

type FilesystemUpstreamService_Sftp struct {
	Sftp *SftpFs `protobuf:"bytes,15,opt,name=sftp,oneof"`
}

func (*FilesystemUpstreamService_Os) isFilesystemUpstreamService_FilesystemType() {}

func (*FilesystemUpstreamService_Tmpfs) isFilesystemUpstreamService_FilesystemType() {}

func (*FilesystemUpstreamService_Http) isFilesystemUpstreamService_FilesystemType() {}

func (*FilesystemUpstreamService_Zip) isFilesystemUpstreamService_FilesystemType() {}

func (*FilesystemUpstreamService_Gcs) isFilesystemUpstreamService_FilesystemType() {}

func (*FilesystemUpstreamService_Sftp) isFilesystemUpstreamService_FilesystemType() {}

type OsFs struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OsFs) Reset() {
	*x = OsFs{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OsFs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OsFs) ProtoMessage() {}

func (x *OsFs) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type OsFs_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 OsFs_builder) Build() *OsFs {
	m0 := &OsFs{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

type MemMapFs struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MemMapFs) Reset() {
	*x = MemMapFs{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MemMapFs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MemMapFs) ProtoMessage() {}

func (x *MemMapFs) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type MemMapFs_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 MemMapFs_builder) Build() *MemMapFs {
	m0 := &MemMapFs{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

type HttpFs struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Endpoint      *string                `protobuf:"bytes,1,opt,name=endpoint" json:"endpoint,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpFs) Reset() {
	*x = HttpFs{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpFs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpFs) ProtoMessage() {}

func (x *HttpFs) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *HttpFs) GetEndpoint() string {
	if x != nil && x.Endpoint != nil {
		return *x.Endpoint
	}
	return ""
}

func (x *HttpFs) SetEndpoint(v string) {
	x.Endpoint = &v
}

func (x *HttpFs) HasEndpoint() bool {
	if x == nil {
		return false
	}
	return x.Endpoint != nil
}

func (x *HttpFs) ClearEndpoint() {
	x.Endpoint = nil
}

type HttpFs_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Endpoint *string
}

func (b0 HttpFs_builder) Build() *HttpFs {
	m0 := &HttpFs{}
	b, x := &b0, m0
	_, _ = b, x
	x.Endpoint = b.Endpoint
	return m0
}

type ZipFs struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	FilePath      *string                `protobuf:"bytes,1,opt,name=file_path,json=filePath" json:"file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZipFs) Reset() {
	*x = ZipFs{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZipFs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZipFs) ProtoMessage() {}

func (x *ZipFs) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ZipFs) GetFilePath() string {
	if x != nil && x.FilePath != nil {
		return *x.FilePath
	}
	return ""
}

func (x *ZipFs) SetFilePath(v string) {
	x.FilePath = &v
}

func (x *ZipFs) HasFilePath() bool {
	if x == nil {
		return false
	}
	return x.FilePath != nil
}

func (x *ZipFs) ClearFilePath() {
	x.FilePath = nil
}

type ZipFs_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	FilePath *string
}

func (b0 ZipFs_builder) Build() *ZipFs {
	m0 := &ZipFs{}
	b, x := &b0, m0
	_, _ = b, x
	x.FilePath = b.FilePath
	return m0
}

type GcsFs struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Bucket        *string                `protobuf:"bytes,1,opt,name=bucket" json:"bucket,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GcsFs) Reset() {
	*x = GcsFs{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GcsFs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GcsFs) ProtoMessage() {}

func (x *GcsFs) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *GcsFs) GetBucket() string {
	if x != nil && x.Bucket != nil {
		return *x.Bucket
	}
	return ""
}

func (x *GcsFs) SetBucket(v string) {
	x.Bucket = &v
}

func (x *GcsFs) HasBucket() bool {
	if x == nil {
		return false
	}
	return x.Bucket != nil
}

func (x *GcsFs) ClearBucket() {
	x.Bucket = nil
}

type GcsFs_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Bucket *string
}

func (b0 GcsFs_builder) Build() *GcsFs {
	m0 := &GcsFs{}
	b, x := &b0, m0
	_, _ = b, x
	x.Bucket = b.Bucket
	return m0
}

type SftpFs struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Address       *string                `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Username      *string                `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	Password      *string                `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	KeyPath       *string                `protobuf:"bytes,4,opt,name=key_path,json=keyPath" json:"key_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SftpFs) Reset() {
	*x = SftpFs{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SftpFs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SftpFs) ProtoMessage() {}

func (x *SftpFs) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SftpFs) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

func (x *SftpFs) GetUsername() string {
	if x != nil && x.Username != nil {
		return *x.Username
	}
	return ""
}

func (x *SftpFs) GetPassword() string {
	if x != nil && x.Password != nil {
		return *x.Password
	}
	return ""
}

func (x *SftpFs) GetKeyPath() string {
	if x != nil && x.KeyPath != nil {
		return *x.KeyPath
	}
	return ""
}

func (x *SftpFs) SetAddress(v string) {
	x.Address = &v
}

func (x *SftpFs) SetUsername(v string) {
	x.Username = &v
}

func (x *SftpFs) SetPassword(v string) {
	x.Password = &v
}

func (x *SftpFs) SetKeyPath(v string) {
	x.KeyPath = &v
}

func (x *SftpFs) HasAddress() bool {
	if x == nil {
		return false
	}
	return x.Address != nil
}

func (x *SftpFs) HasUsername() bool {
	if x == nil {
		return false
	}
	return x.Username != nil
}

func (x *SftpFs) HasPassword() bool {
	if x == nil {
		return false
	}
	return x.Password != nil
}

func (x *SftpFs) HasKeyPath() bool {
	if x == nil {
		return false
	}
	return x.KeyPath != nil
}

func (x *SftpFs) ClearAddress() {
	x.Address = nil
}

func (x *SftpFs) ClearUsername() {
	x.Username = nil
}

func (x *SftpFs) ClearPassword() {
	x.Password = nil
}

func (x *SftpFs) ClearKeyPath() {
	x.KeyPath = nil
}

type SftpFs_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Address  *string
	Username *string
	Password *string
	KeyPath  *string
}

func (b0 SftpFs_builder) Build() *SftpFs {
	m0 := &SftpFs{}
	b, x := &b0, m0
	_, _ = b, x
	x.Address = b.Address
	x.Username = b.Username
	x.Password = b.Password
	x.KeyPath = b.KeyPath
	return m0
}

// McpUpstreamService defines an upstream that is already an MCP-compliant service.
type McpUpstreamService struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The connection details for the upstream MCP service.
	//
	// Types that are valid to be assigned to ConnectionType:
	//
	//	*McpUpstreamService_HttpConnection
	//	*McpUpstreamService_StdioConnection
	//	*McpUpstreamService_BundleConnection
	ConnectionType isMcpUpstreamService_ConnectionType `protobuf_oneof:"connection_type"`
	// If true, mcpany will automatically discover and proxy all tools from the upstream.
	ToolAutoDiscovery *bool `protobuf:"varint,3,opt,name=tool_auto_discovery" json:"tool_auto_discovery,omitempty"`
	// Optional: Overrides or specific configurations for calls discovered from the service.
	Tools []*ToolDefinition `protobuf:"bytes,6,rep,name=tools" json:"tools,omitempty"`
	// A list of resources served by this service.
	Resources []*ResourceDefinition `protobuf:"bytes,7,rep,name=resources" json:"resources,omitempty"`
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*MCPCallDefinition `protobuf:"bytes,8,rep,name=calls" json:"calls,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// A list of prompts served by this service.
	Prompts       []*PromptDefinition `protobuf:"bytes,9,rep,name=prompts" json:"prompts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *McpUpstreamService) Reset() {
	*x = McpUpstreamService{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *McpUpstreamService) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*McpUpstreamService) ProtoMessage() {}

func (x *McpUpstreamService) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *McpUpstreamService) GetConnectionType() isMcpUpstreamService_ConnectionType {
	if x != nil {
		return x.ConnectionType
	}
	return nil
}

func (x *McpUpstreamService) GetHttpConnection() *McpStreamableHttpConnection {
	if x != nil {
		if x, ok := x.ConnectionType.(*McpUpstreamService_HttpConnection); ok {
			return x.HttpConnection
		}
	}
	return nil
}

func (x *McpUpstreamService) GetStdioConnection() *McpStdioConnection {
	if x != nil {
		if x, ok := x.ConnectionType.(*McpUpstreamService_StdioConnection); ok {
			return x.StdioConnection
		}
	}
	return nil
}

func (x *McpUpstreamService) GetBundleConnection() *McpBundleConnection {
	if x != nil {
		if x, ok := x.ConnectionType.(*McpUpstreamService_BundleConnection); ok {
			return x.BundleConnection
		}
	}
	return nil
}

func (x *McpUpstreamService) GetToolAutoDiscovery() bool {
	if x != nil && x.ToolAutoDiscovery != nil {
		return *x.ToolAutoDiscovery
	}
	return false
}

func (x *McpUpstreamService) GetTools() []*ToolDefinition {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *McpUpstreamService) GetResources() []*ResourceDefinition {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *McpUpstreamService) GetCalls() map[string]*MCPCallDefinition {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *McpUpstreamService) GetPrompts() []*PromptDefinition {
	if x != nil {
		return x.Prompts
	}
	return nil
}

func (x *McpUpstreamService) SetHttpConnection(v *McpStreamableHttpConnection) {
	if v == nil {
		x.ConnectionType = nil
		return
	}
	x.ConnectionType = &McpUpstreamService_HttpConnection{v}
}

func (x *McpUpstreamService) SetStdioConnection(v *McpStdioConnection) {
	if v == nil {
		x.ConnectionType = nil
		return
	}
	x.ConnectionType = &McpUpstreamService_StdioConnection{v}
}

func (x *McpUpstreamService) SetBundleConnection(v *McpBundleConnection) {
	if v == nil {
		x.ConnectionType = nil
		return
	}
	x.ConnectionType = &McpUpstreamService_BundleConnection{v}
}

func (x *McpUpstreamService) SetToolAutoDiscovery(v bool) {
	x.ToolAutoDiscovery = &v
}

func (x *McpUpstreamService) SetTools(v []*ToolDefinition) {
	x.Tools = v
}

func (x *McpUpstreamService) SetResources(v []*ResourceDefinition) {
	x.Resources = v
}

func (x *McpUpstreamService) SetCalls(v map[string]*MCPCallDefinition) {
	x.Calls = v
}

func (x *McpUpstreamService) SetPrompts(v []*PromptDefinition) {
	x.Prompts = v
}

func (x *McpUpstreamService) HasConnectionType() bool {
	if x == nil {
		return false
	}
	return x.ConnectionType != nil
}

func (x *McpUpstreamService) HasHttpConnection() bool {
	if x == nil {
		return false
	}
	_, ok := x.ConnectionType.(*McpUpstreamService_HttpConnection)
	return ok
}

func (x *McpUpstreamService) HasStdioConnection() bool {
	if x == nil {
		return false
	}
	_, ok := x.ConnectionType.(*McpUpstreamService_StdioConnection)
	return ok
}

func (x *McpUpstreamService) HasBundleConnection() bool {
	if x == nil {
		return false
	}
	_, ok := x.ConnectionType.(*McpUpstreamService_BundleConnection)
	return ok
}

func (x *McpUpstreamService) HasToolAutoDiscovery() bool {
	if x == nil {
		return false
	}
	return x.ToolAutoDiscovery != nil
}

func (x *McpUpstreamService) ClearConnectionType() {
	x.ConnectionType = nil
}

func (x *McpUpstreamService) ClearHttpConnection() {
	if _, ok := x.ConnectionType.(*McpUpstreamService_HttpConnection); ok {
		x.ConnectionType = nil
	}
}

func (x *McpUpstreamService) ClearStdioConnection() {
	if _, ok := x.ConnectionType.(*McpUpstreamService_StdioConnection); ok {
		x.ConnectionType = nil
	}
}

func (x *McpUpstreamService) ClearBundleConnection() {
	if _, ok := x.ConnectionType.(*McpUpstreamService_BundleConnection); ok {
		x.ConnectionType = nil
	}
}

func (x *McpUpstreamService) ClearToolAutoDiscovery() {
	x.ToolAutoDiscovery = nil
}

const McpUpstreamService_ConnectionType_not_set_case case_McpUpstreamService_ConnectionType = 0
const McpUpstreamService_HttpConnection_case case_McpUpstreamService_ConnectionType = 1
const McpUpstreamService_StdioConnection_case case_McpUpstreamService_ConnectionType = 2
const McpUpstreamService_BundleConnection_case case_McpUpstreamService_ConnectionType = 4

func (x *McpUpstreamService) WhichConnectionType() case_McpUpstreamService_ConnectionType {
	if x == nil {
		return McpUpstreamService_ConnectionType_not_set_case
	}
	switch x.ConnectionType.(type) {
	case *McpUpstreamService_HttpConnection:
		return McpUpstreamService_HttpConnection_case
	case *McpUpstreamService_StdioConnection:
		return McpUpstreamService_StdioConnection_case
	case *McpUpstreamService_BundleConnection:
		return McpUpstreamService_BundleConnection_case
	default:
		return McpUpstreamService_ConnectionType_not_set_case
	}
}

type McpUpstreamService_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The connection details for the upstream MCP service.

	// Fields of oneof ConnectionType:
	HttpConnection *McpStreamableHttpConnection
	// Connect via a stdio process.
	StdioConnection *McpStdioConnection
	// Connect via a bundle.
	BundleConnection *McpBundleConnection
	// -- end of ConnectionType
	// If true, mcpany will automatically discover and proxy all tools from the upstream.
	ToolAutoDiscovery *bool
	// Optional: Overrides or specific configurations for calls discovered from the service.
	Tools []*ToolDefinition
	// A list of resources served by this service.
	Resources []*ResourceDefinition
	// A map of call definitions, keyed by their unique ID.
	Calls map[string]*MCPCallDefinition
	// A list of prompts served by this service.
	Prompts []*PromptDefinition
}

func (b0 McpUpstreamService_builder) Build() *McpUpstreamService {
	m0 := &McpUpstreamService{}
	b, x := &b0, m0
	_, _ = b, x
	if b.HttpConnection != nil {
		x.ConnectionType = &McpUpstreamService_HttpConnection{b.HttpConnection}
	}
	if b.StdioConnection != nil {
		x.ConnectionType = &McpUpstreamService_StdioConnection{b.StdioConnection}
	}
	if b.BundleConnection != nil {
		x.ConnectionType = &McpUpstreamService_BundleConnection{b.BundleConnection}
	}
	x.ToolAutoDiscovery = b.ToolAutoDiscovery
	x.Tools = b.Tools
	x.Resources = b.Resources
	x.Calls = b.Calls
	x.Prompts = b.Prompts
	return m0
}

type case_McpUpstreamService_ConnectionType protoreflect.FieldNumber

func (x case_McpUpstreamService_ConnectionType) String() string {
	md := file_proto_config_v1_upstream_service_proto_msgTypes[26].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isMcpUpstreamService_ConnectionType interface {
	isMcpUpstreamService_ConnectionType()
}

type McpUpstreamService_HttpConnection struct {
	HttpConnection *McpStreamableHttpConnection `protobuf:"bytes,1,opt,name=http_connection,oneof"`
}

type McpUpstreamService_StdioConnection struct {
	// Connect via a stdio process.
	StdioConnection *McpStdioConnection `protobuf:"bytes,2,opt,name=stdio_connection,oneof"`
}

type McpUpstreamService_BundleConnection struct {
	// Connect via a bundle.
	BundleConnection *McpBundleConnection `protobuf:"bytes,4,opt,name=bundle_connection,oneof"`
}

func (*McpUpstreamService_HttpConnection) isMcpUpstreamService_ConnectionType() {}

func (*McpUpstreamService_StdioConnection) isMcpUpstreamService_ConnectionType() {}

func (*McpUpstreamService_BundleConnection) isMcpUpstreamService_ConnectionType() {}

// McpStdioConnection defines the parameters for a stdio-based connection.
type McpStdioConnection struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The command and arguments to execute the service.
	Command *string  `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	// The working directory for the command.
	WorkingDirectory *string `protobuf:"bytes,3,opt,name=working_directory" json:"working_directory,omitempty"`
	// Optional: The container image to use. If not provided, an image will be
	// selected based on the command.
	ContainerImage *string `protobuf:"bytes,4,opt,name=container_image" json:"container_image,omitempty"`
	// Optional: A list of commands to run as setup before the main command.
	SetupCommands []string `protobuf:"bytes,5,rep,name=setup_commands" json:"setup_commands,omitempty"`
	// Optional: Environment variables to set in the container.
	Env           map[string]*SecretValue `protobuf:"bytes,7,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *McpStdioConnection) Reset() {
	*x = McpStdioConnection{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *McpStdioConnection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*McpStdioConnection) ProtoMessage() {}

func (x *McpStdioConnection) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *McpStdioConnection) GetCommand() string {
	if x != nil && x.Command != nil {
		return *x.Command
	}
	return ""
}

func (x *McpStdioConnection) GetArgs() []string {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *McpStdioConnection) GetWorkingDirectory() string {
	if x != nil && x.WorkingDirectory != nil {
		return *x.WorkingDirectory
	}
	return ""
}

func (x *McpStdioConnection) GetContainerImage() string {
	if x != nil && x.ContainerImage != nil {
		return *x.ContainerImage
	}
	return ""
}

func (x *McpStdioConnection) GetSetupCommands() []string {
	if x != nil {
		return x.SetupCommands
	}
	return nil
}

func (x *McpStdioConnection) GetEnv() map[string]*SecretValue {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *McpStdioConnection) SetCommand(v string) {
	x.Command = &v
}

func (x *McpStdioConnection) SetArgs(v []string) {
	x.Args = v
}

func (x *McpStdioConnection) SetWorkingDirectory(v string) {
	x.WorkingDirectory = &v
}

func (x *McpStdioConnection) SetContainerImage(v string) {
	x.ContainerImage = &v
}

func (x *McpStdioConnection) SetSetupCommands(v []string) {
	x.SetupCommands = v
}

func (x *McpStdioConnection) SetEnv(v map[string]*SecretValue) {
	x.Env = v
}

func (x *McpStdioConnection) HasCommand() bool {
	if x == nil {
		return false
	}
	return x.Command != nil
}

func (x *McpStdioConnection) HasWorkingDirectory() bool {
	if x == nil {
		return false
	}
	return x.WorkingDirectory != nil
}

func (x *McpStdioConnection) HasContainerImage() bool {
	if x == nil {
		return false
	}
	return x.ContainerImage != nil
}

func (x *McpStdioConnection) ClearCommand() {
	x.Command = nil
}

func (x *McpStdioConnection) ClearWorkingDirectory() {
	x.WorkingDirectory = nil
}

func (x *McpStdioConnection) ClearContainerImage() {
	x.ContainerImage = nil
}

type McpStdioConnection_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The command and arguments to execute the service.
	Command *string
	Args    []string
	// The working directory for the command.
	WorkingDirectory *string
	// Optional: The container image to use. If not provided, an image will be
	// selected based on the command.
	ContainerImage *string
	// Optional: A list of commands to run as setup before the main command.
	SetupCommands []string
	// Optional: Environment variables to set in the container.
	Env map[string]*SecretValue
}

func (b0 McpStdioConnection_builder) Build() *McpStdioConnection {
	m0 := &McpStdioConnection{}
	b, x := &b0, m0
	_, _ = b, x
	x.Command = b.Command
	x.Args = b.Args
	x.WorkingDirectory = b.WorkingDirectory
	x.ContainerImage = b.ContainerImage
	x.SetupCommands = b.SetupCommands
	x.Env = b.Env
	return m0
}

type McpStreamableHttpConnection struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Connect via HTTP.
	HttpAddress *string `protobuf:"bytes,1,opt,name=http_address" json:"http_address,omitempty"`
	// TLS configuration, applicable if using an http_address.
	TlsConfig     *TLSConfig `protobuf:"bytes,5,opt,name=tls_config" json:"tls_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *McpStreamableHttpConnection) Reset() {
	*x = McpStreamableHttpConnection{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *McpStreamableHttpConnection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*McpStreamableHttpConnection) ProtoMessage() {}

func (x *McpStreamableHttpConnection) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *McpStreamableHttpConnection) GetHttpAddress() string {
	if x != nil && x.HttpAddress != nil {
		return *x.HttpAddress
	}
	return ""
}

func (x *McpStreamableHttpConnection) GetTlsConfig() *TLSConfig {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

func (x *McpStreamableHttpConnection) SetHttpAddress(v string) {
	x.HttpAddress = &v
}

func (x *McpStreamableHttpConnection) SetTlsConfig(v *TLSConfig) {
	x.TlsConfig = v
}

func (x *McpStreamableHttpConnection) HasHttpAddress() bool {
	if x == nil {
		return false
	}
	return x.HttpAddress != nil
}

func (x *McpStreamableHttpConnection) HasTlsConfig() bool {
	if x == nil {
		return false
	}
	return x.TlsConfig != nil
}

func (x *McpStreamableHttpConnection) ClearHttpAddress() {
	x.HttpAddress = nil
}

func (x *McpStreamableHttpConnection) ClearTlsConfig() {
	x.TlsConfig = nil
}

type McpStreamableHttpConnection_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Connect via HTTP.
	HttpAddress *string
	// TLS configuration, applicable if using an http_address.
	TlsConfig *TLSConfig
}

func (b0 McpStreamableHttpConnection_builder) Build() *McpStreamableHttpConnection {
	m0 := &McpStreamableHttpConnection{}
	b, x := &b0, m0
	_, _ = b, x
	x.HttpAddress = b.HttpAddress
	x.TlsConfig = b.TlsConfig
	return m0
}

// McpBundleConnection defines the parameters for a bundle-based connection.
type McpBundleConnection struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The path to the bundle file.
	BundlePath *string `protobuf:"bytes,1,opt,name=bundle_path" json:"bundle_path,omitempty"`
	// Optional: The container image to use. If not provided, a default image will be used.
	ContainerImage *string `protobuf:"bytes,2,opt,name=container_image" json:"container_image,omitempty"`
	// Optional: Environment variables to pass to the container.
	Env           map[string]*SecretValue `protobuf:"bytes,4,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *McpBundleConnection) Reset() {
	*x = McpBundleConnection{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *McpBundleConnection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*McpBundleConnection) ProtoMessage() {}

func (x *McpBundleConnection) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *McpBundleConnection) GetBundlePath() string {
	if x != nil && x.BundlePath != nil {
		return *x.BundlePath
	}
	return ""
}

func (x *McpBundleConnection) GetContainerImage() string {
	if x != nil && x.ContainerImage != nil {
		return *x.ContainerImage
	}
	return ""
}

func (x *McpBundleConnection) GetEnv() map[string]*SecretValue {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *McpBundleConnection) SetBundlePath(v string) {
	x.BundlePath = &v
}

func (x *McpBundleConnection) SetContainerImage(v string) {
	x.ContainerImage = &v
}

func (x *McpBundleConnection) SetEnv(v map[string]*SecretValue) {
	x.Env = v
}

func (x *McpBundleConnection) HasBundlePath() bool {
	if x == nil {
		return false
	}
	return x.BundlePath != nil
}

func (x *McpBundleConnection) HasContainerImage() bool {
	if x == nil {
		return false
	}
	return x.ContainerImage != nil
}

func (x *McpBundleConnection) ClearBundlePath() {
	x.BundlePath = nil
}

func (x *McpBundleConnection) ClearContainerImage() {
	x.ContainerImage = nil
}

type McpBundleConnection_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The path to the bundle file.
	BundlePath *string
	// Optional: The container image to use. If not provided, a default image will be used.
	ContainerImage *string
	// Optional: Environment variables to pass to the container.
	Env map[string]*SecretValue
}

func (b0 McpBundleConnection_builder) Build() *McpBundleConnection {
	m0 := &McpBundleConnection{}
	b, x := &b0, m0
	_, _ = b, x
	x.BundlePath = b.BundlePath
	x.ContainerImage = b.ContainerImage
	x.Env = b.Env
	return m0
}

// ConnectionPoolConfig defines settings for managing a pool of connections to an upstream service.
type ConnectionPoolConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The maximum number of simultaneous connections to allow to the upstream service.
	MaxConnections *int32 `protobuf:"varint,1,opt,name=max_connections" json:"max_connections,omitempty"`
	// The maximum number of idle connections to keep in the pool.
	MaxIdleConnections *int32 `protobuf:"varint,2,opt,name=max_idle_connections" json:"max_idle_connections,omitempty"`
	// The duration a connection can remain idle in the pool before being closed.
	IdleTimeout   *durationpb.Duration `protobuf:"bytes,3,opt,name=idle_timeout" json:"idle_timeout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectionPoolConfig) Reset() {
	*x = ConnectionPoolConfig{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectionPoolConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectionPoolConfig) ProtoMessage() {}

func (x *ConnectionPoolConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ConnectionPoolConfig) GetMaxConnections() int32 {
	if x != nil && x.MaxConnections != nil {
		return *x.MaxConnections
	}
	return 0
}

func (x *ConnectionPoolConfig) GetMaxIdleConnections() int32 {
	if x != nil && x.MaxIdleConnections != nil {
		return *x.MaxIdleConnections
	}
	return 0
}

func (x *ConnectionPoolConfig) GetIdleTimeout() *durationpb.Duration {
	if x != nil {
		return x.IdleTimeout
	}
	return nil
}

func (x *ConnectionPoolConfig) SetMaxConnections(v int32) {
	x.MaxConnections = &v
}

func (x *ConnectionPoolConfig) SetMaxIdleConnections(v int32) {
	x.MaxIdleConnections = &v
}

func (x *ConnectionPoolConfig) SetIdleTimeout(v *durationpb.Duration) {
	x.IdleTimeout = v
}

func (x *ConnectionPoolConfig) HasMaxConnections() bool {
	if x == nil {
		return false
	}
	return x.MaxConnections != nil
}

func (x *ConnectionPoolConfig) HasMaxIdleConnections() bool {
	if x == nil {
		return false
	}
	return x.MaxIdleConnections != nil
}

func (x *ConnectionPoolConfig) HasIdleTimeout() bool {
	if x == nil {
		return false
	}
	return x.IdleTimeout != nil
}

func (x *ConnectionPoolConfig) ClearMaxConnections() {
	x.MaxConnections = nil
}

func (x *ConnectionPoolConfig) ClearMaxIdleConnections() {
	x.MaxIdleConnections = nil
}

func (x *ConnectionPoolConfig) ClearIdleTimeout() {
	x.IdleTimeout = nil
}

type ConnectionPoolConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The maximum number of simultaneous connections to allow to the upstream service.
	MaxConnections *int32
	// The maximum number of idle connections to keep in the pool.
	MaxIdleConnections *int32
	// The duration a connection can remain idle in the pool before being closed.
	IdleTimeout *durationpb.Duration
}

func (b0 ConnectionPoolConfig_builder) Build() *ConnectionPoolConfig {
	m0 := &ConnectionPoolConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.MaxConnections = b.MaxConnections
	x.MaxIdleConnections = b.MaxIdleConnections
	x.IdleTimeout = b.IdleTimeout
	return m0
}

// Defines the container environment for running a command.
type ContainerEnvironment struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The name of the container.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The image to use for the container.
	Image *string `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	// The volumes to mount into the container, with destination as key and source as value.
	Volumes map[string]string `protobuf:"bytes,3,rep,name=volumes" json:"volumes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Environment variables to set in the container (supports secrets).
	Env           map[string]*SecretValue `protobuf:"bytes,4,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContainerEnvironment) Reset() {
	*x = ContainerEnvironment{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContainerEnvironment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerEnvironment) ProtoMessage() {}

func (x *ContainerEnvironment) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ContainerEnvironment) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ContainerEnvironment) GetImage() string {
	if x != nil && x.Image != nil {
		return *x.Image
	}
	return ""
}

func (x *ContainerEnvironment) GetVolumes() map[string]string {
	if x != nil {
		return x.Volumes
	}
	return nil
}

func (x *ContainerEnvironment) GetEnv() map[string]*SecretValue {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *ContainerEnvironment) SetName(v string) {
	x.Name = &v
}

func (x *ContainerEnvironment) SetImage(v string) {
	x.Image = &v
}

func (x *ContainerEnvironment) SetVolumes(v map[string]string) {
	x.Volumes = v
}

func (x *ContainerEnvironment) SetEnv(v map[string]*SecretValue) {
	x.Env = v
}

func (x *ContainerEnvironment) HasName() bool {
	if x == nil {
		return false
	}
	return x.Name != nil
}

func (x *ContainerEnvironment) HasImage() bool {
	if x == nil {
		return false
	}
	return x.Image != nil
}

func (x *ContainerEnvironment) ClearName() {
	x.Name = nil
}

func (x *ContainerEnvironment) ClearImage() {
	x.Image = nil
}

type ContainerEnvironment_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The name of the container.
	Name *string
	// The image to use for the container.
	Image *string
	// The volumes to mount into the container, with destination as key and source as value.
	Volumes map[string]string
	// Environment variables to set in the container (supports secrets).
	Env map[string]*SecretValue
}

func (b0 ContainerEnvironment_builder) Build() *ContainerEnvironment {
	m0 := &ContainerEnvironment{}
	b, x := &b0, m0
	_, _ = b, x
	x.Name = b.Name
	x.Image = b.Image
	x.Volumes = b.Volumes
	x.Env = b.Env
	return m0
}

// Configuration for rate limiting requests to the upstream service.
type RateLimitConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Whether rate limiting is enabled.
	IsEnabled *bool `protobuf:"varint,1,opt,name=is_enabled" json:"is_enabled,omitempty"`
	// The maximum number of requests allowed per second.
	RequestsPerSecond *float64 `protobuf:"fixed64,2,opt,name=requests_per_second" json:"requests_per_second,omitempty"`
	// The number of requests that can be allowed in a short burst.
	Burst   *int64                   `protobuf:"varint,3,opt,name=burst" json:"burst,omitempty"`
	Storage *RateLimitConfig_Storage `protobuf:"varint,4,opt,name=storage,enum=mcpany.config.v1.RateLimitConfig_Storage" json:"storage,omitempty"`
	// Redis configuration if storage is set to STORAGE_REDIS.
	Redis      *bus.RedisBus               `protobuf:"bytes,5,opt,name=redis" json:"redis,omitempty"`
	KeyBy      *RateLimitConfig_KeyBy      `protobuf:"varint,6,opt,name=key_by,enum=mcpany.config.v1.RateLimitConfig_KeyBy" json:"key_by,omitempty"`
	CostMetric *RateLimitConfig_CostMetric `protobuf:"varint,7,opt,name=cost_metric,enum=mcpany.config.v1.RateLimitConfig_CostMetric" json:"cost_metric,omitempty"`
	// Tool-specific rate limits. Key is the tool name.
	ToolLimits    map[string]*RateLimitConfig `protobuf:"bytes,8,rep,name=tool_limits" json:"tool_limits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimitConfig) Reset() {
	*x = RateLimitConfig{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitConfig) ProtoMessage() {}

func (x *RateLimitConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *RateLimitConfig) GetIsEnabled() bool {
	if x != nil && x.IsEnabled != nil {
		return *x.IsEnabled
	}
	return false
}

func (x *RateLimitConfig) GetRequestsPerSecond() float64 {
	if x != nil && x.RequestsPerSecond != nil {
		return *x.RequestsPerSecond
	}
	return 0
}

func (x *RateLimitConfig) GetBurst() int64 {
	if x != nil && x.Burst != nil {
		return *x.Burst
	}
	return 0
}

func (x *RateLimitConfig) GetStorage() RateLimitConfig_Storage {
	if x != nil && x.Storage != nil {
		return *x.Storage
	}
	return RateLimitConfig_STORAGE_UNSPECIFIED
}

func (x *RateLimitConfig) GetRedis() *bus.RedisBus {
	if x != nil {
		return x.Redis
	}
	return nil
}

func (x *RateLimitConfig) GetKeyBy() RateLimitConfig_KeyBy {
	if x != nil && x.KeyBy != nil {
		return *x.KeyBy
	}
	return RateLimitConfig_KEY_BY_UNSPECIFIED
}

func (x *RateLimitConfig) GetCostMetric() RateLimitConfig_CostMetric {
	if x != nil && x.CostMetric != nil {
		return *x.CostMetric
	}
	return RateLimitConfig_COST_METRIC_REQUESTS
}

func (x *RateLimitConfig) GetToolLimits() map[string]*RateLimitConfig {
	if x != nil {
		return x.ToolLimits
	}
	return nil
}

func (x *RateLimitConfig) SetIsEnabled(v bool) {
	x.IsEnabled = &v
}

func (x *RateLimitConfig) SetRequestsPerSecond(v float64) {
	x.RequestsPerSecond = &v
}

func (x *RateLimitConfig) SetBurst(v int64) {
	x.Burst = &v
}

func (x *RateLimitConfig) SetStorage(v RateLimitConfig_Storage) {
	x.Storage = &v
}

func (x *RateLimitConfig) SetRedis(v *bus.RedisBus) {
	x.Redis = v
}

func (x *RateLimitConfig) SetKeyBy(v RateLimitConfig_KeyBy) {
	x.KeyBy = &v
}

func (x *RateLimitConfig) SetCostMetric(v RateLimitConfig_CostMetric) {
	x.CostMetric = &v
}

func (x *RateLimitConfig) SetToolLimits(v map[string]*RateLimitConfig) {
	x.ToolLimits = v
}

func (x *RateLimitConfig) HasIsEnabled() bool {
	if x == nil {
		return false
	}
	return x.IsEnabled != nil
}

func (x *RateLimitConfig) HasRequestsPerSecond() bool {
	if x == nil {
		return false
	}
	return x.RequestsPerSecond != nil
}

func (x *RateLimitConfig) HasBurst() bool {
	if x == nil {
		return false
	}
	return x.Burst != nil
}

func (x *RateLimitConfig) HasStorage() bool {
	if x == nil {
		return false
	}
	return x.Storage != nil
}

func (x *RateLimitConfig) HasRedis() bool {
	if x == nil {
		return false
	}
	return x.Redis != nil
}

func (x *RateLimitConfig) HasKeyBy() bool {
	if x == nil {
		return false
	}
	return x.KeyBy != nil
}

func (x *RateLimitConfig) HasCostMetric() bool {
	if x == nil {
		return false
	}
	return x.CostMetric != nil
}

func (x *RateLimitConfig) ClearIsEnabled() {
	x.IsEnabled = nil
}

func (x *RateLimitConfig) ClearRequestsPerSecond() {
	x.RequestsPerSecond = nil
}

func (x *RateLimitConfig) ClearBurst() {
	x.Burst = nil
}

func (x *RateLimitConfig) ClearStorage() {
	x.Storage = nil
}

func (x *RateLimitConfig) ClearRedis() {
	x.Redis = nil
}

func (x *RateLimitConfig) ClearKeyBy() {
	x.KeyBy = nil
}

func (x *RateLimitConfig) ClearCostMetric() {
	x.CostMetric = nil
}

type RateLimitConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Whether rate limiting is enabled.
	IsEnabled *bool
	// The maximum number of requests allowed per second.
	RequestsPerSecond *float64
	// The number of requests that can be allowed in a short burst.
	Burst   *int64
	Storage *RateLimitConfig_Storage
	// Redis configuration if storage is set to STORAGE_REDIS.
	Redis      *bus.RedisBus
	KeyBy      *RateLimitConfig_KeyBy
	CostMetric *RateLimitConfig_CostMetric
	// Tool-specific rate limits. Key is the tool name.
	ToolLimits map[string]*RateLimitConfig
}

func (b0 RateLimitConfig_builder) Build() *RateLimitConfig {
	m0 := &RateLimitConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.IsEnabled = b.IsEnabled
	x.RequestsPerSecond = b.RequestsPerSecond
	x.Burst = b.Burst
	x.Storage = b.Storage
	x.Redis = b.Redis
	x.KeyBy = b.KeyBy
	x.CostMetric = b.CostMetric
	x.ToolLimits = b.ToolLimits
	return m0
}

// Configuration for service resilience features like circuit breakers and retries.
type ResilienceConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Circuit breaker configuration to prevent repeated calls to a failing service.
	CircuitBreaker *CircuitBreakerConfig `protobuf:"bytes,1,opt,name=circuit_breaker" json:"circuit_breaker,omitempty"`
	// Retry policy for failed requests.
	RetryPolicy   *RetryConfig `protobuf:"bytes,2,opt,name=retry_policy" json:"retry_policy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResilienceConfig) Reset() {
	*x = ResilienceConfig{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResilienceConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResilienceConfig) ProtoMessage() {}

func (x *ResilienceConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ResilienceConfig) GetCircuitBreaker() *CircuitBreakerConfig {
	if x != nil {
		return x.CircuitBreaker
	}
	return nil
}

func (x *ResilienceConfig) GetRetryPolicy() *RetryConfig {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

func (x *ResilienceConfig) SetCircuitBreaker(v *CircuitBreakerConfig) {
	x.CircuitBreaker = v
}

func (x *ResilienceConfig) SetRetryPolicy(v *RetryConfig) {
	x.RetryPolicy = v
}

func (x *ResilienceConfig) HasCircuitBreaker() bool {
	if x == nil {
		return false
	}
	return x.CircuitBreaker != nil
}

func (x *ResilienceConfig) HasRetryPolicy() bool {
	if x == nil {
		return false
	}
	return x.RetryPolicy != nil
}

func (x *ResilienceConfig) ClearCircuitBreaker() {
	x.CircuitBreaker = nil
}

func (x *ResilienceConfig) ClearRetryPolicy() {
	x.RetryPolicy = nil
}

type ResilienceConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Circuit breaker configuration to prevent repeated calls to a failing service.
	CircuitBreaker *CircuitBreakerConfig
	// Retry policy for failed requests.
	RetryPolicy *RetryConfig
}

func (b0 ResilienceConfig_builder) Build() *ResilienceConfig {
	m0 := &ResilienceConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.CircuitBreaker = b.CircuitBreaker
	x.RetryPolicy = b.RetryPolicy
	return m0
}

// CircuitBreakerConfig defines the parameters for the circuit breaker pattern.
type CircuitBreakerConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// If the failure rate exceeds this threshold, the circuit opens. (e.g., 0.5 for 50%)
	FailureRateThreshold *float64 `protobuf:"fixed64,1,opt,name=failure_rate_threshold" json:"failure_rate_threshold,omitempty"`
	// The number of consecutive failures required to open the circuit.
	ConsecutiveFailures *int32 `protobuf:"varint,2,opt,name=consecutive_failures" json:"consecutive_failures,omitempty"`
	// The duration the circuit remains open before transitioning to half-open.
	OpenDuration *durationpb.Duration `protobuf:"bytes,3,opt,name=open_duration" json:"open_duration,omitempty"`
	// The number of requests to allow in the half-open state to test for recovery.
	HalfOpenRequests *int32 `protobuf:"varint,4,opt,name=half_open_requests" json:"half_open_requests,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *CircuitBreakerConfig) Reset() {
	*x = CircuitBreakerConfig{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CircuitBreakerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircuitBreakerConfig) ProtoMessage() {}

func (x *CircuitBreakerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CircuitBreakerConfig) GetFailureRateThreshold() float64 {
	if x != nil && x.FailureRateThreshold != nil {
		return *x.FailureRateThreshold
	}
	return 0
}

func (x *CircuitBreakerConfig) GetConsecutiveFailures() int32 {
	if x != nil && x.ConsecutiveFailures != nil {
		return *x.ConsecutiveFailures
	}
	return 0
}

func (x *CircuitBreakerConfig) GetOpenDuration() *durationpb.Duration {
	if x != nil {
		return x.OpenDuration
	}
	return nil
}

func (x *CircuitBreakerConfig) GetHalfOpenRequests() int32 {
	if x != nil && x.HalfOpenRequests != nil {
		return *x.HalfOpenRequests
	}
	return 0
}

func (x *CircuitBreakerConfig) SetFailureRateThreshold(v float64) {
	x.FailureRateThreshold = &v
}

func (x *CircuitBreakerConfig) SetConsecutiveFailures(v int32) {
	x.ConsecutiveFailures = &v
}

func (x *CircuitBreakerConfig) SetOpenDuration(v *durationpb.Duration) {
	x.OpenDuration = v
}

func (x *CircuitBreakerConfig) SetHalfOpenRequests(v int32) {
	x.HalfOpenRequests = &v
}

func (x *CircuitBreakerConfig) HasFailureRateThreshold() bool {
	if x == nil {
		return false
	}
	return x.FailureRateThreshold != nil
}

func (x *CircuitBreakerConfig) HasConsecutiveFailures() bool {
	if x == nil {
		return false
	}
	return x.ConsecutiveFailures != nil
}

func (x *CircuitBreakerConfig) HasOpenDuration() bool {
	if x == nil {
		return false
	}
	return x.OpenDuration != nil
}

func (x *CircuitBreakerConfig) HasHalfOpenRequests() bool {
	if x == nil {
		return false
	}
	return x.HalfOpenRequests != nil
}

func (x *CircuitBreakerConfig) ClearFailureRateThreshold() {
	x.FailureRateThreshold = nil
}

func (x *CircuitBreakerConfig) ClearConsecutiveFailures() {
	x.ConsecutiveFailures = nil
}

func (x *CircuitBreakerConfig) ClearOpenDuration() {
	x.OpenDuration = nil
}

func (x *CircuitBreakerConfig) ClearHalfOpenRequests() {
	x.HalfOpenRequests = nil
}

type CircuitBreakerConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// If the failure rate exceeds this threshold, the circuit opens. (e.g., 0.5 for 50%)
	FailureRateThreshold *float64
	// The number of consecutive failures required to open the circuit.
	ConsecutiveFailures *int32
	// The duration the circuit remains open before transitioning to half-open.
	OpenDuration *durationpb.Duration
	// The number of requests to allow in the half-open state to test for recovery.
	HalfOpenRequests *int32
}

func (b0 CircuitBreakerConfig_builder) Build() *CircuitBreakerConfig {
	m0 := &CircuitBreakerConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.FailureRateThreshold = b.FailureRateThreshold
	x.ConsecutiveFailures = b.ConsecutiveFailures
	x.OpenDuration = b.OpenDuration
	x.HalfOpenRequests = b.HalfOpenRequests
	return m0
}

// RetryConfig defines the parameters for retrying failed requests.
type RetryConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The number of times to retry a failed request.
	NumberOfRetries *int32 `protobuf:"varint,1,opt,name=number_of_retries" json:"number_of_retries,omitempty"`
	// The base duration for the backoff between retries.
	BaseBackoff *durationpb.Duration `protobuf:"bytes,2,opt,name=base_backoff" json:"base_backoff,omitempty"`
	// The maximum duration for the backoff.
	MaxBackoff *durationpb.Duration `protobuf:"bytes,3,opt,name=max_backoff" json:"max_backoff,omitempty"`
	// The maximum total time to spend retrying.
	MaxElapsedTime *durationpb.Duration `protobuf:"bytes,4,opt,name=max_elapsed_time" json:"max_elapsed_time,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RetryConfig) Reset() {
	*x = RetryConfig{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetryConfig) ProtoMessage() {}

func (x *RetryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *RetryConfig) GetNumberOfRetries() int32 {
	if x != nil && x.NumberOfRetries != nil {
		return *x.NumberOfRetries
	}
	return 0
}

func (x *RetryConfig) GetBaseBackoff() *durationpb.Duration {
	if x != nil {
		return x.BaseBackoff
	}
	return nil
}

func (x *RetryConfig) GetMaxBackoff() *durationpb.Duration {
	if x != nil {
		return x.MaxBackoff
	}
	return nil
}

func (x *RetryConfig) GetMaxElapsedTime() *durationpb.Duration {
	if x != nil {
		return x.MaxElapsedTime
	}
	return nil
}

func (x *RetryConfig) SetNumberOfRetries(v int32) {
	x.NumberOfRetries = &v
}

func (x *RetryConfig) SetBaseBackoff(v *durationpb.Duration) {
	x.BaseBackoff = v
}

func (x *RetryConfig) SetMaxBackoff(v *durationpb.Duration) {
	x.MaxBackoff = v
}

func (x *RetryConfig) SetMaxElapsedTime(v *durationpb.Duration) {
	x.MaxElapsedTime = v
}

func (x *RetryConfig) HasNumberOfRetries() bool {
	if x == nil {
		return false
	}
	return x.NumberOfRetries != nil
}

func (x *RetryConfig) HasBaseBackoff() bool {
	if x == nil {
		return false
	}
	return x.BaseBackoff != nil
}

func (x *RetryConfig) HasMaxBackoff() bool {
	if x == nil {
		return false
	}
	return x.MaxBackoff != nil
}

func (x *RetryConfig) HasMaxElapsedTime() bool {
	if x == nil {
		return false
	}
	return x.MaxElapsedTime != nil
}

func (x *RetryConfig) ClearNumberOfRetries() {
	x.NumberOfRetries = nil
}

func (x *RetryConfig) ClearBaseBackoff() {
	x.BaseBackoff = nil
}

func (x *RetryConfig) ClearMaxBackoff() {
	x.MaxBackoff = nil
}

func (x *RetryConfig) ClearMaxElapsedTime() {
	x.MaxElapsedTime = nil
}

type RetryConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The number of times to retry a failed request.
	NumberOfRetries *int32
	// The base duration for the backoff between retries.
	BaseBackoff *durationpb.Duration
	// The maximum duration for the backoff.
	MaxBackoff *durationpb.Duration
	// The maximum total time to spend retrying.
	MaxElapsedTime *durationpb.Duration
}

func (b0 RetryConfig_builder) Build() *RetryConfig {
	m0 := &RetryConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.NumberOfRetries = b.NumberOfRetries
	x.BaseBackoff = b.BaseBackoff
	x.MaxBackoff = b.MaxBackoff
	x.MaxElapsedTime = b.MaxElapsedTime
	return m0
}

// TLSConfig defines the TLS settings for connecting to an upstream service.
type TLSConfig struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The server name to use for SNI.
	ServerName *string `protobuf:"bytes,1,opt,name=server_name" json:"server_name,omitempty"`
	// Path to the CA certificate file for verifying the server's certificate.
	CaCertPath *string `protobuf:"bytes,2,opt,name=ca_cert_path" json:"ca_cert_path,omitempty"`
	// Path to the client certificate file for mTLS.
	ClientCertPath *string `protobuf:"bytes,3,opt,name=client_cert_path" json:"client_cert_path,omitempty"`
	// Path to the client private key file for mTLS.
	ClientKeyPath *string `protobuf:"bytes,4,opt,name=client_key_path" json:"client_key_path,omitempty"`
	// If true, the client will not verify the server's certificate chain. Use with caution.
	InsecureSkipVerify *bool `protobuf:"varint,5,opt,name=insecure_skip_verify" json:"insecure_skip_verify,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *TLSConfig) Reset() {
	*x = TLSConfig{}
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TLSConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TLSConfig) ProtoMessage() {}

func (x *TLSConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_v1_upstream_service_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TLSConfig) GetServerName() string {
	if x != nil && x.ServerName != nil {
		return *x.ServerName
	}
	return ""
}

func (x *TLSConfig) GetCaCertPath() string {
	if x != nil && x.CaCertPath != nil {
		return *x.CaCertPath
	}
	return ""
}

func (x *TLSConfig) GetClientCertPath() string {
	if x != nil && x.ClientCertPath != nil {
		return *x.ClientCertPath
	}
	return ""
}

func (x *TLSConfig) GetClientKeyPath() string {
	if x != nil && x.ClientKeyPath != nil {
		return *x.ClientKeyPath
	}
	return ""
}

func (x *TLSConfig) GetInsecureSkipVerify() bool {
	if x != nil && x.InsecureSkipVerify != nil {
		return *x.InsecureSkipVerify
	}
	return false
}

func (x *TLSConfig) SetServerName(v string) {
	x.ServerName = &v
}

func (x *TLSConfig) SetCaCertPath(v string) {
	x.CaCertPath = &v
}

func (x *TLSConfig) SetClientCertPath(v string) {
	x.ClientCertPath = &v
}

func (x *TLSConfig) SetClientKeyPath(v string) {
	x.ClientKeyPath = &v
}

func (x *TLSConfig) SetInsecureSkipVerify(v bool) {
	x.InsecureSkipVerify = &v
}

func (x *TLSConfig) HasServerName() bool {
	if x == nil {
		return false
	}
	return x.ServerName != nil
}

func (x *TLSConfig) HasCaCertPath() bool {
	if x == nil {
		return false
	}
	return x.CaCertPath != nil
}

func (x *TLSConfig) HasClientCertPath() bool {
	if x == nil {
		return false
	}
	return x.ClientCertPath != nil
}

func (x *TLSConfig) HasClientKeyPath() bool {
	if x == nil {
		return false
	}
	return x.ClientKeyPath != nil
}

func (x *TLSConfig) HasInsecureSkipVerify() bool {
	if x == nil {
		return false
	}
	return x.InsecureSkipVerify != nil
}

func (x *TLSConfig) ClearServerName() {
	x.ServerName = nil
}

func (x *TLSConfig) ClearCaCertPath() {
	x.CaCertPath = nil
}

func (x *TLSConfig) ClearClientCertPath() {
	x.ClientCertPath = nil
}

func (x *TLSConfig) ClearClientKeyPath() {
	x.ClientKeyPath = nil
}

func (x *TLSConfig) ClearInsecureSkipVerify() {
	x.InsecureSkipVerify = nil
}

type TLSConfig_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The server name to use for SNI.
	ServerName *string
	// Path to the CA certificate file for verifying the server's certificate.
	CaCertPath *string
	// Path to the client certificate file for mTLS.
	ClientCertPath *string
	// Path to the client private key file for mTLS.
	ClientKeyPath *string
	// If true, the client will not verify the server's certificate chain. Use with caution.
	InsecureSkipVerify *bool
}

func (b0 TLSConfig_builder) Build() *TLSConfig {
	m0 := &TLSConfig{}
	b, x := &b0, m0
	_, _ = b, x
	x.ServerName = b.ServerName
	x.CaCertPath = b.CaCertPath
	x.ClientCertPath = b.ClientCertPath
	x.ClientKeyPath = b.ClientKeyPath
	x.InsecureSkipVerify = b.InsecureSkipVerify
	return m0
}

var File_proto_config_v1_upstream_service_proto protoreflect.FileDescriptor

const file_proto_config_v1_upstream_service_proto_rawDesc = "" +
	"\n" +
	"&proto/config/v1/upstream_service.proto\x12\x10mcpany.config.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x13proto/bus/bus.proto\x1a\x1aproto/config/v1/auth.proto\x1a\x1aproto/config/v1/call.proto\x1a\"proto/config/v1/health_check.proto\x1a\x1dproto/config/v1/profile.proto\x1a\x1cproto/config/v1/prompt.proto\x1a\x1eproto/config/v1/resource.proto\x1a\x1aproto/config/v1/tool.proto\x1a\x1dproto/config/v1/webhook.proto\"\xb9\x01\n" +
	"\x19UpstreamServiceCollection\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\bhttp_url\x18\x02 \x01(\tR\bhttp_url\x12\x1a\n" +
	"\bpriority\x18\x03 \x01(\x05R\bpriority\x12P\n" +
	"\x0eauthentication\x18\x04 \x01(\v2(.mcpany.config.v1.UpstreamAuthenticationR\x0eauthentication\"\xee\x12\n" +
	"\x15UpstreamServiceConfig\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12&\n" +
	"\x0esanitized_name\x18\x12 \x01(\tR\x0esanitized_name\x12P\n" +
	"\x0fconnection_pool\x18\x03 \x01(\v2&.mcpany.config.v1.ConnectionPoolConfigR\x0fconnection_pool\x12b\n" +
	"\x17upstream_authentication\x18\x04 \x01(\v2(.mcpany.config.v1.UpstreamAuthenticationR\x17upstream_authentication\x123\n" +
	"\x05cache\x18\x05 \x01(\v2\x1d.mcpany.config.v1.CacheConfigR\x05cache\x12A\n" +
	"\n" +
	"rate_limit\x18\x06 \x01(\v2!.mcpany.config.v1.RateLimitConfigR\n" +
	"rate_limit\x12a\n" +
	"\x17load_balancing_strategy\x18\a \x01(\x0e2'.mcpany.config.v1.LoadBalancingStrategyR\x17load_balancing_strategy\x12B\n" +
	"\n" +
	"resilience\x18\b \x01(\v2\".mcpany.config.v1.ResilienceConfigR\n" +
	"resilience\x12H\n" +
	"\vmcp_service\x18\t \x01(\v2$.mcpany.config.v1.McpUpstreamServiceH\x00R\vmcp_service\x12K\n" +
	"\fhttp_service\x18\n" +
	" \x01(\v2%.mcpany.config.v1.HttpUpstreamServiceH\x00R\fhttp_service\x12K\n" +
	"\fgrpc_service\x18\v \x01(\v2%.mcpany.config.v1.GrpcUpstreamServiceH\x00R\fgrpc_service\x12T\n" +
	"\x0fopenapi_service\x18\f \x01(\v2(.mcpany.config.v1.OpenapiUpstreamServiceH\x00R\x0fopenapi_service\x12b\n" +
	"\x14command_line_service\x18\r \x01(\v2,.mcpany.config.v1.CommandLineUpstreamServiceH\x00R\x14command_line_service\x12Z\n" +
	"\x11websocket_service\x18\x10 \x01(\v2*.mcpany.config.v1.WebsocketUpstreamServiceH\x00R\x11websocket_service\x12Q\n" +
	"\x0ewebrtc_service\x18\x11 \x01(\v2'.mcpany.config.v1.WebrtcUpstreamServiceH\x00R\x0ewebrtc_service\x12T\n" +
	"\x0fgraphql_service\x18\x15 \x01(\v2(.mcpany.config.v1.GraphQLUpstreamServiceH\x00R\x0fgraphql_service\x12H\n" +
	"\vsql_service\x18\x1f \x01(\v2$.mcpany.config.v1.SqlUpstreamServiceH\x00R\vsql_service\x12]\n" +
	"\x12filesystem_service\x18  \x01(\v2+.mcpany.config.v1.FilesystemUpstreamServiceH\x00R\x12filesystem_service\x12\x18\n" +
	"\aversion\x18\x0e \x01(\tR\aversion\x12N\n" +
	"\x0eauthentication\x18\x0f \x01(\v2&.mcpany.config.v1.AuthenticationConfigR\x0eauthentication\x12\x18\n" +
	"\adisable\x18\x13 \x01(\bR\adisable\x12\x1a\n" +
	"\bpriority\x18\x14 \x01(\x05R\bpriority\x12B\n" +
	"\rcall_policies\x18\x16 \x03(\v2\x1c.mcpany.config.v1.CallPolicyR\rcall_policies\x12B\n" +
	"\x0epre_call_hooks\x18\x17 \x03(\v2\x1a.mcpany.config.v1.CallHookR\x0epre_call_hooks\x12D\n" +
	"\x0fpost_call_hooks\x18\x18 \x03(\v2\x1a.mcpany.config.v1.CallHookR\x0fpost_call_hooks\x125\n" +
	"\bprofiles\x18\x19 \x03(\v2\x19.mcpany.config.v1.ProfileR\bprofiles\x12<\n" +
	"\aprompts\x18\x1a \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x12N\n" +
	"\x12tool_export_policy\x18\x1b \x01(\v2\x1e.mcpany.config.v1.ExportPolicyR\x12tool_export_policy\x12R\n" +
	"\x14prompt_export_policy\x18\x1c \x01(\v2\x1e.mcpany.config.v1.ExportPolicyR\x14prompt_export_policy\x12V\n" +
	"\x16resource_export_policy\x18\x1d \x01(\v2\x1e.mcpany.config.v1.ExportPolicyR\x16resource_export_policy\x12.\n" +
	"\x12auto_discover_tool\x18\x1e \x01(\bR\x12auto_discover_tool\x12b\n" +
	"\x0eprofile_limits\x18! \x03(\v2:.mcpany.config.v1.UpstreamServiceConfig.ProfileLimitsEntryR\x0eprofile_limits\x1ac\n" +
	"\x12ProfileLimitsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x127\n" +
	"\x05value\x18\x02 \x01(\v2!.mcpany.config.v1.RateLimitConfigR\x05value:\x028\x01B\x10\n" +
	"\x0eservice_config\"\xd1\x01\n" +
	"\n" +
	"CallPolicy\x12J\n" +
	"\x0edefault_action\x18\x01 \x01(\x0e2#.mcpany.config.v1.CallPolicy.ActionR\rdefaultAction\x126\n" +
	"\x05rules\x18\x02 \x03(\v2 .mcpany.config.v1.CallPolicyRuleR\x05rules\"?\n" +
	"\x06Action\x12\t\n" +
	"\x05ALLOW\x10\x00\x12\b\n" +
	"\x04DENY\x10\x01\x12\x0e\n" +
	"\n" +
	"SAVE_CACHE\x10\x02\x12\x10\n" +
	"\fDELETE_CACHE\x10\x03\"\xd8\x01\n" +
	"\x0eCallPolicyRule\x12;\n" +
	"\x06action\x18\x01 \x01(\x0e2#.mcpany.config.v1.CallPolicy.ActionR\x06action\x12\x1e\n" +
	"\n" +
	"name_regex\x18\x02 \x01(\tR\n" +
	"name_regex\x12%\n" +
	"\x0eargument_regex\x18\x03 \x01(\tR\rargumentRegex\x12\x1c\n" +
	"\turl_regex\x18\x04 \x01(\tR\turl_regex\x12$\n" +
	"\rcall_id_regex\x18\x05 \x01(\tR\rcall_id_regex\"\xd3\x01\n" +
	"\fExportPolicy\x12L\n" +
	"\x0edefault_action\x18\x01 \x01(\x0e2%.mcpany.config.v1.ExportPolicy.ActionR\rdefaultAction\x122\n" +
	"\x05rules\x18\x02 \x03(\v2\x1c.mcpany.config.v1.ExportRuleR\x05rules\"A\n" +
	"\x06Action\x12\x1d\n" +
	"\x19EXPORT_ACTION_UNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06EXPORT\x10\x01\x12\f\n" +
	"\bUNEXPORT\x10\x02\"k\n" +
	"\n" +
	"ExportRule\x12\x1e\n" +
	"\n" +
	"name_regex\x18\x01 \x01(\tR\n" +
	"name_regex\x12=\n" +
	"\x06action\x18\x02 \x01(\x0e2%.mcpany.config.v1.ExportPolicy.ActionR\x06action\"\xab\x01\n" +
	"\bCallHook\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12;\n" +
	"\awebhook\x18\x02 \x01(\v2\x1f.mcpany.config.v1.WebhookConfigH\x00R\awebhook\x12?\n" +
	"\vcall_policy\x18\x04 \x01(\v2\x1c.mcpany.config.v1.CallPolicyH\x00R\n" +
	"callPolicyB\r\n" +
	"\vhook_config\"\xdd\x05\n" +
	"\x13GrpcUpstreamService\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12&\n" +
	"\x0euse_reflection\x18\x02 \x01(\bR\x0euse_reflection\x12;\n" +
	"\n" +
	"tls_config\x18\x03 \x01(\v2\x1b.mcpany.config.v1.TLSConfigR\n" +
	"tls_config\x126\n" +
	"\x05tools\x18\x04 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12E\n" +
	"\fhealth_check\x18\x05 \x01(\v2!.mcpany.config.v1.GrpcHealthCheckR\fhealth_check\x12O\n" +
	"\x11proto_definitions\x18\x06 \x03(\v2!.mcpany.config.v1.ProtoDefinitionR\x11proto_definitions\x12M\n" +
	"\x10proto_collection\x18\a \x03(\v2!.mcpany.config.v1.ProtoCollectionR\x10proto_collection\x12B\n" +
	"\tresources\x18\b \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12F\n" +
	"\x05calls\x18\t \x03(\v20.mcpany.config.v1.GrpcUpstreamService.CallsEntryR\x05calls\x12<\n" +
	"\aprompts\x18\x13 \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x1a^\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12:\n" +
	"\x05value\x18\x02 \x01(\v2$.mcpany.config.v1.GrpcCallDefinitionR\x05value:\x028\x01\"\xae\x01\n" +
	"\x0fProtoDefinition\x12=\n" +
	"\n" +
	"proto_file\x18\x01 \x01(\v2\x1b.mcpany.config.v1.ProtoFileH\x00R\n" +
	"proto_file\x12O\n" +
	"\x10proto_descriptor\x18\x02 \x01(\v2!.mcpany.config.v1.ProtoDescriptorH\x00R\x10proto_descriptorB\v\n" +
	"\tproto_ref\"{\n" +
	"\tProtoFile\x12\x1c\n" +
	"\tfile_name\x18\x01 \x01(\tR\tfile_name\x12$\n" +
	"\ffile_content\x18\x02 \x01(\tH\x00R\ffile_content\x12\x1e\n" +
	"\tfile_path\x18\x03 \x01(\tH\x00R\tfile_pathB\n" +
	"\n" +
	"\bfile_ref\"[\n" +
	"\x0fProtoDescriptor\x12\x1c\n" +
	"\tfile_name\x18\x01 \x01(\tR\tfile_name\x12\x1e\n" +
	"\tfile_path\x18\x02 \x01(\tH\x00R\tfile_pathB\n" +
	"\n" +
	"\bfile_ref\"\x7f\n" +
	"\x0fProtoCollection\x12\x1c\n" +
	"\troot_path\x18\x01 \x01(\tR\troot_path\x12*\n" +
	"\x10path_match_regex\x18\x02 \x01(\tR\x10path_match_regex\x12\"\n" +
	"\fis_recursive\x18\x03 \x01(\bR\fis_recursive\"\x95\x04\n" +
	"\x13HttpUpstreamService\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x126\n" +
	"\x05tools\x18\x02 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12F\n" +
	"\x05calls\x18\x06 \x03(\v20.mcpany.config.v1.HttpUpstreamService.CallsEntryR\x05calls\x12E\n" +
	"\fhealth_check\x18\x03 \x01(\v2!.mcpany.config.v1.HttpHealthCheckR\fhealth_check\x12;\n" +
	"\n" +
	"tls_config\x18\x04 \x01(\v2\x1b.mcpany.config.v1.TLSConfigR\n" +
	"tls_config\x12B\n" +
	"\tresources\x18\x05 \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12<\n" +
	"\aprompts\x18\a \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x1a^\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12:\n" +
	"\x05value\x18\x02 \x01(\v2$.mcpany.config.v1.HttpCallDefinitionR\x05value:\x028\x01\"\xa9\x04\n" +
	"\x18WebsocketUpstreamService\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x126\n" +
	"\x05tools\x18\x02 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12;\n" +
	"\n" +
	"tls_config\x18\x03 \x01(\v2\x1b.mcpany.config.v1.TLSConfigR\n" +
	"tls_config\x12B\n" +
	"\tresources\x18\x04 \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12K\n" +
	"\x05calls\x18\x05 \x03(\v25.mcpany.config.v1.WebsocketUpstreamService.CallsEntryR\x05calls\x12<\n" +
	"\aprompts\x18\x06 \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x12J\n" +
	"\fhealth_check\x18\a \x01(\v2&.mcpany.config.v1.WebsocketHealthCheckR\fhealth_check\x1ac\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12?\n" +
	"\x05value\x18\x02 \x01(\v2).mcpany.config.v1.WebsocketCallDefinitionR\x05value:\x028\x01\"\x9d\x04\n" +
	"\x15WebrtcUpstreamService\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x126\n" +
	"\x05tools\x18\x02 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12;\n" +
	"\n" +
	"tls_config\x18\x03 \x01(\v2\x1b.mcpany.config.v1.TLSConfigR\n" +
	"tls_config\x12B\n" +
	"\tresources\x18\x04 \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12H\n" +
	"\x05calls\x18\x05 \x03(\v22.mcpany.config.v1.WebrtcUpstreamService.CallsEntryR\x05calls\x12<\n" +
	"\aprompts\x18\x06 \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x12G\n" +
	"\fhealth_check\x18\a \x01(\v2#.mcpany.config.v1.WebRTCHealthCheckR\fhealth_check\x1a`\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12<\n" +
	"\x05value\x18\x02 \x01(\v2&.mcpany.config.v1.WebrtcCallDefinitionR\x05value:\x028\x01\"\xf1\x04\n" +
	"\x16OpenapiUpstreamService\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12$\n" +
	"\fspec_content\x18\x02 \x01(\tH\x00R\fspec_content\x12\x1c\n" +
	"\bspec_url\x18\t \x01(\tH\x00R\bspec_url\x12E\n" +
	"\fhealth_check\x18\x03 \x01(\v2!.mcpany.config.v1.HttpHealthCheckR\fhealth_check\x12;\n" +
	"\n" +
	"tls_config\x18\x04 \x01(\v2\x1b.mcpany.config.v1.TLSConfigR\n" +
	"tls_config\x126\n" +
	"\x05tools\x18\x05 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12B\n" +
	"\tresources\x18\x06 \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12I\n" +
	"\x05calls\x18\a \x03(\v23.mcpany.config.v1.OpenapiUpstreamService.CallsEntryR\x05calls\x12<\n" +
	"\aprompts\x18\b \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x1aa\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.mcpany.config.v1.OpenAPICallDefinitionR\x05value:\x028\x01B\r\n" +
	"\vspec_source\"\xfe\b\n" +
	"\x1aCommandLineUpstreamService\x12\x18\n" +
	"\acommand\x18\x01 \x01(\tR\acommand\x12,\n" +
	"\x11working_directory\x18\x03 \x01(\tR\x11working_directory\x126\n" +
	"\x05tools\x18\x04 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12L\n" +
	"\fhealth_check\x18\x05 \x01(\v2(.mcpany.config.v1.CommandLineHealthCheckR\fhealth_check\x123\n" +
	"\x05cache\x18\x06 \x01(\v2\x1d.mcpany.config.v1.CacheConfigR\x05cache\x12\\\n" +
	"\x15container_environment\x18\a \x01(\v2&.mcpany.config.v1.ContainerEnvironmentR\x15container_environment\x123\n" +
	"\atimeout\x18\b \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12B\n" +
	"\tresources\x18\t \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12M\n" +
	"\x05calls\x18\n" +
	" \x03(\v27.mcpany.config.v1.CommandLineUpstreamService.CallsEntryR\x05calls\x12<\n" +
	"\aprompts\x18\v \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x12z\n" +
	"\x16communication_protocol\x18\f \x01(\x0e2B.mcpany.config.v1.CommandLineUpstreamService.CommunicationProtocolR\x16communication_protocol\x12\x14\n" +
	"\x05local\x18\r \x01(\bR\x05local\x12G\n" +
	"\x03env\x18\x0e \x03(\v25.mcpany.config.v1.CommandLineUpstreamService.EnvEntryR\x03env\x1ae\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12A\n" +
	"\x05value\x18\x02 \x01(\v2+.mcpany.config.v1.CommandLineCallDefinitionR\x05value:\x028\x01\x1aU\n" +
	"\bEnvEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x123\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05value:\x028\x01\"`\n" +
	"\x15CommunicationProtocol\x12&\n" +
	"\"COMMUNICATION_PROTOCOL_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bCOMMUNICATION_PROTOCOL_JSON\x10\x01\"\xe0\x01\n" +
	"\x16GraphQLUpstreamService\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12I\n" +
	"\x05calls\x18\x02 \x03(\v23.mcpany.config.v1.GraphQLUpstreamService.CallsEntryR\x05calls\x1aa\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.mcpany.config.v1.GraphQLCallDefinitionR\x05value:\x028\x01\"\xe4\x01\n" +
	"\x12SqlUpstreamService\x12\x16\n" +
	"\x06driver\x18\x01 \x01(\tR\x06driver\x12\x10\n" +
	"\x03dsn\x18\x02 \x01(\tR\x03dsn\x12E\n" +
	"\x05calls\x18\x03 \x03(\v2/.mcpany.config.v1.SqlUpstreamService.CallsEntryR\x05calls\x1a]\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x129\n" +
	"\x05value\x18\x02 \x01(\v2#.mcpany.config.v1.SqlCallDefinitionR\x05value:\x028\x01\"\xb8\x05\n" +
	"\x19FilesystemUpstreamService\x12Z\n" +
	"\n" +
	"root_paths\x18\x01 \x03(\v2:.mcpany.config.v1.FilesystemUpstreamService.RootPathsEntryR\n" +
	"root_paths\x12\x1c\n" +
	"\tread_only\x18\x02 \x01(\bR\tread_only\x126\n" +
	"\x05tools\x18\x03 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12B\n" +
	"\tresources\x18\x04 \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12<\n" +
	"\aprompts\x18\x05 \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x12(\n" +
	"\x02os\x18\n" +
	" \x01(\v2\x16.mcpany.config.v1.OsFsH\x00R\x02os\x122\n" +
	"\x05tmpfs\x18\v \x01(\v2\x1a.mcpany.config.v1.MemMapFsH\x00R\x05tmpfs\x12.\n" +
	"\x04http\x18\f \x01(\v2\x18.mcpany.config.v1.HttpFsH\x00R\x04http\x12+\n" +
	"\x03zip\x18\r \x01(\v2\x17.mcpany.config.v1.ZipFsH\x00R\x03zip\x12+\n" +
	"\x03gcs\x18\x0e \x01(\v2\x17.mcpany.config.v1.GcsFsH\x00R\x03gcs\x12.\n" +
	"\x04sftp\x18\x0f \x01(\v2\x18.mcpany.config.v1.SftpFsH\x00R\x04sftp\x1a<\n" +
	"\x0eRootPathsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x11\n" +
	"\x0ffilesystem_type\"\x06\n" +
	"\x04OsFs\"\n" +
	"\n" +
	"\bMemMapFs\"$\n" +
	"\x06HttpFs\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\"$\n" +
	"\x05ZipFs\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\"\x1f\n" +
	"\x05GcsFs\x12\x16\n" +
	"\x06bucket\x18\x01 \x01(\tR\x06bucket\"u\n" +
	"\x06SftpFs\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x1a\n" +
	"\busername\x18\x02 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x03 \x01(\tR\bpassword\x12\x19\n" +
	"\bkey_path\x18\x04 \x01(\tR\akeyPath\"\xbf\x05\n" +
	"\x12McpUpstreamService\x12Y\n" +
	"\x0fhttp_connection\x18\x01 \x01(\v2-.mcpany.config.v1.McpStreamableHttpConnectionH\x00R\x0fhttp_connection\x12R\n" +
	"\x10stdio_connection\x18\x02 \x01(\v2$.mcpany.config.v1.McpStdioConnectionH\x00R\x10stdio_connection\x12U\n" +
	"\x11bundle_connection\x18\x04 \x01(\v2%.mcpany.config.v1.McpBundleConnectionH\x00R\x11bundle_connection\x120\n" +
	"\x13tool_auto_discovery\x18\x03 \x01(\bR\x13tool_auto_discovery\x126\n" +
	"\x05tools\x18\x06 \x03(\v2 .mcpany.config.v1.ToolDefinitionR\x05tools\x12B\n" +
	"\tresources\x18\a \x03(\v2$.mcpany.config.v1.ResourceDefinitionR\tresources\x12E\n" +
	"\x05calls\x18\b \x03(\v2/.mcpany.config.v1.McpUpstreamService.CallsEntryR\x05calls\x12<\n" +
	"\aprompts\x18\t \x03(\v2\".mcpany.config.v1.PromptDefinitionR\aprompts\x1a]\n" +
	"\n" +
	"CallsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x129\n" +
	"\x05value\x18\x02 \x01(\v2#.mcpany.config.v1.MCPCallDefinitionR\x05value:\x028\x01B\x11\n" +
	"\x0fconnection_type\"\xe0\x02\n" +
	"\x12McpStdioConnection\x12\x18\n" +
	"\acommand\x18\x01 \x01(\tR\acommand\x12\x12\n" +
	"\x04args\x18\x02 \x03(\tR\x04args\x12,\n" +
	"\x11working_directory\x18\x03 \x01(\tR\x11working_directory\x12(\n" +
	"\x0fcontainer_image\x18\x04 \x01(\tR\x0fcontainer_image\x12&\n" +
	"\x0esetup_commands\x18\x05 \x03(\tR\x0esetup_commands\x12?\n" +
	"\x03env\x18\a \x03(\v2-.mcpany.config.v1.McpStdioConnection.EnvEntryR\x03env\x1aU\n" +
	"\bEnvEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x123\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05value:\x028\x01J\x04\b\x06\x10\a\"~\n" +
	"\x1bMcpStreamableHttpConnection\x12\"\n" +
	"\fhttp_address\x18\x01 \x01(\tR\fhttp_address\x12;\n" +
	"\n" +
	"tls_config\x18\x05 \x01(\v2\x1b.mcpany.config.v1.TLSConfigR\n" +
	"tls_config\"\x80\x02\n" +
	"\x13McpBundleConnection\x12 \n" +
	"\vbundle_path\x18\x01 \x01(\tR\vbundle_path\x12(\n" +
	"\x0fcontainer_image\x18\x02 \x01(\tR\x0fcontainer_image\x12@\n" +
	"\x03env\x18\x04 \x03(\v2..mcpany.config.v1.McpBundleConnection.EnvEntryR\x03env\x1aU\n" +
	"\bEnvEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x123\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05value:\x028\x01J\x04\b\x03\x10\x04\"\xb3\x01\n" +
	"\x14ConnectionPoolConfig\x12(\n" +
	"\x0fmax_connections\x18\x01 \x01(\x05R\x0fmax_connections\x122\n" +
	"\x14max_idle_connections\x18\x02 \x01(\x05R\x14max_idle_connections\x12=\n" +
	"\fidle_timeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\fidle_timeout\"\xe5\x02\n" +
	"\x14ContainerEnvironment\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05image\x18\x02 \x01(\tR\x05image\x12M\n" +
	"\avolumes\x18\x03 \x03(\v23.mcpany.config.v1.ContainerEnvironment.VolumesEntryR\avolumes\x12A\n" +
	"\x03env\x18\x04 \x03(\v2/.mcpany.config.v1.ContainerEnvironment.EnvEntryR\x03env\x1a:\n" +
	"\fVolumesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aU\n" +
	"\bEnvEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x123\n" +
	"\x05value\x18\x02 \x01(\v2\x1d.mcpany.config.v1.SecretValueR\x05value:\x028\x01\"\xa1\x06\n" +
	"\x0fRateLimitConfig\x12\x1e\n" +
	"\n" +
	"is_enabled\x18\x01 \x01(\bR\n" +
	"is_enabled\x120\n" +
	"\x13requests_per_second\x18\x02 \x01(\x01R\x13requests_per_second\x12\x14\n" +
	"\x05burst\x18\x03 \x01(\x03R\x05burst\x12C\n" +
	"\astorage\x18\x04 \x01(\x0e2).mcpany.config.v1.RateLimitConfig.StorageR\astorage\x12#\n" +
	"\x05redis\x18\x05 \x01(\v2\r.bus.RedisBusR\x05redis\x12?\n" +
	"\x06key_by\x18\x06 \x01(\x0e2'.mcpany.config.v1.RateLimitConfig.KeyByR\x06key_by\x12N\n" +
	"\vcost_metric\x18\a \x01(\x0e2,.mcpany.config.v1.RateLimitConfig.CostMetricR\vcost_metric\x12S\n" +
	"\vtool_limits\x18\b \x03(\v21.mcpany.config.v1.RateLimitConfig.ToolLimitsEntryR\vtool_limits\x1a`\n" +
	"\x0fToolLimitsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x127\n" +
	"\x05value\x18\x02 \x01(\v2!.mcpany.config.v1.RateLimitConfigR\x05value:\x028\x01\"I\n" +
	"\aStorage\x12\x17\n" +
	"\x13STORAGE_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eSTORAGE_MEMORY\x10\x01\x12\x11\n" +
	"\rSTORAGE_REDIS\x10\x02\"i\n" +
	"\x05KeyBy\x12\x16\n" +
	"\x12KEY_BY_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rKEY_BY_GLOBAL\x10\x01\x12\r\n" +
	"\tKEY_BY_IP\x10\x02\x12\x12\n" +
	"\x0eKEY_BY_USER_ID\x10\x03\x12\x12\n" +
	"\x0eKEY_BY_API_KEY\x10\x04\">\n" +
	"\n" +
	"CostMetric\x12\x18\n" +
	"\x14COST_METRIC_REQUESTS\x10\x00\x12\x16\n" +
	"\x12COST_METRIC_TOKENS\x10\x01\"\xa7\x01\n" +
	"\x10ResilienceConfig\x12P\n" +
	"\x0fcircuit_breaker\x18\x01 \x01(\v2&.mcpany.config.v1.CircuitBreakerConfigR\x0fcircuit_breaker\x12A\n" +
	"\fretry_policy\x18\x02 \x01(\v2\x1d.mcpany.config.v1.RetryConfigR\fretry_policy\"\xf3\x01\n" +
	"\x14CircuitBreakerConfig\x126\n" +
	"\x16failure_rate_threshold\x18\x01 \x01(\x01R\x16failure_rate_threshold\x122\n" +
	"\x14consecutive_failures\x18\x02 \x01(\x05R\x14consecutive_failures\x12?\n" +
	"\ropen_duration\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\ropen_duration\x12.\n" +
	"\x12half_open_requests\x18\x04 \x01(\x05R\x12half_open_requests\"\xfe\x01\n" +
	"\vRetryConfig\x12,\n" +
	"\x11number_of_retries\x18\x01 \x01(\x05R\x11number_of_retries\x12=\n" +
	"\fbase_backoff\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\fbase_backoff\x12;\n" +
	"\vmax_backoff\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\vmax_backoff\x12E\n" +
	"\x10max_elapsed_time\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x10max_elapsed_time\"\xdb\x01\n" +
	"\tTLSConfig\x12 \n" +
	"\vserver_name\x18\x01 \x01(\tR\vserver_name\x12\"\n" +
	"\fca_cert_path\x18\x02 \x01(\tR\fca_cert_path\x12*\n" +
	"\x10client_cert_path\x18\x03 \x01(\tR\x10client_cert_path\x12(\n" +
	"\x0fclient_key_path\x18\x04 \x01(\tR\x0fclient_key_path\x122\n" +
	"\x14insecure_skip_verify\x18\x05 \x01(\bR\x14insecure_skip_verify*K\n" +
	"\x15LoadBalancingStrategy\x12\x0f\n" +
	"\vROUND_ROBIN\x10\x00\x12\x15\n" +
	"\x11LEAST_CONNECTIONS\x10\x01\x12\n" +
	"\n" +
	"\x06RANDOM\x10\x02B>B\x14UpstreamServiceProtoZ&github.com/mcpany/core/proto/config/v1b\beditionsp\xe8\a"

var file_proto_config_v1_upstream_service_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_proto_config_v1_upstream_service_proto_msgTypes = make([]protoimpl.MessageInfo, 54)
var file_proto_config_v1_upstream_service_proto_goTypes = []any{
	(LoadBalancingStrategy)(0),                            // 0: mcpany.config.v1.LoadBalancingStrategy
	(CallPolicy_Action)(0),                                // 1: mcpany.config.v1.CallPolicy.Action
	(ExportPolicy_Action)(0),                              // 2: mcpany.config.v1.ExportPolicy.Action
	(CommandLineUpstreamService_CommunicationProtocol)(0), // 3: mcpany.config.v1.CommandLineUpstreamService.CommunicationProtocol
	(RateLimitConfig_Storage)(0),                          // 4: mcpany.config.v1.RateLimitConfig.Storage
	(RateLimitConfig_KeyBy)(0),                            // 5: mcpany.config.v1.RateLimitConfig.KeyBy
	(RateLimitConfig_CostMetric)(0),                       // 6: mcpany.config.v1.RateLimitConfig.CostMetric
	(*UpstreamServiceCollection)(nil),                     // 7: mcpany.config.v1.UpstreamServiceCollection
	(*UpstreamServiceConfig)(nil),                         // 8: mcpany.config.v1.UpstreamServiceConfig
	(*CallPolicy)(nil),                                    // 9: mcpany.config.v1.CallPolicy
	(*CallPolicyRule)(nil),                                // 10: mcpany.config.v1.CallPolicyRule
	(*ExportPolicy)(nil),                                  // 11: mcpany.config.v1.ExportPolicy
	(*ExportRule)(nil),                                    // 12: mcpany.config.v1.ExportRule
	(*CallHook)(nil),                                      // 13: mcpany.config.v1.CallHook
	(*GrpcUpstreamService)(nil),                           // 14: mcpany.config.v1.GrpcUpstreamService
	(*ProtoDefinition)(nil),                               // 15: mcpany.config.v1.ProtoDefinition
	(*ProtoFile)(nil),                                     // 16: mcpany.config.v1.ProtoFile
	(*ProtoDescriptor)(nil),                               // 17: mcpany.config.v1.ProtoDescriptor
	(*ProtoCollection)(nil),                               // 18: mcpany.config.v1.ProtoCollection
	(*HttpUpstreamService)(nil),                           // 19: mcpany.config.v1.HttpUpstreamService
	(*WebsocketUpstreamService)(nil),                      // 20: mcpany.config.v1.WebsocketUpstreamService
	(*WebrtcUpstreamService)(nil),                         // 21: mcpany.config.v1.WebrtcUpstreamService
	(*OpenapiUpstreamService)(nil),                        // 22: mcpany.config.v1.OpenapiUpstreamService
	(*CommandLineUpstreamService)(nil),                    // 23: mcpany.config.v1.CommandLineUpstreamService
	(*GraphQLUpstreamService)(nil),                        // 24: mcpany.config.v1.GraphQLUpstreamService
	(*SqlUpstreamService)(nil),                            // 25: mcpany.config.v1.SqlUpstreamService
	(*FilesystemUpstreamService)(nil),                     // 26: mcpany.config.v1.FilesystemUpstreamService
	(*OsFs)(nil),                                          // 27: mcpany.config.v1.OsFs
	(*MemMapFs)(nil),                                      // 28: mcpany.config.v1.MemMapFs
	(*HttpFs)(nil),                                        // 29: mcpany.config.v1.HttpFs
	(*ZipFs)(nil),                                         // 30: mcpany.config.v1.ZipFs
	(*GcsFs)(nil),                                         // 31: mcpany.config.v1.GcsFs
	(*SftpFs)(nil),                                        // 32: mcpany.config.v1.SftpFs
	(*McpUpstreamService)(nil),                            // 33: mcpany.config.v1.McpUpstreamService
	(*McpStdioConnection)(nil),                            // 34: mcpany.config.v1.McpStdioConnection
	(*McpStreamableHttpConnection)(nil),                   // 35: mcpany.config.v1.McpStreamableHttpConnection
	(*McpBundleConnection)(nil),                           // 36: mcpany.config.v1.McpBundleConnection
	(*ConnectionPoolConfig)(nil),                          // 37: mcpany.config.v1.ConnectionPoolConfig
	(*ContainerEnvironment)(nil),                          // 38: mcpany.config.v1.ContainerEnvironment
	(*RateLimitConfig)(nil),                               // 39: mcpany.config.v1.RateLimitConfig
	(*ResilienceConfig)(nil),                              // 40: mcpany.config.v1.ResilienceConfig
	(*CircuitBreakerConfig)(nil),                          // 41: mcpany.config.v1.CircuitBreakerConfig
	(*RetryConfig)(nil),                                   // 42: mcpany.config.v1.RetryConfig
	(*TLSConfig)(nil),                                     // 43: mcpany.config.v1.TLSConfig
	nil,                                                   // 44: mcpany.config.v1.UpstreamServiceConfig.ProfileLimitsEntry
	nil,                                                   // 45: mcpany.config.v1.GrpcUpstreamService.CallsEntry
	nil,                                                   // 46: mcpany.config.v1.HttpUpstreamService.CallsEntry
	nil,                                                   // 47: mcpany.config.v1.WebsocketUpstreamService.CallsEntry
	nil,                                                   // 48: mcpany.config.v1.WebrtcUpstreamService.CallsEntry
	nil,                                                   // 49: mcpany.config.v1.OpenapiUpstreamService.CallsEntry
	nil,                                                   // 50: mcpany.config.v1.CommandLineUpstreamService.CallsEntry
	nil,                                                   // 51: mcpany.config.v1.CommandLineUpstreamService.EnvEntry
	nil,                                                   // 52: mcpany.config.v1.GraphQLUpstreamService.CallsEntry
	nil,                                                   // 53: mcpany.config.v1.SqlUpstreamService.CallsEntry
	nil,                                                   // 54: mcpany.config.v1.FilesystemUpstreamService.RootPathsEntry
	nil,                                                   // 55: mcpany.config.v1.McpUpstreamService.CallsEntry
	nil,                                                   // 56: mcpany.config.v1.McpStdioConnection.EnvEntry
	nil,                                                   // 57: mcpany.config.v1.McpBundleConnection.EnvEntry
	nil,                                                   // 58: mcpany.config.v1.ContainerEnvironment.VolumesEntry
	nil,                                                   // 59: mcpany.config.v1.ContainerEnvironment.EnvEntry
	nil,                                                   // 60: mcpany.config.v1.RateLimitConfig.ToolLimitsEntry
	(*UpstreamAuthentication)(nil),                        // 61: mcpany.config.v1.UpstreamAuthentication
	(*CacheConfig)(nil),                                   // 62: mcpany.config.v1.CacheConfig
	(*AuthenticationConfig)(nil),                          // 63: mcpany.config.v1.AuthenticationConfig
	(*Profile)(nil),                                       // 64: mcpany.config.v1.Profile
	(*PromptDefinition)(nil),                              // 65: mcpany.config.v1.PromptDefinition
	(*WebhookConfig)(nil),                                 // 66: mcpany.config.v1.WebhookConfig
	(*ToolDefinition)(nil),                                // 67: mcpany.config.v1.ToolDefinition
	(*GrpcHealthCheck)(nil),                               // 68: mcpany.config.v1.GrpcHealthCheck
	(*ResourceDefinition)(nil),                            // 69: mcpany.config.v1.ResourceDefinition
	(*HttpHealthCheck)(nil),                               // 70: mcpany.config.v1.HttpHealthCheck
	(*WebsocketHealthCheck)(nil),                          // 71: mcpany.config.v1.WebsocketHealthCheck
	(*WebRTCHealthCheck)(nil),                             // 72: mcpany.config.v1.WebRTCHealthCheck
	(*CommandLineHealthCheck)(nil),                        // 73: mcpany.config.v1.CommandLineHealthCheck
	(*durationpb.Duration)(nil),                           // 74: google.protobuf.Duration
	(*bus.RedisBus)(nil),                                  // 75: bus.RedisBus
	(*GrpcCallDefinition)(nil),                            // 76: mcpany.config.v1.GrpcCallDefinition
	(*HttpCallDefinition)(nil),                            // 77: mcpany.config.v1.HttpCallDefinition
	(*WebsocketCallDefinition)(nil),                       // 78: mcpany.config.v1.WebsocketCallDefinition
	(*WebrtcCallDefinition)(nil),                          // 79: mcpany.config.v1.WebrtcCallDefinition
	(*OpenAPICallDefinition)(nil),                         // 80: mcpany.config.v1.OpenAPICallDefinition
	(*CommandLineCallDefinition)(nil),                     // 81: mcpany.config.v1.CommandLineCallDefinition
	(*SecretValue)(nil),                                   // 82: mcpany.config.v1.SecretValue
	(*GraphQLCallDefinition)(nil),                         // 83: mcpany.config.v1.GraphQLCallDefinition
	(*SqlCallDefinition)(nil),                             // 84: mcpany.config.v1.SqlCallDefinition
	(*MCPCallDefinition)(nil),                             // 85: mcpany.config.v1.MCPCallDefinition
}
var file_proto_config_v1_upstream_service_proto_depIdxs = []int32{
	61,  // 0: mcpany.config.v1.UpstreamServiceCollection.authentication:type_name -> mcpany.config.v1.UpstreamAuthentication
	37,  // 1: mcpany.config.v1.UpstreamServiceConfig.connection_pool:type_name -> mcpany.config.v1.ConnectionPoolConfig
	61,  // 2: mcpany.config.v1.UpstreamServiceConfig.upstream_authentication:type_name -> mcpany.config.v1.UpstreamAuthentication
	62,  // 3: mcpany.config.v1.UpstreamServiceConfig.cache:type_name -> mcpany.config.v1.CacheConfig
	39,  // 4: mcpany.config.v1.UpstreamServiceConfig.rate_limit:type_name -> mcpany.config.v1.RateLimitConfig
	0,   // 5: mcpany.config.v1.UpstreamServiceConfig.load_balancing_strategy:type_name -> mcpany.config.v1.LoadBalancingStrategy
	40,  // 6: mcpany.config.v1.UpstreamServiceConfig.resilience:type_name -> mcpany.config.v1.ResilienceConfig
	33,  // 7: mcpany.config.v1.UpstreamServiceConfig.mcp_service:type_name -> mcpany.config.v1.McpUpstreamService
	19,  // 8: mcpany.config.v1.UpstreamServiceConfig.http_service:type_name -> mcpany.config.v1.HttpUpstreamService
	14,  // 9: mcpany.config.v1.UpstreamServiceConfig.grpc_service:type_name -> mcpany.config.v1.GrpcUpstreamService
	22,  // 10: mcpany.config.v1.UpstreamServiceConfig.openapi_service:type_name -> mcpany.config.v1.OpenapiUpstreamService
	23,  // 11: mcpany.config.v1.UpstreamServiceConfig.command_line_service:type_name -> mcpany.config.v1.CommandLineUpstreamService
	20,  // 12: mcpany.config.v1.UpstreamServiceConfig.websocket_service:type_name -> mcpany.config.v1.WebsocketUpstreamService
	21,  // 13: mcpany.config.v1.UpstreamServiceConfig.webrtc_service:type_name -> mcpany.config.v1.WebrtcUpstreamService
	24,  // 14: mcpany.config.v1.UpstreamServiceConfig.graphql_service:type_name -> mcpany.config.v1.GraphQLUpstreamService
	25,  // 15: mcpany.config.v1.UpstreamServiceConfig.sql_service:type_name -> mcpany.config.v1.SqlUpstreamService
	26,  // 16: mcpany.config.v1.UpstreamServiceConfig.filesystem_service:type_name -> mcpany.config.v1.FilesystemUpstreamService
	63,  // 17: mcpany.config.v1.UpstreamServiceConfig.authentication:type_name -> mcpany.config.v1.AuthenticationConfig
	9,   // 18: mcpany.config.v1.UpstreamServiceConfig.call_policies:type_name -> mcpany.config.v1.CallPolicy
	13,  // 19: mcpany.config.v1.UpstreamServiceConfig.pre_call_hooks:type_name -> mcpany.config.v1.CallHook
	13,  // 20: mcpany.config.v1.UpstreamServiceConfig.post_call_hooks:type_name -> mcpany.config.v1.CallHook
	64,  // 21: mcpany.config.v1.UpstreamServiceConfig.profiles:type_name -> mcpany.config.v1.Profile
	65,  // 22: mcpany.config.v1.UpstreamServiceConfig.prompts:type_name -> mcpany.config.v1.PromptDefinition
	11,  // 23: mcpany.config.v1.UpstreamServiceConfig.tool_export_policy:type_name -> mcpany.config.v1.ExportPolicy
	11,  // 24: mcpany.config.v1.UpstreamServiceConfig.prompt_export_policy:type_name -> mcpany.config.v1.ExportPolicy
	11,  // 25: mcpany.config.v1.UpstreamServiceConfig.resource_export_policy:type_name -> mcpany.config.v1.ExportPolicy
	44,  // 26: mcpany.config.v1.UpstreamServiceConfig.profile_limits:type_name -> mcpany.config.v1.UpstreamServiceConfig.ProfileLimitsEntry
	1,   // 27: mcpany.config.v1.CallPolicy.default_action:type_name -> mcpany.config.v1.CallPolicy.Action
	10,  // 28: mcpany.config.v1.CallPolicy.rules:type_name -> mcpany.config.v1.CallPolicyRule
	1,   // 29: mcpany.config.v1.CallPolicyRule.action:type_name -> mcpany.config.v1.CallPolicy.Action
	2,   // 30: mcpany.config.v1.ExportPolicy.default_action:type_name -> mcpany.config.v1.ExportPolicy.Action
	12,  // 31: mcpany.config.v1.ExportPolicy.rules:type_name -> mcpany.config.v1.ExportRule
	2,   // 32: mcpany.config.v1.ExportRule.action:type_name -> mcpany.config.v1.ExportPolicy.Action
	66,  // 33: mcpany.config.v1.CallHook.webhook:type_name -> mcpany.config.v1.WebhookConfig
	9,   // 34: mcpany.config.v1.CallHook.call_policy:type_name -> mcpany.config.v1.CallPolicy
	43,  // 35: mcpany.config.v1.GrpcUpstreamService.tls_config:type_name -> mcpany.config.v1.TLSConfig
	67,  // 36: mcpany.config.v1.GrpcUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	68,  // 37: mcpany.config.v1.GrpcUpstreamService.health_check:type_name -> mcpany.config.v1.GrpcHealthCheck
	15,  // 38: mcpany.config.v1.GrpcUpstreamService.proto_definitions:type_name -> mcpany.config.v1.ProtoDefinition
	18,  // 39: mcpany.config.v1.GrpcUpstreamService.proto_collection:type_name -> mcpany.config.v1.ProtoCollection
	69,  // 40: mcpany.config.v1.GrpcUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	45,  // 41: mcpany.config.v1.GrpcUpstreamService.calls:type_name -> mcpany.config.v1.GrpcUpstreamService.CallsEntry
	65,  // 42: mcpany.config.v1.GrpcUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	16,  // 43: mcpany.config.v1.ProtoDefinition.proto_file:type_name -> mcpany.config.v1.ProtoFile
	17,  // 44: mcpany.config.v1.ProtoDefinition.proto_descriptor:type_name -> mcpany.config.v1.ProtoDescriptor
	67,  // 45: mcpany.config.v1.HttpUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	46,  // 46: mcpany.config.v1.HttpUpstreamService.calls:type_name -> mcpany.config.v1.HttpUpstreamService.CallsEntry
	70,  // 47: mcpany.config.v1.HttpUpstreamService.health_check:type_name -> mcpany.config.v1.HttpHealthCheck
	43,  // 48: mcpany.config.v1.HttpUpstreamService.tls_config:type_name -> mcpany.config.v1.TLSConfig
	69,  // 49: mcpany.config.v1.HttpUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	65,  // 50: mcpany.config.v1.HttpUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	67,  // 51: mcpany.config.v1.WebsocketUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	43,  // 52: mcpany.config.v1.WebsocketUpstreamService.tls_config:type_name -> mcpany.config.v1.TLSConfig
	69,  // 53: mcpany.config.v1.WebsocketUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	47,  // 54: mcpany.config.v1.WebsocketUpstreamService.calls:type_name -> mcpany.config.v1.WebsocketUpstreamService.CallsEntry
	65,  // 55: mcpany.config.v1.WebsocketUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	71,  // 56: mcpany.config.v1.WebsocketUpstreamService.health_check:type_name -> mcpany.config.v1.WebsocketHealthCheck
	67,  // 57: mcpany.config.v1.WebrtcUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	43,  // 58: mcpany.config.v1.WebrtcUpstreamService.tls_config:type_name -> mcpany.config.v1.TLSConfig
	69,  // 59: mcpany.config.v1.WebrtcUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	48,  // 60: mcpany.config.v1.WebrtcUpstreamService.calls:type_name -> mcpany.config.v1.WebrtcUpstreamService.CallsEntry
	65,  // 61: mcpany.config.v1.WebrtcUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	72,  // 62: mcpany.config.v1.WebrtcUpstreamService.health_check:type_name -> mcpany.config.v1.WebRTCHealthCheck
	70,  // 63: mcpany.config.v1.OpenapiUpstreamService.health_check:type_name -> mcpany.config.v1.HttpHealthCheck
	43,  // 64: mcpany.config.v1.OpenapiUpstreamService.tls_config:type_name -> mcpany.config.v1.TLSConfig
	67,  // 65: mcpany.config.v1.OpenapiUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	69,  // 66: mcpany.config.v1.OpenapiUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	49,  // 67: mcpany.config.v1.OpenapiUpstreamService.calls:type_name -> mcpany.config.v1.OpenapiUpstreamService.CallsEntry
	65,  // 68: mcpany.config.v1.OpenapiUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	67,  // 69: mcpany.config.v1.CommandLineUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	73,  // 70: mcpany.config.v1.CommandLineUpstreamService.health_check:type_name -> mcpany.config.v1.CommandLineHealthCheck
	62,  // 71: mcpany.config.v1.CommandLineUpstreamService.cache:type_name -> mcpany.config.v1.CacheConfig
	38,  // 72: mcpany.config.v1.CommandLineUpstreamService.container_environment:type_name -> mcpany.config.v1.ContainerEnvironment
	74,  // 73: mcpany.config.v1.CommandLineUpstreamService.timeout:type_name -> google.protobuf.Duration
	69,  // 74: mcpany.config.v1.CommandLineUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	50,  // 75: mcpany.config.v1.CommandLineUpstreamService.calls:type_name -> mcpany.config.v1.CommandLineUpstreamService.CallsEntry
	65,  // 76: mcpany.config.v1.CommandLineUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	3,   // 77: mcpany.config.v1.CommandLineUpstreamService.communication_protocol:type_name -> mcpany.config.v1.CommandLineUpstreamService.CommunicationProtocol
	51,  // 78: mcpany.config.v1.CommandLineUpstreamService.env:type_name -> mcpany.config.v1.CommandLineUpstreamService.EnvEntry
	52,  // 79: mcpany.config.v1.GraphQLUpstreamService.calls:type_name -> mcpany.config.v1.GraphQLUpstreamService.CallsEntry
	53,  // 80: mcpany.config.v1.SqlUpstreamService.calls:type_name -> mcpany.config.v1.SqlUpstreamService.CallsEntry
	54,  // 81: mcpany.config.v1.FilesystemUpstreamService.root_paths:type_name -> mcpany.config.v1.FilesystemUpstreamService.RootPathsEntry
	67,  // 82: mcpany.config.v1.FilesystemUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	69,  // 83: mcpany.config.v1.FilesystemUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	65,  // 84: mcpany.config.v1.FilesystemUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	27,  // 85: mcpany.config.v1.FilesystemUpstreamService.os:type_name -> mcpany.config.v1.OsFs
	28,  // 86: mcpany.config.v1.FilesystemUpstreamService.tmpfs:type_name -> mcpany.config.v1.MemMapFs
	29,  // 87: mcpany.config.v1.FilesystemUpstreamService.http:type_name -> mcpany.config.v1.HttpFs
	30,  // 88: mcpany.config.v1.FilesystemUpstreamService.zip:type_name -> mcpany.config.v1.ZipFs
	31,  // 89: mcpany.config.v1.FilesystemUpstreamService.gcs:type_name -> mcpany.config.v1.GcsFs
	32,  // 90: mcpany.config.v1.FilesystemUpstreamService.sftp:type_name -> mcpany.config.v1.SftpFs
	35,  // 91: mcpany.config.v1.McpUpstreamService.http_connection:type_name -> mcpany.config.v1.McpStreamableHttpConnection
	34,  // 92: mcpany.config.v1.McpUpstreamService.stdio_connection:type_name -> mcpany.config.v1.McpStdioConnection
	36,  // 93: mcpany.config.v1.McpUpstreamService.bundle_connection:type_name -> mcpany.config.v1.McpBundleConnection
	67,  // 94: mcpany.config.v1.McpUpstreamService.tools:type_name -> mcpany.config.v1.ToolDefinition
	69,  // 95: mcpany.config.v1.McpUpstreamService.resources:type_name -> mcpany.config.v1.ResourceDefinition
	55,  // 96: mcpany.config.v1.McpUpstreamService.calls:type_name -> mcpany.config.v1.McpUpstreamService.CallsEntry
	65,  // 97: mcpany.config.v1.McpUpstreamService.prompts:type_name -> mcpany.config.v1.PromptDefinition
	56,  // 98: mcpany.config.v1.McpStdioConnection.env:type_name -> mcpany.config.v1.McpStdioConnection.EnvEntry
	43,  // 99: mcpany.config.v1.McpStreamableHttpConnection.tls_config:type_name -> mcpany.config.v1.TLSConfig
	57,  // 100: mcpany.config.v1.McpBundleConnection.env:type_name -> mcpany.config.v1.McpBundleConnection.EnvEntry
	74,  // 101: mcpany.config.v1.ConnectionPoolConfig.idle_timeout:type_name -> google.protobuf.Duration
	58,  // 102: mcpany.config.v1.ContainerEnvironment.volumes:type_name -> mcpany.config.v1.ContainerEnvironment.VolumesEntry
	59,  // 103: mcpany.config.v1.ContainerEnvironment.env:type_name -> mcpany.config.v1.ContainerEnvironment.EnvEntry
	4,   // 104: mcpany.config.v1.RateLimitConfig.storage:type_name -> mcpany.config.v1.RateLimitConfig.Storage
	75,  // 105: mcpany.config.v1.RateLimitConfig.redis:type_name -> bus.RedisBus
	5,   // 106: mcpany.config.v1.RateLimitConfig.key_by:type_name -> mcpany.config.v1.RateLimitConfig.KeyBy
	6,   // 107: mcpany.config.v1.RateLimitConfig.cost_metric:type_name -> mcpany.config.v1.RateLimitConfig.CostMetric
	60,  // 108: mcpany.config.v1.RateLimitConfig.tool_limits:type_name -> mcpany.config.v1.RateLimitConfig.ToolLimitsEntry
	41,  // 109: mcpany.config.v1.ResilienceConfig.circuit_breaker:type_name -> mcpany.config.v1.CircuitBreakerConfig
	42,  // 110: mcpany.config.v1.ResilienceConfig.retry_policy:type_name -> mcpany.config.v1.RetryConfig
	74,  // 111: mcpany.config.v1.CircuitBreakerConfig.open_duration:type_name -> google.protobuf.Duration
	74,  // 112: mcpany.config.v1.RetryConfig.base_backoff:type_name -> google.protobuf.Duration
	74,  // 113: mcpany.config.v1.RetryConfig.max_backoff:type_name -> google.protobuf.Duration
	74,  // 114: mcpany.config.v1.RetryConfig.max_elapsed_time:type_name -> google.protobuf.Duration
	39,  // 115: mcpany.config.v1.UpstreamServiceConfig.ProfileLimitsEntry.value:type_name -> mcpany.config.v1.RateLimitConfig
	76,  // 116: mcpany.config.v1.GrpcUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.GrpcCallDefinition
	77,  // 117: mcpany.config.v1.HttpUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.HttpCallDefinition
	78,  // 118: mcpany.config.v1.WebsocketUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.WebsocketCallDefinition
	79,  // 119: mcpany.config.v1.WebrtcUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.WebrtcCallDefinition
	80,  // 120: mcpany.config.v1.OpenapiUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.OpenAPICallDefinition
	81,  // 121: mcpany.config.v1.CommandLineUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.CommandLineCallDefinition
	82,  // 122: mcpany.config.v1.CommandLineUpstreamService.EnvEntry.value:type_name -> mcpany.config.v1.SecretValue
	83,  // 123: mcpany.config.v1.GraphQLUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.GraphQLCallDefinition
	84,  // 124: mcpany.config.v1.SqlUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.SqlCallDefinition
	85,  // 125: mcpany.config.v1.McpUpstreamService.CallsEntry.value:type_name -> mcpany.config.v1.MCPCallDefinition
	82,  // 126: mcpany.config.v1.McpStdioConnection.EnvEntry.value:type_name -> mcpany.config.v1.SecretValue
	82,  // 127: mcpany.config.v1.McpBundleConnection.EnvEntry.value:type_name -> mcpany.config.v1.SecretValue
	82,  // 128: mcpany.config.v1.ContainerEnvironment.EnvEntry.value:type_name -> mcpany.config.v1.SecretValue
	39,  // 129: mcpany.config.v1.RateLimitConfig.ToolLimitsEntry.value:type_name -> mcpany.config.v1.RateLimitConfig
	130, // [130:130] is the sub-list for method output_type
	130, // [130:130] is the sub-list for method input_type
	130, // [130:130] is the sub-list for extension type_name
	130, // [130:130] is the sub-list for extension extendee
	0,   // [0:130] is the sub-list for field type_name
}

func init() { file_proto_config_v1_upstream_service_proto_init() }
func file_proto_config_v1_upstream_service_proto_init() {
	if File_proto_config_v1_upstream_service_proto != nil {
		return
	}
	file_proto_config_v1_auth_proto_init()
	file_proto_config_v1_call_proto_init()
	file_proto_config_v1_health_check_proto_init()
	file_proto_config_v1_profile_proto_init()
	file_proto_config_v1_prompt_proto_init()
	file_proto_config_v1_resource_proto_init()
	file_proto_config_v1_tool_proto_init()
	file_proto_config_v1_webhook_proto_init()
	file_proto_config_v1_upstream_service_proto_msgTypes[1].OneofWrappers = []any{
		(*UpstreamServiceConfig_McpService)(nil),
		(*UpstreamServiceConfig_HttpService)(nil),
		(*UpstreamServiceConfig_GrpcService)(nil),
		(*UpstreamServiceConfig_OpenapiService)(nil),
		(*UpstreamServiceConfig_CommandLineService)(nil),
		(*UpstreamServiceConfig_WebsocketService)(nil),
		(*UpstreamServiceConfig_WebrtcService)(nil),
		(*UpstreamServiceConfig_GraphqlService)(nil),
		(*UpstreamServiceConfig_SqlService)(nil),
		(*UpstreamServiceConfig_FilesystemService)(nil),
	}
	file_proto_config_v1_upstream_service_proto_msgTypes[6].OneofWrappers = []any{
		(*CallHook_Webhook)(nil),
		(*CallHook_CallPolicy)(nil),
	}
	file_proto_config_v1_upstream_service_proto_msgTypes[8].OneofWrappers = []any{
		(*ProtoDefinition_ProtoFile)(nil),
		(*ProtoDefinition_ProtoDescriptor)(nil),
	}
	file_proto_config_v1_upstream_service_proto_msgTypes[9].OneofWrappers = []any{
		(*ProtoFile_FileContent)(nil),
		(*ProtoFile_FilePath)(nil),
	}
	file_proto_config_v1_upstream_service_proto_msgTypes[10].OneofWrappers = []any{
		(*ProtoDescriptor_FilePath)(nil),
	}
	file_proto_config_v1_upstream_service_proto_msgTypes[15].OneofWrappers = []any{
		(*OpenapiUpstreamService_SpecContent)(nil),
		(*OpenapiUpstreamService_SpecUrl)(nil),
	}
	file_proto_config_v1_upstream_service_proto_msgTypes[19].OneofWrappers = []any{
		(*FilesystemUpstreamService_Os)(nil),
		(*FilesystemUpstreamService_Tmpfs)(nil),
		(*FilesystemUpstreamService_Http)(nil),
		(*FilesystemUpstreamService_Zip)(nil),
		(*FilesystemUpstreamService_Gcs)(nil),
		(*FilesystemUpstreamService_Sftp)(nil),
	}
	file_proto_config_v1_upstream_service_proto_msgTypes[26].OneofWrappers = []any{
		(*McpUpstreamService_HttpConnection)(nil),
		(*McpUpstreamService_StdioConnection)(nil),
		(*McpUpstreamService_BundleConnection)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_config_v1_upstream_service_proto_rawDesc), len(file_proto_config_v1_upstream_service_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   54,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_config_v1_upstream_service_proto_goTypes,
		DependencyIndexes: file_proto_config_v1_upstream_service_proto_depIdxs,
		EnumInfos:         file_proto_config_v1_upstream_service_proto_enumTypes,
		MessageInfos:      file_proto_config_v1_upstream_service_proto_msgTypes,
	}.Build()
	File_proto_config_v1_upstream_service_proto = out.File
	file_proto_config_v1_upstream_service_proto_goTypes = nil
	file_proto_config_v1_upstream_service_proto_depIdxs = nil
}
