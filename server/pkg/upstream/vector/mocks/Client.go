// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	client "github.com/milvus-io/milvus-sdk-go/v2/client"

	entity "github.com/milvus-io/milvus-sdk-go/v2/entity"

	mock "github.com/stretchr/testify/mock"

	msgpb "github.com/milvus-io/milvus-proto/go-api/v2/msgpb"

	time "time"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// AddUserRole provides a mock function with given fields: ctx, username, role
func (_m *Client) AddUserRole(ctx context.Context, username string, role string) error {
	ret := _m.Called(ctx, username, role)

	if len(ret) == 0 {
		panic("no return value specified for AddUserRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, username, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AlterAlias provides a mock function with given fields: ctx, collName, alias
func (_m *Client) AlterAlias(ctx context.Context, collName string, alias string) error {
	ret := _m.Called(ctx, collName, alias)

	if len(ret) == 0 {
		panic("no return value specified for AlterAlias")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, collName, alias)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AlterCollection provides a mock function with given fields: ctx, collName, attrs
func (_m *Client) AlterCollection(ctx context.Context, collName string, attrs ...entity.CollectionAttribute) error {
	_va := make([]interface{}, len(attrs))
	for _i := range attrs {
		_va[_i] = attrs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AlterCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...entity.CollectionAttribute) error); ok {
		r0 = rf(ctx, collName, attrs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AlterDatabase provides a mock function with given fields: ctx, dbName, attrs
func (_m *Client) AlterDatabase(ctx context.Context, dbName string, attrs ...entity.CollectionAttribute) error {
	_va := make([]interface{}, len(attrs))
	for _i := range attrs {
		_va[_i] = attrs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dbName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AlterDatabase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...entity.CollectionAttribute) error); ok {
		r0 = rf(ctx, dbName, attrs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AlterIndex provides a mock function with given fields: ctx, collName, indexName, opts
func (_m *Client) AlterIndex(ctx context.Context, collName string, indexName string, opts ...client.IndexOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, indexName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AlterIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) error); ok {
		r0 = rf(ctx, collName, indexName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackupRBAC provides a mock function with given fields: ctx
func (_m *Client) BackupRBAC(ctx context.Context) (*entity.RBACMeta, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BackupRBAC")
	}

	var r0 *entity.RBACMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*entity.RBACMeta, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *entity.RBACMeta); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.RBACMeta)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BulkInsert provides a mock function with given fields: ctx, collName, partitionName, files, opts
func (_m *Client) BulkInsert(ctx context.Context, collName string, partitionName string, files []string, opts ...client.BulkInsertOption) (int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitionName, files)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BulkInsert")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, ...client.BulkInsertOption) (int64, error)); ok {
		return rf(ctx, collName, partitionName, files, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []string, ...client.BulkInsertOption) int64); ok {
		r0 = rf(ctx, collName, partitionName, files, opts...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, []string, ...client.BulkInsertOption) error); ok {
		r1 = rf(ctx, collName, partitionName, files, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalcDistance provides a mock function with given fields: ctx, collName, partitions, metricType, opLeft, opRight
func (_m *Client) CalcDistance(ctx context.Context, collName string, partitions []string, metricType entity.MetricType, opLeft entity.Column, opRight entity.Column) (entity.Column, error) {
	ret := _m.Called(ctx, collName, partitions, metricType, opLeft, opRight)

	if len(ret) == 0 {
		panic("no return value specified for CalcDistance")
	}

	var r0 entity.Column
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, entity.MetricType, entity.Column, entity.Column) (entity.Column, error)); ok {
		return rf(ctx, collName, partitions, metricType, opLeft, opRight)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, entity.MetricType, entity.Column, entity.Column) entity.Column); ok {
		r0 = rf(ctx, collName, partitions, metricType, opLeft, opRight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(entity.Column)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, entity.MetricType, entity.Column, entity.Column) error); ok {
		r1 = rf(ctx, collName, partitions, metricType, opLeft, opRight)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckHealth provides a mock function with given fields: ctx
func (_m *Client) CheckHealth(ctx context.Context) (*entity.MilvusState, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CheckHealth")
	}

	var r0 *entity.MilvusState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*entity.MilvusState, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *entity.MilvusState); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.MilvusState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with no fields
func (_m *Client) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateAlias provides a mock function with given fields: ctx, collName, alias
func (_m *Client) CreateAlias(ctx context.Context, collName string, alias string) error {
	ret := _m.Called(ctx, collName, alias)

	if len(ret) == 0 {
		panic("no return value specified for CreateAlias")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, collName, alias)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateCollection provides a mock function with given fields: ctx, schema, shardsNum, opts
func (_m *Client) CreateCollection(ctx context.Context, schema *entity.Schema, shardsNum int32, opts ...client.CreateCollectionOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, schema, shardsNum)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.Schema, int32, ...client.CreateCollectionOption) error); ok {
		r0 = rf(ctx, schema, shardsNum, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateCollectionByRow provides a mock function with given fields: ctx, row, shardNum
func (_m *Client) CreateCollectionByRow(ctx context.Context, row entity.Row, shardNum int32) error {
	ret := _m.Called(ctx, row, shardNum)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollectionByRow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, entity.Row, int32) error); ok {
		r0 = rf(ctx, row, shardNum)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateCredential provides a mock function with given fields: ctx, username, password
func (_m *Client) CreateCredential(ctx context.Context, username string, password string) error {
	ret := _m.Called(ctx, username, password)

	if len(ret) == 0 {
		panic("no return value specified for CreateCredential")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, username, password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateDatabase provides a mock function with given fields: ctx, dbName, opts
func (_m *Client) CreateDatabase(ctx context.Context, dbName string, opts ...client.CreateDatabaseOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dbName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...client.CreateDatabaseOption) error); ok {
		r0 = rf(ctx, dbName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateIndex provides a mock function with given fields: ctx, collName, fieldName, idx, async, opts
func (_m *Client) CreateIndex(ctx context.Context, collName string, fieldName string, idx entity.Index, async bool, opts ...client.IndexOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, fieldName, idx, async)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, entity.Index, bool, ...client.IndexOption) error); ok {
		r0 = rf(ctx, collName, fieldName, idx, async, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreatePartition provides a mock function with given fields: ctx, collName, partitionName, opts
func (_m *Client) CreatePartition(ctx context.Context, collName string, partitionName string, opts ...client.CreatePartitionOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitionName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePartition")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.CreatePartitionOption) error); ok {
		r0 = rf(ctx, collName, partitionName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateResourceGroup provides a mock function with given fields: ctx, rgName, opts
func (_m *Client) CreateResourceGroup(ctx context.Context, rgName string, opts ...client.CreateResourceGroupOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, rgName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateResourceGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...client.CreateResourceGroupOption) error); ok {
		r0 = rf(ctx, rgName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateRole provides a mock function with given fields: ctx, name
func (_m *Client) CreateRole(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for CreateRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, collName, partitionName, expr
func (_m *Client) Delete(ctx context.Context, collName string, partitionName string, expr string) error {
	ret := _m.Called(ctx, collName, partitionName, expr)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, collName, partitionName, expr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteByPks provides a mock function with given fields: ctx, collName, partitionName, ids
func (_m *Client) DeleteByPks(ctx context.Context, collName string, partitionName string, ids entity.Column) error {
	ret := _m.Called(ctx, collName, partitionName, ids)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByPks")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, entity.Column) error); ok {
		r0 = rf(ctx, collName, partitionName, ids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteCredential provides a mock function with given fields: ctx, username
func (_m *Client) DeleteCredential(ctx context.Context, username string) error {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCredential")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DescribeCollection provides a mock function with given fields: ctx, collName
func (_m *Client) DescribeCollection(ctx context.Context, collName string) (*entity.Collection, error) {
	ret := _m.Called(ctx, collName)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCollection")
	}

	var r0 *entity.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.Collection, error)); ok {
		return rf(ctx, collName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.Collection); ok {
		r0 = rf(ctx, collName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, collName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeDatabase provides a mock function with given fields: ctx, dbName
func (_m *Client) DescribeDatabase(ctx context.Context, dbName string) (*entity.Database, error) {
	ret := _m.Called(ctx, dbName)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDatabase")
	}

	var r0 *entity.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.Database, error)); ok {
		return rf(ctx, dbName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.Database); ok {
		r0 = rf(ctx, dbName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dbName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeIndex provides a mock function with given fields: ctx, collName, fieldName, opts
func (_m *Client) DescribeIndex(ctx context.Context, collName string, fieldName string, opts ...client.IndexOption) ([]entity.Index, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, fieldName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIndex")
	}

	var r0 []entity.Index
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) ([]entity.Index, error)); ok {
		return rf(ctx, collName, fieldName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) []entity.Index); ok {
		r0 = rf(ctx, collName, fieldName, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...client.IndexOption) error); ok {
		r1 = rf(ctx, collName, fieldName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeResourceGroup provides a mock function with given fields: ctx, rgName
func (_m *Client) DescribeResourceGroup(ctx context.Context, rgName string) (*entity.ResourceGroup, error) {
	ret := _m.Called(ctx, rgName)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResourceGroup")
	}

	var r0 *entity.ResourceGroup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.ResourceGroup, error)); ok {
		return rf(ctx, rgName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.ResourceGroup); ok {
		r0 = rf(ctx, rgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.ResourceGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, rgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUser provides a mock function with given fields: ctx, username
func (_m *Client) DescribeUser(ctx context.Context, username string) (entity.UserDescription, error) {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUser")
	}

	var r0 entity.UserDescription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (entity.UserDescription, error)); ok {
		return rf(ctx, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) entity.UserDescription); ok {
		r0 = rf(ctx, username)
	} else {
		r0 = ret.Get(0).(entity.UserDescription)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeUsers provides a mock function with given fields: ctx
func (_m *Client) DescribeUsers(ctx context.Context) ([]entity.UserDescription, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DescribeUsers")
	}

	var r0 []entity.UserDescription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]entity.UserDescription, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []entity.UserDescription); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.UserDescription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DropAlias provides a mock function with given fields: ctx, alias
func (_m *Client) DropAlias(ctx context.Context, alias string) error {
	ret := _m.Called(ctx, alias)

	if len(ret) == 0 {
		panic("no return value specified for DropAlias")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, alias)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DropCollection provides a mock function with given fields: ctx, collName, opts
func (_m *Client) DropCollection(ctx context.Context, collName string, opts ...client.DropCollectionOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DropCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...client.DropCollectionOption) error); ok {
		r0 = rf(ctx, collName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DropDatabase provides a mock function with given fields: ctx, dbName, opts
func (_m *Client) DropDatabase(ctx context.Context, dbName string, opts ...client.DropDatabaseOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dbName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DropDatabase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...client.DropDatabaseOption) error); ok {
		r0 = rf(ctx, dbName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DropIndex provides a mock function with given fields: ctx, collName, fieldName, opts
func (_m *Client) DropIndex(ctx context.Context, collName string, fieldName string, opts ...client.IndexOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, fieldName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DropIndex")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) error); ok {
		r0 = rf(ctx, collName, fieldName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DropPartition provides a mock function with given fields: ctx, collName, partitionName, opts
func (_m *Client) DropPartition(ctx context.Context, collName string, partitionName string, opts ...client.DropPartitionOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitionName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DropPartition")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.DropPartitionOption) error); ok {
		r0 = rf(ctx, collName, partitionName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DropResourceGroup provides a mock function with given fields: ctx, rgName
func (_m *Client) DropResourceGroup(ctx context.Context, rgName string) error {
	ret := _m.Called(ctx, rgName)

	if len(ret) == 0 {
		panic("no return value specified for DropResourceGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, rgName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DropRole provides a mock function with given fields: ctx, name
func (_m *Client) DropRole(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for DropRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Flush provides a mock function with given fields: ctx, collName, async, opts
func (_m *Client) Flush(ctx context.Context, collName string, async bool, opts ...client.FlushOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, async)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, ...client.FlushOption) error); ok {
		r0 = rf(ctx, collName, async, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FlushV2 provides a mock function with given fields: ctx, collName, async, opts
func (_m *Client) FlushV2(ctx context.Context, collName string, async bool, opts ...client.FlushOption) ([]int64, []int64, int64, map[string]msgpb.MsgPosition, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, async)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FlushV2")
	}

	var r0 []int64
	var r1 []int64
	var r2 int64
	var r3 map[string]msgpb.MsgPosition
	var r4 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, ...client.FlushOption) ([]int64, []int64, int64, map[string]msgpb.MsgPosition, error)); ok {
		return rf(ctx, collName, async, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, ...client.FlushOption) []int64); ok {
		r0 = rf(ctx, collName, async, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool, ...client.FlushOption) []int64); ok {
		r1 = rf(ctx, collName, async, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]int64)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, bool, ...client.FlushOption) int64); ok {
		r2 = rf(ctx, collName, async, opts...)
	} else {
		r2 = ret.Get(2).(int64)
	}

	if rf, ok := ret.Get(3).(func(context.Context, string, bool, ...client.FlushOption) map[string]msgpb.MsgPosition); ok {
		r3 = rf(ctx, collName, async, opts...)
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).(map[string]msgpb.MsgPosition)
		}
	}

	if rf, ok := ret.Get(4).(func(context.Context, string, bool, ...client.FlushOption) error); ok {
		r4 = rf(ctx, collName, async, opts...)
	} else {
		r4 = ret.Error(4)
	}

	return r0, r1, r2, r3, r4
}

// Get provides a mock function with given fields: ctx, collectionName, ids, opts
func (_m *Client) Get(ctx context.Context, collectionName string, ids entity.Column, opts ...client.GetOption) (client.ResultSet, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collectionName, ids)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 client.ResultSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, entity.Column, ...client.GetOption) (client.ResultSet, error)); ok {
		return rf(ctx, collectionName, ids, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, entity.Column, ...client.GetOption) client.ResultSet); ok {
		r0 = rf(ctx, collectionName, ids, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.ResultSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, entity.Column, ...client.GetOption) error); ok {
		r1 = rf(ctx, collectionName, ids, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBulkInsertState provides a mock function with given fields: ctx, taskID
func (_m *Client) GetBulkInsertState(ctx context.Context, taskID int64) (*entity.BulkInsertTaskState, error) {
	ret := _m.Called(ctx, taskID)

	if len(ret) == 0 {
		panic("no return value specified for GetBulkInsertState")
	}

	var r0 *entity.BulkInsertTaskState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*entity.BulkInsertTaskState, error)); ok {
		return rf(ctx, taskID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *entity.BulkInsertTaskState); ok {
		r0 = rf(ctx, taskID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.BulkInsertTaskState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, taskID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCollectionStatistics provides a mock function with given fields: ctx, collName
func (_m *Client) GetCollectionStatistics(ctx context.Context, collName string) (map[string]string, error) {
	ret := _m.Called(ctx, collName)

	if len(ret) == 0 {
		panic("no return value specified for GetCollectionStatistics")
	}

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]string, error)); ok {
		return rf(ctx, collName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]string); ok {
		r0 = rf(ctx, collName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, collName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompactionState provides a mock function with given fields: ctx, id
func (_m *Client) GetCompactionState(ctx context.Context, id int64) (entity.CompactionState, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetCompactionState")
	}

	var r0 entity.CompactionState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (entity.CompactionState, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) entity.CompactionState); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(entity.CompactionState)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompactionStateWithPlans provides a mock function with given fields: ctx, id
func (_m *Client) GetCompactionStateWithPlans(ctx context.Context, id int64) (entity.CompactionState, []entity.CompactionPlan, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetCompactionStateWithPlans")
	}

	var r0 entity.CompactionState
	var r1 []entity.CompactionPlan
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (entity.CompactionState, []entity.CompactionPlan, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) entity.CompactionState); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(entity.CompactionState)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) []entity.CompactionPlan); ok {
		r1 = rf(ctx, id)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]entity.CompactionPlan)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, int64) error); ok {
		r2 = rf(ctx, id)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIndexBuildProgress provides a mock function with given fields: ctx, collName, fieldName, opts
func (_m *Client) GetIndexBuildProgress(ctx context.Context, collName string, fieldName string, opts ...client.IndexOption) (int64, int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, fieldName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIndexBuildProgress")
	}

	var r0 int64
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) (int64, int64, error)); ok {
		return rf(ctx, collName, fieldName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) int64); ok {
		r0 = rf(ctx, collName, fieldName, opts...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...client.IndexOption) int64); ok {
		r1 = rf(ctx, collName, fieldName, opts...)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, ...client.IndexOption) error); ok {
		r2 = rf(ctx, collName, fieldName, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIndexState provides a mock function with given fields: ctx, collName, fieldName, opts
func (_m *Client) GetIndexState(ctx context.Context, collName string, fieldName string, opts ...client.IndexOption) (entity.IndexState, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, fieldName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIndexState")
	}

	var r0 entity.IndexState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) (entity.IndexState, error)); ok {
		return rf(ctx, collName, fieldName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...client.IndexOption) entity.IndexState); ok {
		r0 = rf(ctx, collName, fieldName, opts...)
	} else {
		r0 = ret.Get(0).(entity.IndexState)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...client.IndexOption) error); ok {
		r1 = rf(ctx, collName, fieldName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoadState provides a mock function with given fields: ctx, collectionName, partitionNames
func (_m *Client) GetLoadState(ctx context.Context, collectionName string, partitionNames []string) (entity.LoadState, error) {
	ret := _m.Called(ctx, collectionName, partitionNames)

	if len(ret) == 0 {
		panic("no return value specified for GetLoadState")
	}

	var r0 entity.LoadState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) (entity.LoadState, error)); ok {
		return rf(ctx, collectionName, partitionNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) entity.LoadState); ok {
		r0 = rf(ctx, collectionName, partitionNames)
	} else {
		r0 = ret.Get(0).(entity.LoadState)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, collectionName, partitionNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoadingProgress provides a mock function with given fields: ctx, collectionName, partitionNames
func (_m *Client) GetLoadingProgress(ctx context.Context, collectionName string, partitionNames []string) (int64, error) {
	ret := _m.Called(ctx, collectionName, partitionNames)

	if len(ret) == 0 {
		panic("no return value specified for GetLoadingProgress")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) (int64, error)); ok {
		return rf(ctx, collectionName, partitionNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) int64); ok {
		r0 = rf(ctx, collectionName, partitionNames)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, collectionName, partitionNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPersistentSegmentInfo provides a mock function with given fields: ctx, collName
func (_m *Client) GetPersistentSegmentInfo(ctx context.Context, collName string) ([]*entity.Segment, error) {
	ret := _m.Called(ctx, collName)

	if len(ret) == 0 {
		panic("no return value specified for GetPersistentSegmentInfo")
	}

	var r0 []*entity.Segment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*entity.Segment, error)); ok {
		return rf(ctx, collName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*entity.Segment); ok {
		r0 = rf(ctx, collName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Segment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, collName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReplicas provides a mock function with given fields: ctx, collName
func (_m *Client) GetReplicas(ctx context.Context, collName string) ([]*entity.ReplicaGroup, error) {
	ret := _m.Called(ctx, collName)

	if len(ret) == 0 {
		panic("no return value specified for GetReplicas")
	}

	var r0 []*entity.ReplicaGroup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*entity.ReplicaGroup, error)); ok {
		return rf(ctx, collName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*entity.ReplicaGroup); ok {
		r0 = rf(ctx, collName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.ReplicaGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, collName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersion provides a mock function with given fields: ctx
func (_m *Client) GetVersion(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Grant provides a mock function with given fields: ctx, role, objectType, object, privilege, options
func (_m *Client) Grant(ctx context.Context, role string, objectType entity.PriviledgeObjectType, object string, privilege string, options ...entity.OperatePrivilegeOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, role, objectType, object, privilege)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Grant")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, entity.PriviledgeObjectType, string, string, ...entity.OperatePrivilegeOption) error); ok {
		r0 = rf(ctx, role, objectType, object, privilege, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HasCollection provides a mock function with given fields: ctx, collName
func (_m *Client) HasCollection(ctx context.Context, collName string) (bool, error) {
	ret := _m.Called(ctx, collName)

	if len(ret) == 0 {
		panic("no return value specified for HasCollection")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, collName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, collName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, collName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasPartition provides a mock function with given fields: ctx, collName, partitionName
func (_m *Client) HasPartition(ctx context.Context, collName string, partitionName string) (bool, error) {
	ret := _m.Called(ctx, collName, partitionName)

	if len(ret) == 0 {
		panic("no return value specified for HasPartition")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, collName, partitionName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, collName, partitionName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, collName, partitionName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HybridSearch provides a mock function with given fields: ctx, collName, partitions, limit, outputFields, reranker, subRequests, opts
func (_m *Client) HybridSearch(ctx context.Context, collName string, partitions []string, limit int, outputFields []string, reranker client.Reranker, subRequests []*client.ANNSearchRequest, opts ...client.SearchQueryOptionFunc) ([]client.SearchResult, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitions, limit, outputFields, reranker, subRequests)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HybridSearch")
	}

	var r0 []client.SearchResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, []string, client.Reranker, []*client.ANNSearchRequest, ...client.SearchQueryOptionFunc) ([]client.SearchResult, error)); ok {
		return rf(ctx, collName, partitions, limit, outputFields, reranker, subRequests, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, int, []string, client.Reranker, []*client.ANNSearchRequest, ...client.SearchQueryOptionFunc) []client.SearchResult); ok {
		r0 = rf(ctx, collName, partitions, limit, outputFields, reranker, subRequests, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.SearchResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, int, []string, client.Reranker, []*client.ANNSearchRequest, ...client.SearchQueryOptionFunc) error); ok {
		r1 = rf(ctx, collName, partitions, limit, outputFields, reranker, subRequests, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Insert provides a mock function with given fields: ctx, collName, partitionName, columns
func (_m *Client) Insert(ctx context.Context, collName string, partitionName string, columns ...entity.Column) (entity.Column, error) {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitionName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 entity.Column
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...entity.Column) (entity.Column, error)); ok {
		return rf(ctx, collName, partitionName, columns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...entity.Column) entity.Column); ok {
		r0 = rf(ctx, collName, partitionName, columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(entity.Column)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...entity.Column) error); ok {
		r1 = rf(ctx, collName, partitionName, columns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertByRows provides a mock function with given fields: ctx, collName, paritionName, rows
func (_m *Client) InsertByRows(ctx context.Context, collName string, paritionName string, rows []entity.Row) (entity.Column, error) {
	ret := _m.Called(ctx, collName, paritionName, rows)

	if len(ret) == 0 {
		panic("no return value specified for InsertByRows")
	}

	var r0 entity.Column
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []entity.Row) (entity.Column, error)); ok {
		return rf(ctx, collName, paritionName, rows)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []entity.Row) entity.Column); ok {
		r0 = rf(ctx, collName, paritionName, rows)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(entity.Column)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, []entity.Row) error); ok {
		r1 = rf(ctx, collName, paritionName, rows)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertRows provides a mock function with given fields: ctx, collName, partitionName, rows
func (_m *Client) InsertRows(ctx context.Context, collName string, partitionName string, rows []interface{}) (entity.Column, error) {
	ret := _m.Called(ctx, collName, partitionName, rows)

	if len(ret) == 0 {
		panic("no return value specified for InsertRows")
	}

	var r0 entity.Column
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []interface{}) (entity.Column, error)); ok {
		return rf(ctx, collName, partitionName, rows)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []interface{}) entity.Column); ok {
		r0 = rf(ctx, collName, partitionName, rows)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(entity.Column)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, []interface{}) error); ok {
		r1 = rf(ctx, collName, partitionName, rows)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBulkInsertTasks provides a mock function with given fields: ctx, collName, limit
func (_m *Client) ListBulkInsertTasks(ctx context.Context, collName string, limit int64) ([]*entity.BulkInsertTaskState, error) {
	ret := _m.Called(ctx, collName, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListBulkInsertTasks")
	}

	var r0 []*entity.BulkInsertTaskState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) ([]*entity.BulkInsertTaskState, error)); ok {
		return rf(ctx, collName, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) []*entity.BulkInsertTaskState); ok {
		r0 = rf(ctx, collName, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.BulkInsertTaskState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, collName, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCollections provides a mock function with given fields: ctx, opts
func (_m *Client) ListCollections(ctx context.Context, opts ...client.ListCollectionOption) ([]*entity.Collection, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCollections")
	}

	var r0 []*entity.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.ListCollectionOption) ([]*entity.Collection, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...client.ListCollectionOption) []*entity.Collection); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...client.ListCollectionOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCredUsers provides a mock function with given fields: ctx
func (_m *Client) ListCredUsers(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListCredUsers")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatabases provides a mock function with given fields: ctx
func (_m *Client) ListDatabases(ctx context.Context) ([]entity.Database, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabases")
	}

	var r0 []entity.Database
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]entity.Database, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []entity.Database); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Database)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGrant provides a mock function with given fields: ctx, role, object, objectName, dbName
func (_m *Client) ListGrant(ctx context.Context, role string, object string, objectName string, dbName string) ([]entity.RoleGrants, error) {
	ret := _m.Called(ctx, role, object, objectName, dbName)

	if len(ret) == 0 {
		panic("no return value specified for ListGrant")
	}

	var r0 []entity.RoleGrants
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) ([]entity.RoleGrants, error)); ok {
		return rf(ctx, role, object, objectName, dbName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) []entity.RoleGrants); ok {
		r0 = rf(ctx, role, object, objectName, dbName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.RoleGrants)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, role, object, objectName, dbName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListGrants provides a mock function with given fields: ctx, role, dbName
func (_m *Client) ListGrants(ctx context.Context, role string, dbName string) ([]entity.RoleGrants, error) {
	ret := _m.Called(ctx, role, dbName)

	if len(ret) == 0 {
		panic("no return value specified for ListGrants")
	}

	var r0 []entity.RoleGrants
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]entity.RoleGrants, error)); ok {
		return rf(ctx, role, dbName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []entity.RoleGrants); ok {
		r0 = rf(ctx, role, dbName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.RoleGrants)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, role, dbName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListResourceGroups provides a mock function with given fields: ctx
func (_m *Client) ListResourceGroups(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListResourceGroups")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRoles provides a mock function with given fields: ctx
func (_m *Client) ListRoles(ctx context.Context) ([]entity.Role, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListRoles")
	}

	var r0 []entity.Role
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]entity.Role, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []entity.Role); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Role)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUsers provides a mock function with given fields: ctx
func (_m *Client) ListUsers(ctx context.Context) ([]entity.User, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 []entity.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]entity.User, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []entity.User); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadCollection provides a mock function with given fields: ctx, collName, async, opts
func (_m *Client) LoadCollection(ctx context.Context, collName string, async bool, opts ...client.LoadCollectionOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, async)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, ...client.LoadCollectionOption) error); ok {
		r0 = rf(ctx, collName, async, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LoadPartitions provides a mock function with given fields: ctx, collName, partitionNames, async, opts
func (_m *Client) LoadPartitions(ctx context.Context, collName string, partitionNames []string, async bool, opts ...client.LoadPartitionsOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitionNames, async)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadPartitions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool, ...client.LoadPartitionsOption) error); ok {
		r0 = rf(ctx, collName, partitionNames, async, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ManualCompaction provides a mock function with given fields: ctx, collName, toleranceDuration
func (_m *Client) ManualCompaction(ctx context.Context, collName string, toleranceDuration time.Duration) (int64, error) {
	ret := _m.Called(ctx, collName, toleranceDuration)

	if len(ret) == 0 {
		panic("no return value specified for ManualCompaction")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) (int64, error)); ok {
		return rf(ctx, collName, toleranceDuration)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) int64); ok {
		r0 = rf(ctx, collName, toleranceDuration)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, time.Duration) error); ok {
		r1 = rf(ctx, collName, toleranceDuration)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCollection provides a mock function with given fields: ctx, collName, dimension, opts
func (_m *Client) NewCollection(ctx context.Context, collName string, dimension int64, opts ...client.CreateCollectionOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, dimension)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NewCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...client.CreateCollectionOption) error); ok {
		r0 = rf(ctx, collName, dimension, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Query provides a mock function with given fields: ctx, collectionName, partitionNames, expr, outputFields, opts
func (_m *Client) Query(ctx context.Context, collectionName string, partitionNames []string, expr string, outputFields []string, opts ...client.SearchQueryOptionFunc) (client.ResultSet, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collectionName, partitionNames, expr, outputFields)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 client.ResultSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, string, []string, ...client.SearchQueryOptionFunc) (client.ResultSet, error)); ok {
		return rf(ctx, collectionName, partitionNames, expr, outputFields, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, string, []string, ...client.SearchQueryOptionFunc) client.ResultSet); ok {
		r0 = rf(ctx, collectionName, partitionNames, expr, outputFields, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.ResultSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, string, []string, ...client.SearchQueryOptionFunc) error); ok {
		r1 = rf(ctx, collectionName, partitionNames, expr, outputFields, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryByPks provides a mock function with given fields: ctx, collectionName, partitionNames, ids, outputFields, opts
func (_m *Client) QueryByPks(ctx context.Context, collectionName string, partitionNames []string, ids entity.Column, outputFields []string, opts ...client.SearchQueryOptionFunc) (client.ResultSet, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collectionName, partitionNames, ids, outputFields)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryByPks")
	}

	var r0 client.ResultSet
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, entity.Column, []string, ...client.SearchQueryOptionFunc) (client.ResultSet, error)); ok {
		return rf(ctx, collectionName, partitionNames, ids, outputFields, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, entity.Column, []string, ...client.SearchQueryOptionFunc) client.ResultSet); ok {
		r0 = rf(ctx, collectionName, partitionNames, ids, outputFields, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.ResultSet)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, entity.Column, []string, ...client.SearchQueryOptionFunc) error); ok {
		r1 = rf(ctx, collectionName, partitionNames, ids, outputFields, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryIterator provides a mock function with given fields: ctx, opt
func (_m *Client) QueryIterator(ctx context.Context, opt *client.QueryIteratorOption) (*client.QueryIterator, error) {
	ret := _m.Called(ctx, opt)

	if len(ret) == 0 {
		panic("no return value specified for QueryIterator")
	}

	var r0 *client.QueryIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *client.QueryIteratorOption) (*client.QueryIterator, error)); ok {
		return rf(ctx, opt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *client.QueryIteratorOption) *client.QueryIterator); ok {
		r0 = rf(ctx, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.QueryIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *client.QueryIteratorOption) error); ok {
		r1 = rf(ctx, opt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReleaseCollection provides a mock function with given fields: ctx, collName, opts
func (_m *Client) ReleaseCollection(ctx context.Context, collName string, opts ...client.ReleaseCollectionOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...client.ReleaseCollectionOption) error); ok {
		r0 = rf(ctx, collName, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReleasePartitions provides a mock function with given fields: ctx, collName, partitionNames, opts
func (_m *Client) ReleasePartitions(ctx context.Context, collName string, partitionNames []string, opts ...client.ReleasePartitionsOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitionNames)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReleasePartitions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...client.ReleasePartitionsOption) error); ok {
		r0 = rf(ctx, collName, partitionNames, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveUserRole provides a mock function with given fields: ctx, username, role
func (_m *Client) RemoveUserRole(ctx context.Context, username string, role string) error {
	ret := _m.Called(ctx, username, role)

	if len(ret) == 0 {
		panic("no return value specified for RemoveUserRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, username, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RenameCollection provides a mock function with given fields: ctx, collName, newName
func (_m *Client) RenameCollection(ctx context.Context, collName string, newName string) error {
	ret := _m.Called(ctx, collName, newName)

	if len(ret) == 0 {
		panic("no return value specified for RenameCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, collName, newName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReplicateMessage provides a mock function with given fields: ctx, channelName, beginTs, endTs, msgsBytes, startPositions, endPositions, opts
func (_m *Client) ReplicateMessage(ctx context.Context, channelName string, beginTs uint64, endTs uint64, msgsBytes [][]byte, startPositions []*msgpb.MsgPosition, endPositions []*msgpb.MsgPosition, opts ...client.ReplicateMessageOption) (*entity.MessageInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, channelName, beginTs, endTs, msgsBytes, startPositions, endPositions)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplicateMessage")
	}

	var r0 *entity.MessageInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, uint64, [][]byte, []*msgpb.MsgPosition, []*msgpb.MsgPosition, ...client.ReplicateMessageOption) (*entity.MessageInfo, error)); ok {
		return rf(ctx, channelName, beginTs, endTs, msgsBytes, startPositions, endPositions, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, uint64, [][]byte, []*msgpb.MsgPosition, []*msgpb.MsgPosition, ...client.ReplicateMessageOption) *entity.MessageInfo); ok {
		r0 = rf(ctx, channelName, beginTs, endTs, msgsBytes, startPositions, endPositions, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.MessageInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64, uint64, [][]byte, []*msgpb.MsgPosition, []*msgpb.MsgPosition, ...client.ReplicateMessageOption) error); ok {
		r1 = rf(ctx, channelName, beginTs, endTs, msgsBytes, startPositions, endPositions, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreRBAC provides a mock function with given fields: ctx, meta
func (_m *Client) RestoreRBAC(ctx context.Context, meta *entity.RBACMeta) error {
	ret := _m.Called(ctx, meta)

	if len(ret) == 0 {
		panic("no return value specified for RestoreRBAC")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *entity.RBACMeta) error); ok {
		r0 = rf(ctx, meta)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Revoke provides a mock function with given fields: ctx, role, objectType, object, privilege, options
func (_m *Client) Revoke(ctx context.Context, role string, objectType entity.PriviledgeObjectType, object string, privilege string, options ...entity.OperatePrivilegeOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, role, objectType, object, privilege)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Revoke")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, entity.PriviledgeObjectType, string, string, ...entity.OperatePrivilegeOption) error); ok {
		r0 = rf(ctx, role, objectType, object, privilege, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Search provides a mock function with given fields: ctx, collName, partitions, expr, outputFields, vectors, vectorField, metricType, topK, sp, opts
func (_m *Client) Search(ctx context.Context, collName string, partitions []string, expr string, outputFields []string, vectors []entity.Vector, vectorField string, metricType entity.MetricType, topK int, sp entity.SearchParam, opts ...client.SearchQueryOptionFunc) ([]client.SearchResult, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitions, expr, outputFields, vectors, vectorField, metricType, topK, sp)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Search")
	}

	var r0 []client.SearchResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, string, []string, []entity.Vector, string, entity.MetricType, int, entity.SearchParam, ...client.SearchQueryOptionFunc) ([]client.SearchResult, error)); ok {
		return rf(ctx, collName, partitions, expr, outputFields, vectors, vectorField, metricType, topK, sp, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, string, []string, []entity.Vector, string, entity.MetricType, int, entity.SearchParam, ...client.SearchQueryOptionFunc) []client.SearchResult); ok {
		r0 = rf(ctx, collName, partitions, expr, outputFields, vectors, vectorField, metricType, topK, sp, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.SearchResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, string, []string, []entity.Vector, string, entity.MetricType, int, entity.SearchParam, ...client.SearchQueryOptionFunc) error); ok {
		r1 = rf(ctx, collName, partitions, expr, outputFields, vectors, vectorField, metricType, topK, sp, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShowPartitions provides a mock function with given fields: ctx, collName
func (_m *Client) ShowPartitions(ctx context.Context, collName string) ([]*entity.Partition, error) {
	ret := _m.Called(ctx, collName)

	if len(ret) == 0 {
		panic("no return value specified for ShowPartitions")
	}

	var r0 []*entity.Partition
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*entity.Partition, error)); ok {
		return rf(ctx, collName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*entity.Partition); ok {
		r0 = rf(ctx, collName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Partition)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, collName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferNode provides a mock function with given fields: ctx, sourceRg, targetRg, nodesNum
func (_m *Client) TransferNode(ctx context.Context, sourceRg string, targetRg string, nodesNum int32) error {
	ret := _m.Called(ctx, sourceRg, targetRg, nodesNum)

	if len(ret) == 0 {
		panic("no return value specified for TransferNode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int32) error); ok {
		r0 = rf(ctx, sourceRg, targetRg, nodesNum)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TransferReplica provides a mock function with given fields: ctx, sourceRg, targetRg, collectionName, replicaNum
func (_m *Client) TransferReplica(ctx context.Context, sourceRg string, targetRg string, collectionName string, replicaNum int64) error {
	ret := _m.Called(ctx, sourceRg, targetRg, collectionName, replicaNum)

	if len(ret) == 0 {
		panic("no return value specified for TransferReplica")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) error); ok {
		r0 = rf(ctx, sourceRg, targetRg, collectionName, replicaNum)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCredential provides a mock function with given fields: ctx, username, oldPassword, newPassword
func (_m *Client) UpdateCredential(ctx context.Context, username string, oldPassword string, newPassword string) error {
	ret := _m.Called(ctx, username, oldPassword, newPassword)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCredential")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, username, oldPassword, newPassword)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateResourceGroups provides a mock function with given fields: ctx, opts
func (_m *Client) UpdateResourceGroups(ctx context.Context, opts ...client.UpdateResourceGroupsOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResourceGroups")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...client.UpdateResourceGroupsOption) error); ok {
		r0 = rf(ctx, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Upsert provides a mock function with given fields: ctx, collName, partitionName, columns
func (_m *Client) Upsert(ctx context.Context, collName string, partitionName string, columns ...entity.Column) (entity.Column, error) {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, collName, partitionName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 entity.Column
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...entity.Column) (entity.Column, error)); ok {
		return rf(ctx, collName, partitionName, columns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...entity.Column) entity.Column); ok {
		r0 = rf(ctx, collName, partitionName, columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(entity.Column)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...entity.Column) error); ok {
		r1 = rf(ctx, collName, partitionName, columns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsingDatabase provides a mock function with given fields: ctx, dbName
func (_m *Client) UsingDatabase(ctx context.Context, dbName string) error {
	ret := _m.Called(ctx, dbName)

	if len(ret) == 0 {
		panic("no return value specified for UsingDatabase")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, dbName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
