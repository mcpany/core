# Copyright 2025 Author(s) of MCP Any
# SPDX-License-Identifier: Apache-2.0
name: Release

on:
  workflow_dispatch:
    inputs:
      release_version:
        description: "The release version (e.g., v1.2.3)"
        required: true
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  # Define registries and image names centrally
  DOCKERHUB_IMAGE: mcpany/server
  GHCR_IMAGE: ghcr.io/mcpany/server

jobs:
  setup:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      version: ${{ steps.vars.outputs.version }}
      is_release: ${{ steps.vars.outputs.is_release }}
      tags_dockerhub: ${{ steps.vars.outputs.tags_dockerhub }}
      tags_ghcr: ${{ steps.vars.outputs.tags_ghcr }}
      tags_ui_dockerhub: ${{ steps.vars.outputs.tags_ui_dockerhub }}
      tags_ui_ghcr: ${{ steps.vars.outputs.tags_ui_ghcr }}
    steps:
      - name: Set variables
        id: vars
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.release_version }}"
            IS_RELEASE="true"
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "is_release=true" >> $GITHUB_OUTPUT
            # Tags for Docker Hub
            echo "tags_dockerhub=${{ env.DOCKERHUB_IMAGE }}:${VERSION},${{ env.DOCKERHUB_IMAGE }}:latest" >> $GITHUB_OUTPUT
            # Tags for GHCR
            echo "tags_ghcr=${{ env.GHCR_IMAGE }}:${VERSION},${{ env.GHCR_IMAGE }}:latest" >> $GITHUB_OUTPUT
            echo "tags_ui_dockerhub=mcpany/ui:${VERSION},mcpany/ui:latest" >> $GITHUB_OUTPUT
            echo "tags_ui_ghcr=ghcr.io/mcpany/ui:${VERSION},ghcr.io/mcpany/ui:latest" >> $GITHUB_OUTPUT
          else
            # Generate timestamp
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            VERSION="dev-${TIMESTAMP}"
            IS_RELEASE="false"
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "is_release=false" >> $GITHUB_OUTPUT
            # Tags
            echo "tags_dockerhub=${{ env.DOCKERHUB_IMAGE }}:${VERSION},${{ env.DOCKERHUB_IMAGE }}:dev-latest,${{ env.DOCKERHUB_IMAGE }}:dev" >> $GITHUB_OUTPUT
            echo "tags_ghcr=${{ env.GHCR_IMAGE }}:${VERSION},${{ env.GHCR_IMAGE }}:dev-latest,${{ env.GHCR_IMAGE }}:dev" >> $GITHUB_OUTPUT
            echo "tags_ui_dockerhub=mcpany/ui:${VERSION},mcpany/ui:dev-latest,mcpany/ui:dev" >> $GITHUB_OUTPUT
            echo "tags_ui_ghcr=ghcr.io/mcpany/ui:${VERSION},ghcr.io/mcpany/ui:dev-latest,ghcr.io/mcpany/ui:dev" >> $GITHUB_OUTPUT
          fi

  # ==============================================================================
  # JOB 1: BUILD BINARIES (Go Cross-Compilation)
  # Builds .zip files for Windows/Mac/Linux
  # Only runs on manual release
  # ==============================================================================
  build-binaries:
    needs: setup
    if: needs.setup.outputs.is_release == 'true'
    name: Build Binaries (${{ matrix.platform }})
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      matrix:
        platform:
          [
            linux/amd64,
            linux/arm64,
            linux/386,
            darwin/amd64,
            darwin/arm64,
            windows/amd64,
          ]
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.24"
          cache: true

      - name: Prepare environment
        id: prep
        run: make prepare

      - name: Build binaries
        run: |
          make release PLATFORMS=${{ matrix.platform }}

      - name: Package binaries
        id: package
        run: |
          RELEASE_DIR=./build/release
          PLATFORM=${{ matrix.platform }}
          GOOS=${PLATFORM%/*}
          GOARCH=${PLATFORM#*/}
          echo "goos=${GOOS}" >> $GITHUB_OUTPUT
          echo "goarch=${GOARCH}" >> $GITHUB_OUTPUT
          echo "platform_name=$(echo ${{ matrix.platform }} | tr '/' '-')" >> $GITHUB_OUTPUT

          BINARY_NAME=server-$GOOS-$GOARCH
          if [ "$GOOS" = "windows" ]; then
            BINARY_NAME=$BINARY_NAME.exe
          fi
          zip -j $RELEASE_DIR/$BINARY_NAME.zip $RELEASE_DIR/$BINARY_NAME

      - name: Upload binaries artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-binaries-${{ steps.package.outputs.platform_name }}
          path: ./build/release/*.zip

  # ==============================================================================
  # JOB 2: CREATE GITHUB RELEASE
  # Aggregates the binaries and creates the release page
  # Only runs on manual release
  # ==============================================================================
  create-release:
    needs: [setup, build-binaries]
    if: needs.setup.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Download all binaries
        uses: actions/download-artifact@v4
        with:
          pattern: release-binaries-*
          merge-multiple: true
          path: ./build/release

      - name: Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.setup.outputs.version }}
          name: Release ${{ needs.setup.outputs.version }}
          files: ./build/release/*.zip
          generate_release_notes: true
          draft: true
          prerelease: false
          make_latest: false
          token: ${{ secrets.GITHUB_TOKEN }}

  # ==============================================================================
  # JOB 3: DOCKER BUILD (MATRIX)
  # Runs in parallel with binary builds.
  # Uses Native ARM runners for speed.
  # ==============================================================================
  docker-build:
    needs: setup
    name: Docker Build ${{ matrix.platform }}
    # Dynamic runner selection: Native ARM runner for arm64, Standard for amd64
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Get Date
        id: get-date
        run: |
          echo "week=$(/bin/date -u "+%V")" >> $GITHUB_OUTPUT
        shell: bash

      - name: Cache Docker images
        uses: ScribeMD/docker-cache@0.5.0
        with:
          key: docker-images-${{ runner.os }}-${{ matrix.platform }}-${{ steps.get-date.outputs.week }}

      # Only setup QEMU if strictly necessary (e.g. if using ubuntu-latest for ARM)
      # Since we are using native runners, this is mostly a fallback/safety.
      - name: Set up QEMU
        if: ${{ matrix.runner == 'ubuntu-latest' && matrix.platform != 'linux/amd64' }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["mirror.gcr.io"]

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare build context
        run: |
          make -C server prepare-docker-context

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v5
        with:
          context: server
          file: server/docker/Dockerfile.server
          platforms: ${{ matrix.platform }}
          tags: |
            ${{ needs.setup.outputs.tags_dockerhub }}
            ${{ needs.setup.outputs.tags_ghcr }}
          # Export as tarball for artifact upload
          outputs: type=docker,dest=/tmp/server-image.tar
          cache-from: type=gha,scope=${{ matrix.platform }}
          # Optimized cache: use mode=max to cache layers
          cache-to: type=gha,mode=max,scope=${{ matrix.platform }}

      - name: Rename artifact
        run: |
          # Sanitize platform name for artifact filename
          PLATFORM_SLUG=$(echo "${{ matrix.platform }}" | tr '/' '-')
          mv /tmp/server-image.tar /tmp/server-image-${PLATFORM_SLUG}.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: server-image-${{ strategy.job-index }}
          path: /tmp/server-image-*.tar
          if-no-files-found: error
          retention-days: 1

  # ==============================================================================
  # JOB 4: DOCKER MERGE
  # Combines the AMD64 and ARM64 digests into one "latest" tag
  # ==============================================================================
  docker-merge:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [setup, docker-build]
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: server-image-*
          merge-multiple: true
          path: /tmp/images

      - name: Load images
        run: |
          for tarball in /tmp/images/*.tar; do
            echo "Loading $tarball..."
            docker load --input "$tarball"
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["mirror.gcr.io"]

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push images and create manifest
        if: github.event_name != 'pull_request'
        run: |
          DOCKERHUB_IMAGE="${{ env.DOCKERHUB_IMAGE }}"
          GHCR_IMAGE="${{ env.GHCR_IMAGE }}"
          VERSION="${{ needs.setup.outputs.version }}"
          IS_RELEASE="${{ needs.setup.outputs.is_release }}"

          # Parse tags we expect to be on the loaded images
          TAGS_DH="${{ needs.setup.outputs.tags_dockerhub }}"
          TAGS_GH="${{ needs.setup.outputs.tags_ghcr }}"

          # Convert comma-separated tags to arrays
          IFS=',' read -ra ADDR_DH <<< "$TAGS_DH"
          IFS=',' read -ra ADDR_GH <<< "$TAGS_GH"

          # Arrays to hold the platform-specific tags for manifest creation
          declare -A MANIFEST_TAGS_DH
          declare -A MANIFEST_TAGS_GH

          for tarball in /tmp/images/*.tar; do
            # Extract platform slug from filename (e.g., server-image-linux-amd64.tar -> linux-amd64)
            BASENAME=$(basename "$tarball" .tar)
            PLATFORM_SLUG=${BASENAME#server-image-}

            echo "Processing $tarball (Platform: $PLATFORM_SLUG)..."

            # Load the image
            # This restores the tags (e.g. mcpany/server:latest) pointing to this architecture's image
            docker load --input "$tarball"

            # Retag and Push DockerHub tags
            for tag in "${ADDR_DH[@]}"; do
              # tag is like mcpany/server:v1.2.3
              ARCH_TAG="${tag}-${PLATFORM_SLUG}"
              docker tag "$tag" "$ARCH_TAG"
              docker push "$ARCH_TAG"

              # Record this arch tag for the manifest of the base tag
              MANIFEST_TAGS_DH["$tag"]="${MANIFEST_TAGS_DH["$tag"]} $ARCH_TAG"
            done

            # Retag and Push GHCR tags
            for tag in "${ADDR_GH[@]}"; do
              ARCH_TAG="${tag}-${PLATFORM_SLUG}"
              docker tag "$tag" "$ARCH_TAG"
              docker push "$ARCH_TAG"
              MANIFEST_TAGS_GH["$tag"]="${MANIFEST_TAGS_GH["$tag"]} $ARCH_TAG"
            done
          done

          # Create and Push Manifests for Docker Hub
          for tag in "${!MANIFEST_TAGS_DH[@]}"; do
            ARCH_TAGS=${MANIFEST_TAGS_DH["$tag"]}
            echo "Creating manifest for $tag with: $ARCH_TAGS"
            docker manifest create "$tag" $ARCH_TAGS
            docker manifest push "$tag"
          done

          # Create and Push Manifests for GHCR
          for tag in "${!MANIFEST_TAGS_GH[@]}"; do
            ARCH_TAGS=${MANIFEST_TAGS_GH["$tag"]}
            echo "Creating manifest for $tag with: $ARCH_TAGS"
            docker manifest create "$tag" $ARCH_TAGS
            docker manifest push "$tag"
          done

      - name: Inspect image
        if: github.event_name != 'pull_request'
        run: |
          docker buildx imagetools inspect ${{ env.DOCKERHUB_IMAGE }}:${{ needs.setup.outputs.version }}

  # ==============================================================================
  # JOB 5: UI DOCKER BUILD (MATRIX)
  # ==============================================================================
  docker-build-ui:
    needs: setup
    name: Docker Build UI ${{ matrix.platform }}
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Get Date
        id: get-date
        run: |
          echo "week=$(/bin/date -u "+%V")" >> $GITHUB_OUTPUT
        shell: bash

      - name: Cache Docker images
        uses: ScribeMD/docker-cache@0.5.0
        with:
          key: docker-images-ui-${{ runner.os }}-${{ matrix.platform }}-${{ steps.get-date.outputs.week }}

      - name: Set up QEMU
        if: ${{ matrix.runner == 'ubuntu-latest' && matrix.platform != 'linux/amd64' }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["mirror.gcr.io"]

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ui/Dockerfile
          platforms: ${{ matrix.platform }}
          tags: |
            ${{ needs.setup.outputs.tags_ui_dockerhub }}
            ${{ needs.setup.outputs.tags_ui_ghcr }}
          # Export as tarball for artifact upload
          outputs: type=docker,dest=/tmp/ui-image.tar
          cache-from: type=gha,scope=ui-${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=ui-${{ matrix.platform }}

      - name: Rename artifact
        run: |
          # Sanitize platform name for artifact filename
          PLATFORM_SLUG=$(echo "${{ matrix.platform }}" | tr '/' '-')
          mv /tmp/ui-image.tar /tmp/ui-image-${PLATFORM_SLUG}.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ui-image-${{ strategy.job-index }}
          path: /tmp/ui-image-*.tar
          if-no-files-found: error
          retention-days: 1

      - name: Export digest
        run: |
          mkdir -p /tmp/digests-ui
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests-ui/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-ui-${{ strategy.job-index }}
          path: /tmp/digests-ui/*
          if-no-files-found: error
          retention-days: 1

  # ==============================================================================
  # JOB 6: UI DOCKER MERGE
  # ==============================================================================
  docker-merge-ui:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [setup, docker-build-ui]
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: ui-image-*
          merge-multiple: true
          path: /tmp/images-ui

      - name: Load images
        run: |
          for tarball in /tmp/images-ui/*.tar; do
            echo "Loading $tarball..."
            docker load --input "$tarball"
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["mirror.gcr.io"]

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push images and create manifest
        if: github.event_name != 'pull_request'
        working-directory: /tmp/digests-ui
        run: |
          VERSION="${{ needs.setup.outputs.version }}"
          IS_RELEASE="${{ needs.setup.outputs.is_release }}"
          DOCKERHUB_IMAGE="mcpany/ui"
          # Assuming GHCR image follows pattern ghcr.io/mcpany/ui
          GHCR_IMAGE="ghcr.io/mcpany/ui"

          echo "Generating tags for Version: $VERSION (Is Release: $IS_RELEASE)"

          TAGS_DH="${{ needs.setup.outputs.tags_ui_dockerhub }}"
          TAGS_GH="${{ needs.setup.outputs.tags_ui_ghcr }}"


          # Convert comma-separated tags to arrays
          IFS=',' read -ra ADDR_DH <<< "$TAGS_DH"
          IFS=',' read -ra ADDR_GH <<< "$TAGS_GH"

          # Arrays to hold the platform-specific tags for manifest creation
          declare -A MANIFEST_TAGS_DH
          declare -A MANIFEST_TAGS_GH

          for tarball in /tmp/images-ui/*.tar; do
            # Extract platform slug from filename (e.g., ui-image-linux-amd64.tar -> linux-amd64)
            BASENAME=$(basename "$tarball" .tar)
            PLATFORM_SLUG=${BASENAME#ui-image-}

            echo "Processing $tarball (Platform: $PLATFORM_SLUG)..."

            # Load the image
            docker load --input "$tarball"

            # Retag and Push DockerHub tags
            for tag in "${ADDR_DH[@]}"; do
              ARCH_TAG="${tag}-${PLATFORM_SLUG}"
              docker tag "$tag" "$ARCH_TAG"
              docker push "$ARCH_TAG"
              MANIFEST_TAGS_DH["$tag"]="${MANIFEST_TAGS_DH["$tag"]} $ARCH_TAG"
            done

            # Retag and Push GHCR tags
            for tag in "${ADDR_GH[@]}"; do
              ARCH_TAG="${tag}-${PLATFORM_SLUG}"
              docker tag "$tag" "$ARCH_TAG"
              docker push "$ARCH_TAG"
              MANIFEST_TAGS_GH["$tag"]="${MANIFEST_TAGS_GH["$tag"]} $ARCH_TAG"
            done
          done

          # Create and Push Manifests for Docker Hub
          for tag in "${!MANIFEST_TAGS_DH[@]}"; do
            ARCH_TAGS=${MANIFEST_TAGS_DH["$tag"]}
            echo "Creating manifest for $tag with: $ARCH_TAGS"
            docker manifest create "$tag" $ARCH_TAGS
            docker manifest push "$tag"
          done

          # Create and Push Manifests for GHCR
          for tag in "${!MANIFEST_TAGS_GH[@]}"; do
            ARCH_TAGS=${MANIFEST_TAGS_GH["$tag"]}
            echo "Creating manifest for $tag with: $ARCH_TAGS"
            docker manifest create "$tag" $ARCH_TAGS
            docker manifest push "$tag"
          done

      - name: Inspect image
        if: github.event_name != 'pull_request'
        run: |
          docker buildx imagetools inspect mcpany/ui:${{ needs.setup.outputs.version }}
