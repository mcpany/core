// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               v6.33.1
// source: proto/config/v1/call.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../google/protobuf/duration";
import { Struct, Value } from "../../google/protobuf/struct";
import { SecretValue } from "./auth";
import { WebhookConfig } from "./webhook";

export const protobufPackage = "mcpany.config.v1";

/** ParameterType defines the data type of a parameter. */
export enum ParameterType {
  STRING = 0,
  NUMBER = 1,
  INTEGER = 2,
  BOOLEAN = 3,
  ARRAY = 4,
  OBJECT = 5,
  UNRECOGNIZED = -1,
}

export function parameterTypeFromJSON(object: any): ParameterType {
  switch (object) {
    case 0:
    case "STRING":
      return ParameterType.STRING;
    case 1:
    case "NUMBER":
      return ParameterType.NUMBER;
    case 2:
    case "INTEGER":
      return ParameterType.INTEGER;
    case 3:
    case "BOOLEAN":
      return ParameterType.BOOLEAN;
    case 4:
    case "ARRAY":
      return ParameterType.ARRAY;
    case 5:
    case "OBJECT":
      return ParameterType.OBJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParameterType.UNRECOGNIZED;
  }
}

export function parameterTypeToJSON(object: ParameterType): string {
  switch (object) {
    case ParameterType.STRING:
      return "STRING";
    case ParameterType.NUMBER:
      return "NUMBER";
    case ParameterType.INTEGER:
      return "INTEGER";
    case ParameterType.BOOLEAN:
      return "BOOLEAN";
    case ParameterType.ARRAY:
      return "ARRAY";
    case ParameterType.OBJECT:
      return "OBJECT";
    case ParameterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** HttpCallDefinition describes how to map an MCP call to a specific HTTP request. */
export interface HttpCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** The path of the HTTP endpoint (e.g., "/users/{userId}"). */
  endpointPath: string;
  /** The HTTP method to use for the request. */
  method: HttpCallDefinition_HttpMethod;
  /** Defines the parameters for the HTTP request. */
  parameters: HttpParameterMapping[];
  /** An optional input transformer to generate the request body. */
  inputTransformer?:
    | InputTransformer
    | undefined;
  /** An optional output transformer to parse the response body. */
  outputTransformer?:
    | OutputTransformer
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

export enum HttpCallDefinition_HttpMethod {
  HTTP_METHOD_UNSPECIFIED = 0,
  HTTP_METHOD_GET = 1,
  HTTP_METHOD_POST = 2,
  HTTP_METHOD_PUT = 3,
  HTTP_METHOD_DELETE = 4,
  HTTP_METHOD_PATCH = 5,
  UNRECOGNIZED = -1,
}

export function httpCallDefinition_HttpMethodFromJSON(object: any): HttpCallDefinition_HttpMethod {
  switch (object) {
    case 0:
    case "HTTP_METHOD_UNSPECIFIED":
      return HttpCallDefinition_HttpMethod.HTTP_METHOD_UNSPECIFIED;
    case 1:
    case "HTTP_METHOD_GET":
      return HttpCallDefinition_HttpMethod.HTTP_METHOD_GET;
    case 2:
    case "HTTP_METHOD_POST":
      return HttpCallDefinition_HttpMethod.HTTP_METHOD_POST;
    case 3:
    case "HTTP_METHOD_PUT":
      return HttpCallDefinition_HttpMethod.HTTP_METHOD_PUT;
    case 4:
    case "HTTP_METHOD_DELETE":
      return HttpCallDefinition_HttpMethod.HTTP_METHOD_DELETE;
    case 5:
    case "HTTP_METHOD_PATCH":
      return HttpCallDefinition_HttpMethod.HTTP_METHOD_PATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpCallDefinition_HttpMethod.UNRECOGNIZED;
  }
}

export function httpCallDefinition_HttpMethodToJSON(object: HttpCallDefinition_HttpMethod): string {
  switch (object) {
    case HttpCallDefinition_HttpMethod.HTTP_METHOD_UNSPECIFIED:
      return "HTTP_METHOD_UNSPECIFIED";
    case HttpCallDefinition_HttpMethod.HTTP_METHOD_GET:
      return "HTTP_METHOD_GET";
    case HttpCallDefinition_HttpMethod.HTTP_METHOD_POST:
      return "HTTP_METHOD_POST";
    case HttpCallDefinition_HttpMethod.HTTP_METHOD_PUT:
      return "HTTP_METHOD_PUT";
    case HttpCallDefinition_HttpMethod.HTTP_METHOD_DELETE:
      return "HTTP_METHOD_DELETE";
    case HttpCallDefinition_HttpMethod.HTTP_METHOD_PATCH:
      return "HTTP_METHOD_PATCH";
    case HttpCallDefinition_HttpMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** WebsocketCallDefinition describes how to map an MCP call to a specific websocket message. */
export interface WebsocketCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** Defines the parameters for the websocket message. */
  parameters: WebsocketParameterMapping[];
  /** An optional input transformer to generate the request body. */
  inputTransformer?:
    | InputTransformer
    | undefined;
  /** An optional output transformer to parse the response body. */
  outputTransformer?:
    | OutputTransformer
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/** WebrtcCallDefinition describes how to map an MCP call to a specific webrtc message. */
export interface WebrtcCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** Defines the parameters for the webrtc message. */
  parameters: WebrtcParameterMapping[];
  /** An optional input transformer to generate the request body. */
  inputTransformer?:
    | InputTransformer
    | undefined;
  /** An optional output transformer to parse the response body. */
  outputTransformer?:
    | OutputTransformer
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/** CommandLineCallDefinition describes how to map an MCP call to a stdio command. */
export interface CommandLineCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** Defines the parameters for the stdio command. */
  parameters: CommandLineParameterMapping[];
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The arguments to pass to the command. */
  args: string[];
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/** InputTransformer defines how to render a template from input parameters. */
export interface InputTransformer {
  /**
   * A text template to be rendered.
   * This is used for generating the request body for POST/PUT requests.
   * The template engine is compatible with Jinja2.
   * A text template to be rendered.
   * This is used for generating the request body for POST/PUT requests.
   * The template engine is compatible with Jinja2.
   *
   * @deprecated
   */
  template: string;
  /** A webhook to call to transform the input. */
  webhook?: WebhookConfig | undefined;
}

/** OutputTransformer defines how to parse an output text into structured data. */
export interface OutputTransformer {
  /** The format of the upstream service's output. */
  format: OutputTransformer_OutputFormat;
  /**
   * A map of field names to the extraction expressions.
   * The interpretation of the expression depends on the 'format':
   * - JSON: JSONPath expressions.
   * - XML: XPath expressions.
   * - TEXT: Regular expressions (first capture group is used).
   */
  extractionRules: { [key: string]: string };
  /**
   * An optional template to render the extracted data into a final string.
   * If this is not provided, the raw extracted data will be returned.
   */
  template: string;
  /**
   * The JQ query to transform the output.
   * Only used when format is JQ.
   */
  jqQuery: string;
}

export enum OutputTransformer_OutputFormat {
  /** JSON - The output is JSON, which will be parsed using JSONPath expressions. */
  JSON = 0,
  /** XML - The output is XML, which will be parsed using XPath expressions. */
  XML = 1,
  /** TEXT - The output is plain text, which will be parsed using regex. */
  TEXT = 2,
  /** RAW_BYTES - The output is raw bytes, no parsing will be performed. */
  RAW_BYTES = 3,
  /** JQ - The output is JSON, which will be transformed using a JQ query. */
  JQ = 4,
  UNRECOGNIZED = -1,
}

export function outputTransformer_OutputFormatFromJSON(object: any): OutputTransformer_OutputFormat {
  switch (object) {
    case 0:
    case "JSON":
      return OutputTransformer_OutputFormat.JSON;
    case 1:
    case "XML":
      return OutputTransformer_OutputFormat.XML;
    case 2:
    case "TEXT":
      return OutputTransformer_OutputFormat.TEXT;
    case 3:
    case "RAW_BYTES":
      return OutputTransformer_OutputFormat.RAW_BYTES;
    case 4:
    case "JQ":
      return OutputTransformer_OutputFormat.JQ;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OutputTransformer_OutputFormat.UNRECOGNIZED;
  }
}

export function outputTransformer_OutputFormatToJSON(object: OutputTransformer_OutputFormat): string {
  switch (object) {
    case OutputTransformer_OutputFormat.JSON:
      return "JSON";
    case OutputTransformer_OutputFormat.XML:
      return "XML";
    case OutputTransformer_OutputFormat.TEXT:
      return "TEXT";
    case OutputTransformer_OutputFormat.RAW_BYTES:
      return "RAW_BYTES";
    case OutputTransformer_OutputFormat.JQ:
      return "JQ";
    case OutputTransformer_OutputFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OutputTransformer_ExtractionRulesEntry {
  key: string;
  value: string;
}

/** GrpcCallDefinition describes how to map an MCP call to a specific gRPC method. */
export interface GrpcCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** The fully-qualified gRPC service name. */
  service: string;
  /** The name of the gRPC method to call. */
  method: string;
  /**
   * Note: For gRPC, parameter mapping is typically done by matching field names
   * between the MCP input schema and the gRPC request message.
   * Caching configuration to improve performance and reduce load on the upstream.
   */
  cache?:
    | CacheConfig
    | undefined;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/**
 * OpenAPICallDefinition describes a call derived from an OpenAPI specification.
 * This is often used for discovery rather than manual configuration.
 */
export interface OpenAPICallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** An optional input transformer to generate the request body. */
  inputTransformer?:
    | InputTransformer
    | undefined;
  /** An optional output transformer to parse the response body. */
  outputTransformer?:
    | OutputTransformer
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/** MCPCallDefinition describes how to map an MCP call to a specific MCP tool. */
export interface MCPCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** An optional input transformer to generate the request body. */
  inputTransformer?:
    | InputTransformer
    | undefined;
  /** An optional output transformer to parse the response body. */
  outputTransformer?:
    | OutputTransformer
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/** GraphQLCallDefinition describes a call derived from a GraphQL introspection query. */
export interface GraphQLCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** The GraphQL query to execute. */
  query: string;
  /** The GraphQL operation name. */
  operationName: string;
  /** A map of variables for the GraphQL query. */
  variables?:
    | { [key: string]: any }
    | undefined;
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The selection set for the GraphQL query. */
  selectionSet: string;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/** SqlCallDefinition describes how to map an MCP call to a SQL query. */
export interface SqlCallDefinition {
  /** The unique identifier for the call. */
  id: string;
  /** The SQL query to execute. Use placeholders like $1, $2 or ? based on the driver. */
  query: string;
  /**
   * The order of input properties to map to query parameters.
   * For example, if the query uses $1 and $2, and this list is ["userId", "active"],
   * then input.userId will be passed as $1 and input.active as $2.
   */
  parameterOrder: string[];
  /** Caching configuration to improve performance and reduce load on the upstream. */
  cache?:
    | CacheConfig
    | undefined;
  /** The schema for the input parameters required by the call. */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** The schema for the output of the call. */
  outputSchema?: { [key: string]: any } | undefined;
}

/** ParameterSchema defines the schema for a single parameter, following Google's JSON schema. */
export interface ParameterSchema {
  /** The name of the input parameter from the MCP call. */
  name: string;
  /** A description of the parameter. */
  description: string;
  /** The data type of the parameter. */
  type: ParameterType;
  /** Whether the parameter is required. */
  isRequired: boolean;
  /** The default value of the parameter. */
  defaultValue?: any | undefined;
}

/** HttpParameterMapping defines how to place an input parameter into an HTTP request. */
export interface HttpParameterMapping {
  /** The schema for the parameter. */
  schema?:
    | ParameterSchema
    | undefined;
  /** A secret value to use for the parameter. */
  secret?:
    | SecretValue
    | undefined;
  /** Whether to disable automatic URL escaping for this parameter. */
  disableEscape: boolean;
}

/** WebsocketParameterMapping defines how to place an input parameter into a websocket message. */
export interface WebsocketParameterMapping {
  /** The schema for the parameter. */
  schema?:
    | ParameterSchema
    | undefined;
  /** A secret value to use for the parameter. */
  secret?: SecretValue | undefined;
}

/** WebrtcParameterMapping defines how to place an input parameter into a webrtc message. */
export interface WebrtcParameterMapping {
  /** The schema for the parameter. */
  schema?:
    | ParameterSchema
    | undefined;
  /** A secret value to use for the parameter. */
  secret?: SecretValue | undefined;
}

/** CommandLineParameterMapping defines how to pass an input parameter to a stdio process. */
export interface CommandLineParameterMapping {
  /** The schema for the parameter. */
  schema?:
    | ParameterSchema
    | undefined;
  /** A secret value to use for the parameter. */
  secret?: SecretValue | undefined;
}

/** CacheConfig is a dummy message for now. */
export interface CacheConfig {
  isEnabled: boolean;
  ttl?: Duration | undefined;
  strategy: string;
  semanticConfig?: SemanticCacheConfig | undefined;
}

export interface SemanticCacheConfig {
  /**
   * Provider for embeddings (e.g., "openai", "vertexai", "ollama", "http")
   * Deprecated: Use provider_config instead.
   */
  provider: string;
  /**
   * Model name (e.g., "text-embedding-3-small")
   * Deprecated: Use provider_config instead.
   */
  model: string;
  /**
   * API Key (can be a reference to environment variable or secret)
   * Deprecated: Use provider_config instead.
   */
  apiKey?:
    | SecretValue
    | undefined;
  /** Similarity threshold (0.0 to 1.0). Higher means stricter matching. */
  similarityThreshold: number;
  openai?: OpenAIEmbeddingProviderConfig | undefined;
  ollama?: OllamaEmbeddingProviderConfig | undefined;
  http?:
    | HttpEmbeddingProviderConfig
    | undefined;
  /**
   * Path to SQLite database file for persistent storage.
   * If empty, the cache will be in-memory only.
   */
  persistencePath: string;
}

export interface OpenAIEmbeddingProviderConfig {
  model: string;
  apiKey?: SecretValue | undefined;
}

export interface OllamaEmbeddingProviderConfig {
  model: string;
  baseUrl: string;
}

export interface HttpEmbeddingProviderConfig {
  url: string;
  headers: { [key: string]: string };
  bodyTemplate: string;
  responseJsonPath: string;
}

export interface HttpEmbeddingProviderConfig_HeadersEntry {
  key: string;
  value: string;
}

function createBaseHttpCallDefinition(): HttpCallDefinition {
  return {
    id: "",
    endpointPath: "",
    method: 0,
    parameters: [],
    inputTransformer: undefined,
    outputTransformer: undefined,
    cache: undefined,
    inputSchema: undefined,
    outputSchema: undefined,
  };
}

export const HttpCallDefinition: MessageFns<HttpCallDefinition> = {
  encode(message: HttpCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.endpointPath !== "") {
      writer.uint32(26).string(message.endpointPath);
    }
    if (message.method !== 0) {
      writer.uint32(32).int32(message.method);
    }
    for (const v of message.parameters) {
      HttpParameterMapping.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.inputTransformer !== undefined) {
      InputTransformer.encode(message.inputTransformer, writer.uint32(50).fork()).join();
    }
    if (message.outputTransformer !== undefined) {
      OutputTransformer.encode(message.outputTransformer, writer.uint32(58).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(66).fork()).join();
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(74).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endpointPath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parameters.push(HttpParameterMapping.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputTransformer = InputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputTransformer = OutputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      endpointPath: isSet(object.endpoint_path) ? globalThis.String(object.endpoint_path) : "",
      method: isSet(object.method) ? httpCallDefinition_HttpMethodFromJSON(object.method) : 0,
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => HttpParameterMapping.fromJSON(e))
        : [],
      inputTransformer: isSet(object.input_transformer)
        ? InputTransformer.fromJSON(object.input_transformer)
        : undefined,
      outputTransformer: isSet(object.output_transformer)
        ? OutputTransformer.fromJSON(object.output_transformer)
        : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: HttpCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.endpointPath !== "") {
      obj.endpoint_path = message.endpointPath;
    }
    if (message.method !== 0) {
      obj.method = httpCallDefinition_HttpMethodToJSON(message.method);
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => HttpParameterMapping.toJSON(e));
    }
    if (message.inputTransformer !== undefined) {
      obj.input_transformer = InputTransformer.toJSON(message.inputTransformer);
    }
    if (message.outputTransformer !== undefined) {
      obj.output_transformer = OutputTransformer.toJSON(message.outputTransformer);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpCallDefinition>, I>>(base?: I): HttpCallDefinition {
    return HttpCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpCallDefinition>, I>>(object: I): HttpCallDefinition {
    const message = createBaseHttpCallDefinition();
    message.id = object.id ?? "";
    message.endpointPath = object.endpointPath ?? "";
    message.method = object.method ?? 0;
    message.parameters = object.parameters?.map((e) => HttpParameterMapping.fromPartial(e)) || [];
    message.inputTransformer = (object.inputTransformer !== undefined && object.inputTransformer !== null)
      ? InputTransformer.fromPartial(object.inputTransformer)
      : undefined;
    message.outputTransformer = (object.outputTransformer !== undefined && object.outputTransformer !== null)
      ? OutputTransformer.fromPartial(object.outputTransformer)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseWebsocketCallDefinition(): WebsocketCallDefinition {
  return {
    id: "",
    parameters: [],
    inputTransformer: undefined,
    outputTransformer: undefined,
    cache: undefined,
    inputSchema: undefined,
    outputSchema: undefined,
  };
}

export const WebsocketCallDefinition: MessageFns<WebsocketCallDefinition> = {
  encode(message: WebsocketCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.parameters) {
      WebsocketParameterMapping.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.inputTransformer !== undefined) {
      InputTransformer.encode(message.inputTransformer, writer.uint32(34).fork()).join();
    }
    if (message.outputTransformer !== undefined) {
      OutputTransformer.encode(message.outputTransformer, writer.uint32(42).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(50).fork()).join();
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(58).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameters.push(WebsocketParameterMapping.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputTransformer = InputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.outputTransformer = OutputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsocketCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => WebsocketParameterMapping.fromJSON(e))
        : [],
      inputTransformer: isSet(object.input_transformer)
        ? InputTransformer.fromJSON(object.input_transformer)
        : undefined,
      outputTransformer: isSet(object.output_transformer)
        ? OutputTransformer.fromJSON(object.output_transformer)
        : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: WebsocketCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => WebsocketParameterMapping.toJSON(e));
    }
    if (message.inputTransformer !== undefined) {
      obj.input_transformer = InputTransformer.toJSON(message.inputTransformer);
    }
    if (message.outputTransformer !== undefined) {
      obj.output_transformer = OutputTransformer.toJSON(message.outputTransformer);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebsocketCallDefinition>, I>>(base?: I): WebsocketCallDefinition {
    return WebsocketCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebsocketCallDefinition>, I>>(object: I): WebsocketCallDefinition {
    const message = createBaseWebsocketCallDefinition();
    message.id = object.id ?? "";
    message.parameters = object.parameters?.map((e) => WebsocketParameterMapping.fromPartial(e)) || [];
    message.inputTransformer = (object.inputTransformer !== undefined && object.inputTransformer !== null)
      ? InputTransformer.fromPartial(object.inputTransformer)
      : undefined;
    message.outputTransformer = (object.outputTransformer !== undefined && object.outputTransformer !== null)
      ? OutputTransformer.fromPartial(object.outputTransformer)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseWebrtcCallDefinition(): WebrtcCallDefinition {
  return {
    id: "",
    parameters: [],
    inputTransformer: undefined,
    outputTransformer: undefined,
    cache: undefined,
    inputSchema: undefined,
    outputSchema: undefined,
  };
}

export const WebrtcCallDefinition: MessageFns<WebrtcCallDefinition> = {
  encode(message: WebrtcCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.parameters) {
      WebrtcParameterMapping.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.inputTransformer !== undefined) {
      InputTransformer.encode(message.inputTransformer, writer.uint32(34).fork()).join();
    }
    if (message.outputTransformer !== undefined) {
      OutputTransformer.encode(message.outputTransformer, writer.uint32(42).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(50).fork()).join();
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(58).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebrtcCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameters.push(WebrtcParameterMapping.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputTransformer = InputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.outputTransformer = OutputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => WebrtcParameterMapping.fromJSON(e))
        : [],
      inputTransformer: isSet(object.input_transformer)
        ? InputTransformer.fromJSON(object.input_transformer)
        : undefined,
      outputTransformer: isSet(object.output_transformer)
        ? OutputTransformer.fromJSON(object.output_transformer)
        : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: WebrtcCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => WebrtcParameterMapping.toJSON(e));
    }
    if (message.inputTransformer !== undefined) {
      obj.input_transformer = InputTransformer.toJSON(message.inputTransformer);
    }
    if (message.outputTransformer !== undefined) {
      obj.output_transformer = OutputTransformer.toJSON(message.outputTransformer);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcCallDefinition>, I>>(base?: I): WebrtcCallDefinition {
    return WebrtcCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcCallDefinition>, I>>(object: I): WebrtcCallDefinition {
    const message = createBaseWebrtcCallDefinition();
    message.id = object.id ?? "";
    message.parameters = object.parameters?.map((e) => WebrtcParameterMapping.fromPartial(e)) || [];
    message.inputTransformer = (object.inputTransformer !== undefined && object.inputTransformer !== null)
      ? InputTransformer.fromPartial(object.inputTransformer)
      : undefined;
    message.outputTransformer = (object.outputTransformer !== undefined && object.outputTransformer !== null)
      ? OutputTransformer.fromPartial(object.outputTransformer)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseCommandLineCallDefinition(): CommandLineCallDefinition {
  return { id: "", parameters: [], cache: undefined, args: [], inputSchema: undefined, outputSchema: undefined };
}

export const CommandLineCallDefinition: MessageFns<CommandLineCallDefinition> = {
  encode(message: CommandLineCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.parameters) {
      CommandLineParameterMapping.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(34).fork()).join();
    }
    for (const v of message.args) {
      writer.uint32(42).string(v!);
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(50).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandLineCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandLineCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameters.push(CommandLineParameterMapping.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandLineCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => CommandLineParameterMapping.fromJSON(e))
        : [],
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: CommandLineCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => CommandLineParameterMapping.toJSON(e));
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandLineCallDefinition>, I>>(base?: I): CommandLineCallDefinition {
    return CommandLineCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandLineCallDefinition>, I>>(object: I): CommandLineCallDefinition {
    const message = createBaseCommandLineCallDefinition();
    message.id = object.id ?? "";
    message.parameters = object.parameters?.map((e) => CommandLineParameterMapping.fromPartial(e)) || [];
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.args = object.args?.map((e) => e) || [];
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseInputTransformer(): InputTransformer {
  return { template: "", webhook: undefined };
}

export const InputTransformer: MessageFns<InputTransformer> = {
  encode(message: InputTransformer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.template !== "") {
      writer.uint32(10).string(message.template);
    }
    if (message.webhook !== undefined) {
      WebhookConfig.encode(message.webhook, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputTransformer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputTransformer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.template = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.webhook = WebhookConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputTransformer {
    return {
      template: isSet(object.template) ? globalThis.String(object.template) : "",
      webhook: isSet(object.webhook) ? WebhookConfig.fromJSON(object.webhook) : undefined,
    };
  },

  toJSON(message: InputTransformer): unknown {
    const obj: any = {};
    if (message.template !== "") {
      obj.template = message.template;
    }
    if (message.webhook !== undefined) {
      obj.webhook = WebhookConfig.toJSON(message.webhook);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputTransformer>, I>>(base?: I): InputTransformer {
    return InputTransformer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputTransformer>, I>>(object: I): InputTransformer {
    const message = createBaseInputTransformer();
    message.template = object.template ?? "";
    message.webhook = (object.webhook !== undefined && object.webhook !== null)
      ? WebhookConfig.fromPartial(object.webhook)
      : undefined;
    return message;
  },
};

function createBaseOutputTransformer(): OutputTransformer {
  return { format: 0, extractionRules: {}, template: "", jqQuery: "" };
}

export const OutputTransformer: MessageFns<OutputTransformer> = {
  encode(message: OutputTransformer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    globalThis.Object.entries(message.extractionRules).forEach(([key, value]: [string, string]) => {
      OutputTransformer_ExtractionRulesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.template !== "") {
      writer.uint32(26).string(message.template);
    }
    if (message.jqQuery !== "") {
      writer.uint32(34).string(message.jqQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputTransformer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputTransformer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = OutputTransformer_ExtractionRulesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.extractionRules[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.template = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jqQuery = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputTransformer {
    return {
      format: isSet(object.format) ? outputTransformer_OutputFormatFromJSON(object.format) : 0,
      extractionRules: isObject(object.extraction_rules)
        ? (globalThis.Object.entries(object.extraction_rules) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      template: isSet(object.template) ? globalThis.String(object.template) : "",
      jqQuery: isSet(object.jq_query) ? globalThis.String(object.jq_query) : "",
    };
  },

  toJSON(message: OutputTransformer): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = outputTransformer_OutputFormatToJSON(message.format);
    }
    if (message.extractionRules) {
      const entries = globalThis.Object.entries(message.extractionRules) as [string, string][];
      if (entries.length > 0) {
        obj.extraction_rules = {};
        entries.forEach(([k, v]) => {
          obj.extraction_rules[k] = v;
        });
      }
    }
    if (message.template !== "") {
      obj.template = message.template;
    }
    if (message.jqQuery !== "") {
      obj.jq_query = message.jqQuery;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputTransformer>, I>>(base?: I): OutputTransformer {
    return OutputTransformer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputTransformer>, I>>(object: I): OutputTransformer {
    const message = createBaseOutputTransformer();
    message.format = object.format ?? 0;
    message.extractionRules = (globalThis.Object.entries(object.extractionRules ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.template = object.template ?? "";
    message.jqQuery = object.jqQuery ?? "";
    return message;
  },
};

function createBaseOutputTransformer_ExtractionRulesEntry(): OutputTransformer_ExtractionRulesEntry {
  return { key: "", value: "" };
}

export const OutputTransformer_ExtractionRulesEntry: MessageFns<OutputTransformer_ExtractionRulesEntry> = {
  encode(message: OutputTransformer_ExtractionRulesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputTransformer_ExtractionRulesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputTransformer_ExtractionRulesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputTransformer_ExtractionRulesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OutputTransformer_ExtractionRulesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputTransformer_ExtractionRulesEntry>, I>>(
    base?: I,
  ): OutputTransformer_ExtractionRulesEntry {
    return OutputTransformer_ExtractionRulesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputTransformer_ExtractionRulesEntry>, I>>(
    object: I,
  ): OutputTransformer_ExtractionRulesEntry {
    const message = createBaseOutputTransformer_ExtractionRulesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGrpcCallDefinition(): GrpcCallDefinition {
  return { id: "", service: "", method: "", cache: undefined, inputSchema: undefined, outputSchema: undefined };
}

export const GrpcCallDefinition: MessageFns<GrpcCallDefinition> = {
  encode(message: GrpcCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.service !== "") {
      writer.uint32(26).string(message.service);
    }
    if (message.method !== "") {
      writer.uint32(34).string(message.method);
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(42).fork()).join();
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(50).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: GrpcCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrpcCallDefinition>, I>>(base?: I): GrpcCallDefinition {
    return GrpcCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrpcCallDefinition>, I>>(object: I): GrpcCallDefinition {
    const message = createBaseGrpcCallDefinition();
    message.id = object.id ?? "";
    message.service = object.service ?? "";
    message.method = object.method ?? "";
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseOpenAPICallDefinition(): OpenAPICallDefinition {
  return {
    id: "",
    inputTransformer: undefined,
    outputTransformer: undefined,
    cache: undefined,
    inputSchema: undefined,
    outputSchema: undefined,
  };
}

export const OpenAPICallDefinition: MessageFns<OpenAPICallDefinition> = {
  encode(message: OpenAPICallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.inputTransformer !== undefined) {
      InputTransformer.encode(message.inputTransformer, writer.uint32(26).fork()).join();
    }
    if (message.outputTransformer !== undefined) {
      OutputTransformer.encode(message.outputTransformer, writer.uint32(34).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(42).fork()).join();
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(50).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenAPICallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenAPICallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputTransformer = InputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputTransformer = OutputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenAPICallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputTransformer: isSet(object.input_transformer)
        ? InputTransformer.fromJSON(object.input_transformer)
        : undefined,
      outputTransformer: isSet(object.output_transformer)
        ? OutputTransformer.fromJSON(object.output_transformer)
        : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: OpenAPICallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputTransformer !== undefined) {
      obj.input_transformer = InputTransformer.toJSON(message.inputTransformer);
    }
    if (message.outputTransformer !== undefined) {
      obj.output_transformer = OutputTransformer.toJSON(message.outputTransformer);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenAPICallDefinition>, I>>(base?: I): OpenAPICallDefinition {
    return OpenAPICallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenAPICallDefinition>, I>>(object: I): OpenAPICallDefinition {
    const message = createBaseOpenAPICallDefinition();
    message.id = object.id ?? "";
    message.inputTransformer = (object.inputTransformer !== undefined && object.inputTransformer !== null)
      ? InputTransformer.fromPartial(object.inputTransformer)
      : undefined;
    message.outputTransformer = (object.outputTransformer !== undefined && object.outputTransformer !== null)
      ? OutputTransformer.fromPartial(object.outputTransformer)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseMCPCallDefinition(): MCPCallDefinition {
  return {
    id: "",
    inputTransformer: undefined,
    outputTransformer: undefined,
    cache: undefined,
    inputSchema: undefined,
    outputSchema: undefined,
  };
}

export const MCPCallDefinition: MessageFns<MCPCallDefinition> = {
  encode(message: MCPCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.inputTransformer !== undefined) {
      InputTransformer.encode(message.inputTransformer, writer.uint32(26).fork()).join();
    }
    if (message.outputTransformer !== undefined) {
      OutputTransformer.encode(message.outputTransformer, writer.uint32(34).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(42).fork()).join();
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(50).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MCPCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMCPCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputTransformer = InputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputTransformer = OutputTransformer.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MCPCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputTransformer: isSet(object.input_transformer)
        ? InputTransformer.fromJSON(object.input_transformer)
        : undefined,
      outputTransformer: isSet(object.output_transformer)
        ? OutputTransformer.fromJSON(object.output_transformer)
        : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: MCPCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputTransformer !== undefined) {
      obj.input_transformer = InputTransformer.toJSON(message.inputTransformer);
    }
    if (message.outputTransformer !== undefined) {
      obj.output_transformer = OutputTransformer.toJSON(message.outputTransformer);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MCPCallDefinition>, I>>(base?: I): MCPCallDefinition {
    return MCPCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MCPCallDefinition>, I>>(object: I): MCPCallDefinition {
    const message = createBaseMCPCallDefinition();
    message.id = object.id ?? "";
    message.inputTransformer = (object.inputTransformer !== undefined && object.inputTransformer !== null)
      ? InputTransformer.fromPartial(object.inputTransformer)
      : undefined;
    message.outputTransformer = (object.outputTransformer !== undefined && object.outputTransformer !== null)
      ? OutputTransformer.fromPartial(object.outputTransformer)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseGraphQLCallDefinition(): GraphQLCallDefinition {
  return {
    id: "",
    query: "",
    operationName: "",
    variables: undefined,
    cache: undefined,
    selectionSet: "",
    inputSchema: undefined,
    outputSchema: undefined,
  };
}

export const GraphQLCallDefinition: MessageFns<GraphQLCallDefinition> = {
  encode(message: GraphQLCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.operationName !== "") {
      writer.uint32(26).string(message.operationName);
    }
    if (message.variables !== undefined) {
      Struct.encode(Struct.wrap(message.variables), writer.uint32(34).fork()).join();
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(42).fork()).join();
    }
    if (message.selectionSet !== "") {
      writer.uint32(50).string(message.selectionSet);
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(58).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GraphQLCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphQLCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operationName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.variables = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.selectionSet = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphQLCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      operationName: isSet(object.operation_name) ? globalThis.String(object.operation_name) : "",
      variables: isObject(object.variables) ? object.variables : undefined,
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      selectionSet: isSet(object.selection_set) ? globalThis.String(object.selection_set) : "",
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: GraphQLCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.operationName !== "") {
      obj.operation_name = message.operationName;
    }
    if (message.variables !== undefined) {
      obj.variables = message.variables;
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.selectionSet !== "") {
      obj.selection_set = message.selectionSet;
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphQLCallDefinition>, I>>(base?: I): GraphQLCallDefinition {
    return GraphQLCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphQLCallDefinition>, I>>(object: I): GraphQLCallDefinition {
    const message = createBaseGraphQLCallDefinition();
    message.id = object.id ?? "";
    message.query = object.query ?? "";
    message.operationName = object.operationName ?? "";
    message.variables = object.variables ?? undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.selectionSet = object.selectionSet ?? "";
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseSqlCallDefinition(): SqlCallDefinition {
  return { id: "", query: "", parameterOrder: [], cache: undefined, inputSchema: undefined, outputSchema: undefined };
}

export const SqlCallDefinition: MessageFns<SqlCallDefinition> = {
  encode(message: SqlCallDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    for (const v of message.parameterOrder) {
      writer.uint32(26).string(v!);
    }
    if (message.cache !== undefined) {
      CacheConfig.encode(message.cache, writer.uint32(34).fork()).join();
    }
    if (message.inputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.inputSchema), writer.uint32(42).fork()).join();
    }
    if (message.outputSchema !== undefined) {
      Struct.encode(Struct.wrap(message.outputSchema), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlCallDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlCallDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameterOrder.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cache = CacheConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlCallDefinition {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      parameterOrder: globalThis.Array.isArray(object?.parameter_order)
        ? object.parameter_order.map((e: any) => globalThis.String(e))
        : [],
      cache: isSet(object.cache) ? CacheConfig.fromJSON(object.cache) : undefined,
      inputSchema: isObject(object.input_schema) ? object.input_schema : undefined,
      outputSchema: isObject(object.output_schema) ? object.output_schema : undefined,
    };
  },

  toJSON(message: SqlCallDefinition): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.parameterOrder?.length) {
      obj.parameter_order = message.parameterOrder;
    }
    if (message.cache !== undefined) {
      obj.cache = CacheConfig.toJSON(message.cache);
    }
    if (message.inputSchema !== undefined) {
      obj.input_schema = message.inputSchema;
    }
    if (message.outputSchema !== undefined) {
      obj.output_schema = message.outputSchema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqlCallDefinition>, I>>(base?: I): SqlCallDefinition {
    return SqlCallDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqlCallDefinition>, I>>(object: I): SqlCallDefinition {
    const message = createBaseSqlCallDefinition();
    message.id = object.id ?? "";
    message.query = object.query ?? "";
    message.parameterOrder = object.parameterOrder?.map((e) => e) || [];
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheConfig.fromPartial(object.cache)
      : undefined;
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputSchema = object.outputSchema ?? undefined;
    return message;
  },
};

function createBaseParameterSchema(): ParameterSchema {
  return { name: "", description: "", type: 0, isRequired: false, defaultValue: undefined };
}

export const ParameterSchema: MessageFns<ParameterSchema> = {
  encode(message: ParameterSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.isRequired !== false) {
      writer.uint32(32).bool(message.isRequired);
    }
    if (message.defaultValue !== undefined) {
      Value.encode(Value.wrap(message.defaultValue), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isRequired = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? parameterTypeFromJSON(object.type) : 0,
      isRequired: isSet(object.is_required) ? globalThis.Boolean(object.is_required) : false,
      defaultValue: isSet(object?.default_value) ? object.default_value : undefined,
    };
  },

  toJSON(message: ParameterSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = parameterTypeToJSON(message.type);
    }
    if (message.isRequired !== false) {
      obj.is_required = message.isRequired;
    }
    if (message.defaultValue !== undefined) {
      obj.default_value = message.defaultValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterSchema>, I>>(base?: I): ParameterSchema {
    return ParameterSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterSchema>, I>>(object: I): ParameterSchema {
    const message = createBaseParameterSchema();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.isRequired = object.isRequired ?? false;
    message.defaultValue = object.defaultValue ?? undefined;
    return message;
  },
};

function createBaseHttpParameterMapping(): HttpParameterMapping {
  return { schema: undefined, secret: undefined, disableEscape: false };
}

export const HttpParameterMapping: MessageFns<HttpParameterMapping> = {
  encode(message: HttpParameterMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== undefined) {
      ParameterSchema.encode(message.schema, writer.uint32(10).fork()).join();
    }
    if (message.secret !== undefined) {
      SecretValue.encode(message.secret, writer.uint32(18).fork()).join();
    }
    if (message.disableEscape !== false) {
      writer.uint32(24).bool(message.disableEscape);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpParameterMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpParameterMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = ParameterSchema.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disableEscape = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpParameterMapping {
    return {
      schema: isSet(object.schema) ? ParameterSchema.fromJSON(object.schema) : undefined,
      secret: isSet(object.secret) ? SecretValue.fromJSON(object.secret) : undefined,
      disableEscape: isSet(object.disable_escape) ? globalThis.Boolean(object.disable_escape) : false,
    };
  },

  toJSON(message: HttpParameterMapping): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = ParameterSchema.toJSON(message.schema);
    }
    if (message.secret !== undefined) {
      obj.secret = SecretValue.toJSON(message.secret);
    }
    if (message.disableEscape !== false) {
      obj.disable_escape = message.disableEscape;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpParameterMapping>, I>>(base?: I): HttpParameterMapping {
    return HttpParameterMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpParameterMapping>, I>>(object: I): HttpParameterMapping {
    const message = createBaseHttpParameterMapping();
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? ParameterSchema.fromPartial(object.schema)
      : undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? SecretValue.fromPartial(object.secret)
      : undefined;
    message.disableEscape = object.disableEscape ?? false;
    return message;
  },
};

function createBaseWebsocketParameterMapping(): WebsocketParameterMapping {
  return { schema: undefined, secret: undefined };
}

export const WebsocketParameterMapping: MessageFns<WebsocketParameterMapping> = {
  encode(message: WebsocketParameterMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== undefined) {
      ParameterSchema.encode(message.schema, writer.uint32(10).fork()).join();
    }
    if (message.secret !== undefined) {
      SecretValue.encode(message.secret, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketParameterMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketParameterMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = ParameterSchema.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsocketParameterMapping {
    return {
      schema: isSet(object.schema) ? ParameterSchema.fromJSON(object.schema) : undefined,
      secret: isSet(object.secret) ? SecretValue.fromJSON(object.secret) : undefined,
    };
  },

  toJSON(message: WebsocketParameterMapping): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = ParameterSchema.toJSON(message.schema);
    }
    if (message.secret !== undefined) {
      obj.secret = SecretValue.toJSON(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebsocketParameterMapping>, I>>(base?: I): WebsocketParameterMapping {
    return WebsocketParameterMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebsocketParameterMapping>, I>>(object: I): WebsocketParameterMapping {
    const message = createBaseWebsocketParameterMapping();
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? ParameterSchema.fromPartial(object.schema)
      : undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? SecretValue.fromPartial(object.secret)
      : undefined;
    return message;
  },
};

function createBaseWebrtcParameterMapping(): WebrtcParameterMapping {
  return { schema: undefined, secret: undefined };
}

export const WebrtcParameterMapping: MessageFns<WebrtcParameterMapping> = {
  encode(message: WebrtcParameterMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== undefined) {
      ParameterSchema.encode(message.schema, writer.uint32(10).fork()).join();
    }
    if (message.secret !== undefined) {
      SecretValue.encode(message.secret, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebrtcParameterMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcParameterMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = ParameterSchema.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcParameterMapping {
    return {
      schema: isSet(object.schema) ? ParameterSchema.fromJSON(object.schema) : undefined,
      secret: isSet(object.secret) ? SecretValue.fromJSON(object.secret) : undefined,
    };
  },

  toJSON(message: WebrtcParameterMapping): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = ParameterSchema.toJSON(message.schema);
    }
    if (message.secret !== undefined) {
      obj.secret = SecretValue.toJSON(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcParameterMapping>, I>>(base?: I): WebrtcParameterMapping {
    return WebrtcParameterMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcParameterMapping>, I>>(object: I): WebrtcParameterMapping {
    const message = createBaseWebrtcParameterMapping();
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? ParameterSchema.fromPartial(object.schema)
      : undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? SecretValue.fromPartial(object.secret)
      : undefined;
    return message;
  },
};

function createBaseCommandLineParameterMapping(): CommandLineParameterMapping {
  return { schema: undefined, secret: undefined };
}

export const CommandLineParameterMapping: MessageFns<CommandLineParameterMapping> = {
  encode(message: CommandLineParameterMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== undefined) {
      ParameterSchema.encode(message.schema, writer.uint32(10).fork()).join();
    }
    if (message.secret !== undefined) {
      SecretValue.encode(message.secret, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandLineParameterMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandLineParameterMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = ParameterSchema.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandLineParameterMapping {
    return {
      schema: isSet(object.schema) ? ParameterSchema.fromJSON(object.schema) : undefined,
      secret: isSet(object.secret) ? SecretValue.fromJSON(object.secret) : undefined,
    };
  },

  toJSON(message: CommandLineParameterMapping): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = ParameterSchema.toJSON(message.schema);
    }
    if (message.secret !== undefined) {
      obj.secret = SecretValue.toJSON(message.secret);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandLineParameterMapping>, I>>(base?: I): CommandLineParameterMapping {
    return CommandLineParameterMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandLineParameterMapping>, I>>(object: I): CommandLineParameterMapping {
    const message = createBaseCommandLineParameterMapping();
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? ParameterSchema.fromPartial(object.schema)
      : undefined;
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? SecretValue.fromPartial(object.secret)
      : undefined;
    return message;
  },
};

function createBaseCacheConfig(): CacheConfig {
  return { isEnabled: false, ttl: undefined, strategy: "", semanticConfig: undefined };
}

export const CacheConfig: MessageFns<CacheConfig> = {
  encode(message: CacheConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isEnabled !== false) {
      writer.uint32(8).bool(message.isEnabled);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(18).fork()).join();
    }
    if (message.strategy !== "") {
      writer.uint32(26).string(message.strategy);
    }
    if (message.semanticConfig !== undefined) {
      SemanticCacheConfig.encode(message.semanticConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CacheConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCacheConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isEnabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.strategy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.semanticConfig = SemanticCacheConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CacheConfig {
    return {
      isEnabled: isSet(object.is_enabled) ? globalThis.Boolean(object.is_enabled) : false,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
      semanticConfig: isSet(object.semantic_config) ? SemanticCacheConfig.fromJSON(object.semantic_config) : undefined,
    };
  },

  toJSON(message: CacheConfig): unknown {
    const obj: any = {};
    if (message.isEnabled !== false) {
      obj.is_enabled = message.isEnabled;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.strategy !== "") {
      obj.strategy = message.strategy;
    }
    if (message.semanticConfig !== undefined) {
      obj.semantic_config = SemanticCacheConfig.toJSON(message.semanticConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CacheConfig>, I>>(base?: I): CacheConfig {
    return CacheConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CacheConfig>, I>>(object: I): CacheConfig {
    const message = createBaseCacheConfig();
    message.isEnabled = object.isEnabled ?? false;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.strategy = object.strategy ?? "";
    message.semanticConfig = (object.semanticConfig !== undefined && object.semanticConfig !== null)
      ? SemanticCacheConfig.fromPartial(object.semanticConfig)
      : undefined;
    return message;
  },
};

function createBaseSemanticCacheConfig(): SemanticCacheConfig {
  return {
    provider: "",
    model: "",
    apiKey: undefined,
    similarityThreshold: 0,
    openai: undefined,
    ollama: undefined,
    http: undefined,
    persistencePath: "",
  };
}

export const SemanticCacheConfig: MessageFns<SemanticCacheConfig> = {
  encode(message: SemanticCacheConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.apiKey !== undefined) {
      SecretValue.encode(message.apiKey, writer.uint32(26).fork()).join();
    }
    if (message.similarityThreshold !== 0) {
      writer.uint32(37).float(message.similarityThreshold);
    }
    if (message.openai !== undefined) {
      OpenAIEmbeddingProviderConfig.encode(message.openai, writer.uint32(42).fork()).join();
    }
    if (message.ollama !== undefined) {
      OllamaEmbeddingProviderConfig.encode(message.ollama, writer.uint32(50).fork()).join();
    }
    if (message.http !== undefined) {
      HttpEmbeddingProviderConfig.encode(message.http, writer.uint32(58).fork()).join();
    }
    if (message.persistencePath !== "") {
      writer.uint32(66).string(message.persistencePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SemanticCacheConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSemanticCacheConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiKey = SecretValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.similarityThreshold = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.openai = OpenAIEmbeddingProviderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ollama = OllamaEmbeddingProviderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.http = HttpEmbeddingProviderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.persistencePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SemanticCacheConfig {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      apiKey: isSet(object.api_key) ? SecretValue.fromJSON(object.api_key) : undefined,
      similarityThreshold: isSet(object.similarity_threshold) ? globalThis.Number(object.similarity_threshold) : 0,
      openai: isSet(object.openai) ? OpenAIEmbeddingProviderConfig.fromJSON(object.openai) : undefined,
      ollama: isSet(object.ollama) ? OllamaEmbeddingProviderConfig.fromJSON(object.ollama) : undefined,
      http: isSet(object.http) ? HttpEmbeddingProviderConfig.fromJSON(object.http) : undefined,
      persistencePath: isSet(object.persistence_path) ? globalThis.String(object.persistence_path) : "",
    };
  },

  toJSON(message: SemanticCacheConfig): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.apiKey !== undefined) {
      obj.api_key = SecretValue.toJSON(message.apiKey);
    }
    if (message.similarityThreshold !== 0) {
      obj.similarity_threshold = message.similarityThreshold;
    }
    if (message.openai !== undefined) {
      obj.openai = OpenAIEmbeddingProviderConfig.toJSON(message.openai);
    }
    if (message.ollama !== undefined) {
      obj.ollama = OllamaEmbeddingProviderConfig.toJSON(message.ollama);
    }
    if (message.http !== undefined) {
      obj.http = HttpEmbeddingProviderConfig.toJSON(message.http);
    }
    if (message.persistencePath !== "") {
      obj.persistence_path = message.persistencePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SemanticCacheConfig>, I>>(base?: I): SemanticCacheConfig {
    return SemanticCacheConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SemanticCacheConfig>, I>>(object: I): SemanticCacheConfig {
    const message = createBaseSemanticCacheConfig();
    message.provider = object.provider ?? "";
    message.model = object.model ?? "";
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? SecretValue.fromPartial(object.apiKey)
      : undefined;
    message.similarityThreshold = object.similarityThreshold ?? 0;
    message.openai = (object.openai !== undefined && object.openai !== null)
      ? OpenAIEmbeddingProviderConfig.fromPartial(object.openai)
      : undefined;
    message.ollama = (object.ollama !== undefined && object.ollama !== null)
      ? OllamaEmbeddingProviderConfig.fromPartial(object.ollama)
      : undefined;
    message.http = (object.http !== undefined && object.http !== null)
      ? HttpEmbeddingProviderConfig.fromPartial(object.http)
      : undefined;
    message.persistencePath = object.persistencePath ?? "";
    return message;
  },
};

function createBaseOpenAIEmbeddingProviderConfig(): OpenAIEmbeddingProviderConfig {
  return { model: "", apiKey: undefined };
}

export const OpenAIEmbeddingProviderConfig: MessageFns<OpenAIEmbeddingProviderConfig> = {
  encode(message: OpenAIEmbeddingProviderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.apiKey !== undefined) {
      SecretValue.encode(message.apiKey, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenAIEmbeddingProviderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenAIEmbeddingProviderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apiKey = SecretValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenAIEmbeddingProviderConfig {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      apiKey: isSet(object.api_key) ? SecretValue.fromJSON(object.api_key) : undefined,
    };
  },

  toJSON(message: OpenAIEmbeddingProviderConfig): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.apiKey !== undefined) {
      obj.api_key = SecretValue.toJSON(message.apiKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenAIEmbeddingProviderConfig>, I>>(base?: I): OpenAIEmbeddingProviderConfig {
    return OpenAIEmbeddingProviderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenAIEmbeddingProviderConfig>, I>>(
    object: I,
  ): OpenAIEmbeddingProviderConfig {
    const message = createBaseOpenAIEmbeddingProviderConfig();
    message.model = object.model ?? "";
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? SecretValue.fromPartial(object.apiKey)
      : undefined;
    return message;
  },
};

function createBaseOllamaEmbeddingProviderConfig(): OllamaEmbeddingProviderConfig {
  return { model: "", baseUrl: "" };
}

export const OllamaEmbeddingProviderConfig: MessageFns<OllamaEmbeddingProviderConfig> = {
  encode(message: OllamaEmbeddingProviderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OllamaEmbeddingProviderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOllamaEmbeddingProviderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OllamaEmbeddingProviderConfig {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      baseUrl: isSet(object.base_url) ? globalThis.String(object.base_url) : "",
    };
  },

  toJSON(message: OllamaEmbeddingProviderConfig): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.baseUrl !== "") {
      obj.base_url = message.baseUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OllamaEmbeddingProviderConfig>, I>>(base?: I): OllamaEmbeddingProviderConfig {
    return OllamaEmbeddingProviderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OllamaEmbeddingProviderConfig>, I>>(
    object: I,
  ): OllamaEmbeddingProviderConfig {
    const message = createBaseOllamaEmbeddingProviderConfig();
    message.model = object.model ?? "";
    message.baseUrl = object.baseUrl ?? "";
    return message;
  },
};

function createBaseHttpEmbeddingProviderConfig(): HttpEmbeddingProviderConfig {
  return { url: "", headers: {}, bodyTemplate: "", responseJsonPath: "" };
}

export const HttpEmbeddingProviderConfig: MessageFns<HttpEmbeddingProviderConfig> = {
  encode(message: HttpEmbeddingProviderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    globalThis.Object.entries(message.headers).forEach(([key, value]: [string, string]) => {
      HttpEmbeddingProviderConfig_HeadersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.bodyTemplate !== "") {
      writer.uint32(26).string(message.bodyTemplate);
    }
    if (message.responseJsonPath !== "") {
      writer.uint32(34).string(message.responseJsonPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpEmbeddingProviderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpEmbeddingProviderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HttpEmbeddingProviderConfig_HeadersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.headers[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bodyTemplate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.responseJsonPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpEmbeddingProviderConfig {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      headers: isObject(object.headers)
        ? (globalThis.Object.entries(object.headers) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      bodyTemplate: isSet(object.body_template) ? globalThis.String(object.body_template) : "",
      responseJsonPath: isSet(object.response_json_path) ? globalThis.String(object.response_json_path) : "",
    };
  },

  toJSON(message: HttpEmbeddingProviderConfig): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.headers) {
      const entries = globalThis.Object.entries(message.headers) as [string, string][];
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.bodyTemplate !== "") {
      obj.body_template = message.bodyTemplate;
    }
    if (message.responseJsonPath !== "") {
      obj.response_json_path = message.responseJsonPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpEmbeddingProviderConfig>, I>>(base?: I): HttpEmbeddingProviderConfig {
    return HttpEmbeddingProviderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpEmbeddingProviderConfig>, I>>(object: I): HttpEmbeddingProviderConfig {
    const message = createBaseHttpEmbeddingProviderConfig();
    message.url = object.url ?? "";
    message.headers = (globalThis.Object.entries(object.headers ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.bodyTemplate = object.bodyTemplate ?? "";
    message.responseJsonPath = object.responseJsonPath ?? "";
    return message;
  },
};

function createBaseHttpEmbeddingProviderConfig_HeadersEntry(): HttpEmbeddingProviderConfig_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpEmbeddingProviderConfig_HeadersEntry: MessageFns<HttpEmbeddingProviderConfig_HeadersEntry> = {
  encode(message: HttpEmbeddingProviderConfig_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpEmbeddingProviderConfig_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpEmbeddingProviderConfig_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpEmbeddingProviderConfig_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpEmbeddingProviderConfig_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpEmbeddingProviderConfig_HeadersEntry>, I>>(
    base?: I,
  ): HttpEmbeddingProviderConfig_HeadersEntry {
    return HttpEmbeddingProviderConfig_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpEmbeddingProviderConfig_HeadersEntry>, I>>(
    object: I,
  ): HttpEmbeddingProviderConfig_HeadersEntry {
    const message = createBaseHttpEmbeddingProviderConfig_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
